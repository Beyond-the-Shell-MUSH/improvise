** LambdaMOO Database, Format Version 13 **
2
5
6
0 values pending finalization
0 clocks
0 queued tasks
0 suspended tasks
0 interrupted tasks
0 active connections with listeners
121
#0
System
16
2
1
2
4
0
4
6
1
3
1
12
1
62
1
76
1
100
1
113
4
0
22
_log_error
5
172
-1
server_started
5
172
-1
do_login_command
5
172
-1
authenticate
2
172
-1
private
5
172
-1
protected
5
172
-1
restrict_to_server
2
172
-1
restrict_to_builtin
2
172
-1
restrict_to_caller
2
172
-1
permit
5
172
-1
check_create_permission
2
172
-1
check_controls
2
172
-1
_unpack_verb_code
2
172
-1
_pack_verb_code
2
172
-1
bf_verb_code verb_code
5
172
-1
bf_set_verb_code set_verb_code
5
172
-1
verb_detail
5
172
-1
_parse_content_type
2
172
-1
_generate_content_type
2
172
-1
verb_commit
5
172
-1
verb_revert
5
172
-1
lookup*_reference
5
172
-1
15
system
server_options
nothing
ambiguous_match
failed_match
passkey_players
disable_passkey_login
external_compilers
last_login_connection
welcome_message
plastic
model
dialog
mustache
alt
32
1
0
2
1
1
1
2
1
1
-1
2
1
1
-2
2
1
1
-3
2
1
4
2
1
5
1
6
5
0
0
0
5
0
10
1
2
application/x-mustache
1
97
2
1
1
-2
2
1
2
Welcome to Stunt!  For information about Stunt, check out http://stunt.io/.  To connect to the server, type "connect <credentials>".
2
1
1
28
26
1
1
65
64
1
1
80
78
1
1
96
94
1
1
106
104
1
5
2
1
5
2
1
5
2
1
5
2
1
5
11
1
5
11
1
5
11
1
5
11
1
5
11
1
5
11
1
4
4
1
22
1
63
1
83
1
84
11
1
5
11
1
5
60
1
5
60
1
5
74
1
5
98
1
5
98
1
#1
Server Options
16
2
1
2
4
0
4
0
4
0
0
8
support_numeric_verbname_strings
protect_verb_code
protect_set_verb_code
max_concat_catchable
fg_seconds
fg_ticks
bg_seconds
bg_ticks
8
0
0
2
1
0
1
2
0
0
1
2
0
0
1
2
0
0
5
2
0
0
60000
2
0
0
3
2
0
0
30000
2
0
#2
Kernel Package
16
2
1
-1
4
8
1
0
1
1
1
3
1
10
1
4
1
7
1
8
1
9
4
0
4
0
0
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
kernel
2
1
2
1.1.1
2
1
4
8
4
2
1
2
2
package
4
2
1
0
2
system
4
2
1
1
2
server_options
4
2
1
3
2
dictionary
4
2
1
10
2
changelog
4
2
1
4
2
object
4
2
1
8
2
shapes
4
2
1
9
2
composed
2
1
4
7
2
system.system
2
system.server_options
2
dictionary.kernel
2
dictionary.object
2
dictionary.shapes
2
dictionary.composed
2
system.passkey_players
2
1
4
0
2
1
4
0
2
1
4
1
2
install-dictionary
2
1
2
The kernel package comprises the minimal set of objects necessary to hack on and/or bootstrap a core.
2
1
4
1
2
Todd Sundsted
2
1
2
http://stunt.io/packages/kernel
2
1
2
FreeBSD License
2
1
#3
Kernel Dictionary
16
2
1
2
4
0
4
0
4
1
1
0
4
handle_uncaught_error
5
172
-1
handle_task_timeout
5
172
-1
server_started
5
172
-1
authenticate
5
172
-1
4
kernel
object
shapes
composed
4
1
3
2
1
1
4
2
1
1
8
2
1
1
9
2
1
#4
Object
144
2
1
2
4
0
1
-1
4
18
1
8
1
9
1
7
1
30
1
31
1
59
1
67
1
68
1
77
1
81
1
82
1
85
1
92
1
93
1
97
1
101
1
102
1
108
0
1
aliases
1
4
0
2
4
#5
Wizard
7
5
1
7
4
0
4
1
1
110
4
0
2
@strip-db-and-shutdown
5
8
-1
huh
5
172
-1
1
passkey
3
0
0
5
0
5
5
4
5
5
4
#6
Programmer
3
6
1
7
4
0
4
1
1
109
4
0
0
1
passkey
3
0
0
5
0
5
6
4
5
6
4
#7
Home
0
6
1
2
4
2
1
5
1
6
1
4
4
0
1
eval*uate
5
88
-2
0
1
5
6
4
#8
Shapes, Serialization/Deserialization Library
0
2
1
2
4
0
1
4
4
0
23
_log
5
172
-1
_suspend_if_necessary
2
172
-1
_controls controls
2
164
-1
_controls_verb
5
164
-1
_controls_property
5
164
-1
objects
5
172
-1
read_object
5
172
-1
write_object
5
172
-1
_parent_property_info
5
172
-1
_values
5
172
-1
values
5
172
-1
read_value
5
172
-1
write_value
5
172
-1
_write_parents
5
172
-1
_write_player
5
172
-1
read_verb
5
172
-1
write_verb
5
172
-1
read_property
5
172
-1
write_property
5
172
-1
bare_object
2
172
-1
add_value
2
172
-1
add_property_definition
2
172
-1
add_verb_definition
2
172
-1
0
1
5
2
4
#9
Composed, Component Library
0
2
1
2
4
0
1
4
4
0
45
_log
5
172
-1
_move
5
172
-1
_suspend_if_necessary
2
172
-1
_parse_specifier
2
172
-1
_parse_operation
2
172
-1
_parse_version
2
172
-1
_compare_versions
2
172
-1
_sort_versions
2
172
-1
_match match
2
172
-1
_map_specifier
2
172
-1
_unmap_specifier
2
172
-1
_install
2
172
-1
_uninstall
2
172
-1
_find_requires_provider
2
172
-1
reinitialize
2
172
-1
_check_required_provides
2
172
-1
_check_provided_requires
2
172
-1
_generate_global_mapping_keyed_on_object_number
5
172
-1
_generate_global_mapping_keyed_on_identifier
5
172
-1
_map
2
172
-1
_lookup_by_object_number
2
172
-1
_lookup_by_label
2
172
-1
_is_ancestor
2
172
-1
_contents
2
172
-1
install
5
172
-1
uninstall
5
172
-1
delete
5
172
-1
_set_seconds_and_ticks
5
172
-1
_reset_seconds_and_ticks
5
172
-1
import
5
172
-1
export
5
172
-1
_fetch_from_archive
5
172
-1
fetch_index
2
172
-1
fetch_package_to_cache
2
172
-1
import_package_from_archive
5
172
-1
import_package_from_cache
5
172
-1
export_package_to_cache
5
172
-1
import_package_from_file
5
172
-1
export_package_to_file
5
172
-1
pretty_print_cached_package
5
172
-1
@install
5
156
0
@uninstall
5
156
0
@list
5
156
0
_do_instructions
5
172
-1
_undo_instructions
5
172
-1
9
packages
provides_cache
requires_cache
last_fetch_index
archived
cached
archive_host
archive_port
archive_base_uri
10
4
13
1
2
1
11
1
26
1
57
1
60
1
64
1
74
1
78
1
88
1
94
1
98
1
104
1
111
2
0
10
13
2
alt
10
1
2
0.0.3
4
1
1
104
2
application
10
1
2
0.0.7
4
1
1
111
2
ask
10
1
2
0.0.1
4
1
1
60
2
dialog
10
1
2
0.0.5
4
1
1
78
2
dialog_extras
10
1
2
0.0.4
4
1
1
88
2
identity
10
1
2
0.0.2
4
1
1
98
2
kernel
10
1
2
1.1.1
4
1
1
2
2
model
10
1
2
0.0.1
4
1
1
64
2
mustache
10
1
2
1.0.1
4
1
1
94
2
persistent
10
1
2
0.0.2
4
1
1
74
2
plastic
10
1
2
0.0.1
4
1
1
26
2
primitive
10
1
2
0.0.2
4
1
1
11
2
text_tools
10
1
2
0.0.1
4
1
1
57
2
0
10
7
2
ask
10
1
2
0.0.1
4
1
1
64
2
dialog
10
1
2
0.0.5
4
2
1
88
1
111
2
dialog_extras
10
1
2
0.0.4
4
1
1
111
2
kernel
10
1
2
1.1.1
4
11
1
11
1
26
1
57
1
60
1
64
1
74
1
78
1
88
1
94
1
98
1
104
2
plastic
10
1
2
0.0.1
4
1
1
104
2
primitive
10
1
2
0.0.2
4
7
1
26
1
57
1
60
1
78
1
88
1
94
1
104
2
text_tools
10
1
2
0.0.1
4
1
1
104
2
0
0
1355749135
2
0
10
35
2
aloha
10
2
2
0.0.1
2
packages/4d0gc3mrdv.json
2
0.0.2
2
packages/83rpjnd7ng.json
2
alt
10
3
2
0.0.1
2
packages/alt_0_0_1.json
2
0.0.2
2
packages/alt_0_0_2.json
2
0.0.3
2
packages/alt_0.0.3.json
2
ask
10
1
2
0.0.1
2
packages/ask_0_0_1.json
2
ask_tests
10
1
2
0.0.1
2
packages/ask_tests_0_0_1.json
2
autoport
10
3
2
0.0.1
2
packages/dc2brcceev.json
2
0.0.2
2
packages/jfyf7t2wlf.json
2
0.0.3
2
packages/fd5jpcg8w7.json
2
bad
10
1
2
1.2.3
2
packages/bad.json
2
checkpointer
10
5
2
0.0.1
2
packages/lhr8cbgcr7.json
2
0.0.2
2
packages/ss1vlqdq1g.json
2
0.0.3
2
packages/o3dfn0dr7a.json
2
0.0.4
2
packages/lvid3c7ygf.json
2
0.0.5
2
packages/xuwxcs9icv.json
2
core
10
3
2
1.0.3
2
packages/edw48mlmar.json
2
1.0.4
2
packages/tvghx595ft.json
2
1.0.5
2
packages/nuc67gn3gu.json
2
core_tests
10
4
2
1.0.1
2
packages/t8qkzgowjr.json
2
1.0.2
2
packages/ra07w4xpvv.json
2
1.0.3
2
packages/56i6p1b5xu.json
2
1.0.4
2
packages/cijzlno0id.json
2
dialog
10
4
2
0.0.1
2
packages/dialog_0_0_1.json
2
0.0.3
2
packages/dialog_0_0_3.json
2
0.0.4
2
packages/dialog_0_0_4.json
2
0.0.5
2
packages/dialog_0_0_5.json
2
dialog_extras
10
4
2
0.0.1
2
packages/dialog_extras_0_0_1.json
2
0.0.2
2
packages/dialog_extras_0_0_2.json
2
0.0.3
2
packages/dialog_extras_0.0.3.json
2
0.0.4
2
packages/dialog_extras_0_0_4.json
2
dialog_tests
10
1
2
0.0.1
2
packages/dialog_tests_0.0.1.json
2
foobar
10
3
2
1.2.3
2
packages/foobar1.json
2
2.3.4
2
packages/foobar2.json
2
3.4.5
2
packages/foobar3.json
2
identity
10
2
2
0.0.1
2
packages/identity_0_0_1.json
2
0.0.2
2
packages/identity_0_0_2.json
2
kernel
10
8
2
1.0.3
2
packages/z8ztq1w6t5.json
2
1.0.4
2
packages/ok94lc4g38.json
2
1.0.5
2
packages/nodlg69qcb.json
2
1.0.6
2
packages/kernel_1_0_6.json
2
1.0.7
2
packages/kernel_1_0_7.json
2
1.0.8
2
packages/kernel_1_0_8.json
2
1.1.0
2
packages/kernel_1_1_0.json
2
1.1.1
2
packages/kernel_1.1.1.json
2
kernel_tests
10
4
2
1.0.6
2
packages/uxbi9txvay.json
2
1.0.7
2
packages/c7knvmn231.json
2
1.0.8
2
packages/ylkxeegnke.json
2
1.0.9
2
packages/kernel_tests_1_0_9.json
2
lambdacore
10
5
2
0.0.1
2
packages/rg8dm92s7y.json
2
0.0.2
2
packages/kdklzgfe1a.json
2
0.0.3
2
packages/nvnt0s221h.json
2
0.0.4
2
packages/2u1e6sdlih.json
2
0.0.5
2
packages/lambdacore_0_0_5.json
2
martian
10
1
2
0.0.1
2
packages/0bd9syaqvj.json
2
model
10
1
2
0.0.1
2
packages/model_0_0_1.json
2
model_tests
10
1
2
0.0.1
2
packages/model_tests_0_0_1.json
2
mustache
10
3
2
0.0.1
2
packages/mustache_0_0_1.json
2
1.0.0
2
packages/mustache_1_0_0.json
2
1.0.1
2
packages/mustache_1.0.1.json
2
mustache_tests
10
3
2
0.0.1
2
packages/mustache_tests_0_0_1.json
2
1.0.0
2
packages/mustache_tests_1_0_0.json
2
1.0.1
2
packages/mustache_tests_1.0.1.json
2
mysqlfrob
10
2
2
0.0.0
2
packages/mysqlfrob_0_0_0.json
2
0.0.1
2
packages/mysqlfrob_0_0_1.json
2
no_description
10
1
2
1.2.3
2
packages/no_description.json
2
persistent
10
2
2
0.0.1
2
packages/persistent_0_0_1.json
2
0.0.2
2
packages/persistent_0_0_2.json
2
plastic
10
2
2
0.0.0
2
packages/plastic_0_0_0.json
2
0.0.1
2
packages/plastic_0.0.1.json
2
plastic_tests
10
1
2
0.0.1
2
packages/plastic_tests_0.0.1.json
2
primitive
10
3
2
0.0.0
2
packages/primitive_0_0_0.json
2
0.0.1
2
packages/primitive_0_0_1.json
2
0.0.2
2
packages/primitive_0_0_2.json
2
primitive_tests
10
2
2
0.0.1
2
packages/primitive_tests_0_0_1.json
2
0.0.2
2
packages/primitive_tests_0_0_2.json
2
text_tools
10
1
2
0.0.1
2
packages/text_tools_0_0_1.json
2
text_tools_tests
10
1
2
0.0.1
2
packages/text_tools_tests_0_0_1.json
2
unit
10
4
2
1.0.2
2
packages/4thastwvyi.json
2
1.0.3
2
packages/el0h73p9zb.json
2
1.0.4
2
packages/unit_1_0_4.json
2
1.0.5
2
packages/unit_1_0_5.json
2
unit_test
10
1
2
1.0.1
2
packages/gb4sstekz2.json
2
wearable_app
10
2
2
0.0.1
2
packages/wearable_app_0_0_1.json
2
0.0.2
2
packages/wearable_app_0_0_2.json
2
wizard
10
1
2
0.0.0
2
packages/wizard.json
2
0
10
0
2
0
2
stunt.io
2
0
0
80
2
0
2
/v1
2
0
5
2
4
#10
Changelog
16
2
1
2
4
0
1
-1
4
0
1
log
2
172
-1
54
1311681611
1311705199
1313452513
1315679164
1315956214
1316093967
1316094064
1317297266
1317487599
1317741809
1319025014
1319537884
1320954195
1321316054
1321356258
1321643106
1321643582
1323085326
1323087749
1328836140
1329004700
1329006449
1329757584
1329871032
1329874322
1331122162
1336415098
1336415121
1336415146
1336420618
1337254948
1337555791
1338032579
1338035085
1338035909
1338138322
1338138532
1338169765
1338239921
1338256684
1338511433
1338810704
1338810739
1338986468
1339116074
1339119035
1339159099
1339716849
1341319605
1341918651
1341919633
1352859577
1354716719
1355401890
54
2
Added code to disable login by passkey players.
2
1
2
Added code to write a warning to the log when passkey authentication is enabled.
2
1
2
Moved passkey_login and passkey_players to the system object (#0) so that they are harder to subvert.
2
1
2
Updated `strip-core-and-shutdown' verb to reflect passkey changes.
2
1
2
Fixed incorrect implementation of specified test for a built-in function entry.
2
1
2
Added kernel support for enhanced verb programming.
2
1
2
Removed all verbs on core wiz/prog location except `map' and `eval'.
2
1
2
Added support for `chunk_length'.
2
1
2
Added support for `content_type'.
2
1
2
Removed `map' verb from core wiz/prog location.
2
1
2
Changed `restrict_to_caller' to check the object on which the verb was defined, instead of used.
2
1
2
Fixed scope bug in `$lookup()'.
2
1
2
Added `$configuration' -- package independent, per-environment, per-server configuration goes/stays here.
2
1
2
`$lookup()' now allows wizards to specify the package to search.
2
1
2
`$composed' no longer assumes the existence of `$sysobj'.
2
1
2
Remove `$configuration' -- replaced it with an app-specific property.
2
1
2
Added `import_package_from_file()' and `export_package_to_file' to `$composed'.
2
1
2
Added a welcome message and cleaned up `do_login_command()' and `authenticate()'.
2
1
2
Shape" is now called "Shapes".
2
1
2
Reset `#0.last_login_connection' on server start.
2
1
2
Tweaks to use the new for loop syntax.
2
1
2
Moved verb `audit' out of $composed.
2
1
2
`$verb_detail()' handles the case where `caller_perms()' is `$nothing'.
2
1
2
Added `fg/bg_seconds', `fg/bg_ticks' and `max_concat_catchable' properties to `$server_options'.
2
1
2
In the `@import' command, set the seconds/ticks to a large number so suspending is not necessary.
2
1
2
Fixed `reinitialize()' so that it was smarter with `args'.
2
1
2
`$composed' defaults to the existing content type if none is specified.
2
1
2
Verb metadata includes the sha1 of the verb source.
2
1
2
`$verb_detail()' returns the verb metadata.
2
1
2
In `$composed', better error messages when `relocate' holds a bad reference.
2
1
2
Promoted `$shapes:_controls()' to public and reduced perms.
2
1
2
Fixed regular expressions that were matching "." instead of "%.".
2
1
2
Made the default behavior of `bf_verb_code()' match the builtin.
2
1
2
Options should be dashed not underscored.
2
1
2
The fourth arg is the content type.
2
1
2
Added `state' and `revision' to verb metadata, and added verb version control verbs.
2
1
2
Added `updated_by' to verb metadata.
2
1
2
Use `read_http()' in `_fetch_from_archive()'.
2
1
2
Moved instruction handling into `install()' and `uninstall()'/`delete()'.
2
1
2
Make sure the player isn't inside of the package he/she/it is about to delete.
2
1
2
Handle options correctly on install with implicit identifier and version.
2
1
2
Added package-scoped lookup (e.g. `$lookup("object|kernel")').
2
1
2
Moved `$lookup_reference()' to `$system'.
2
1
2
Properly check the file handle when importing/exporting from/to a file.
2
1
2
Don't include unnecessary metadata in output from `read_verb()'.
2
1
2
Do not version or stamp verbs on `import()'.
2
1
2
`$verb_revert()' now reverts the raw verb code, too.
2
1
2
Fixed bug in tilde handling in `_fetch_from_archive()'.
2
1
2
Added ticks/seconds checks in `_unpack/_pack_verb_code()'.
2
1
2
Handle errors fetching from the archive better.
2
1
2
Lookup objects in an object's package even if the specified is explicit.
2
1
2
Give `$protected()' and `$private()' wiz-perms so that they can inspect anonymous objects.
2
1
2
Give `$permit()' wiz-perms so that it can inspect anonymous objects.
2
1
2
Changed the requirement for compiler output in `set_verb_code()'.
2
1
#11
Primitive Package
0
11
1
-1
4
14
1
12
1
13
1
14
1
15
1
16
1
17
1
18
1
19
1
20
1
21
1
22
1
23
1
24
1
25
1
-1
4
0
0
10
identifier
version
manifest
relocate
requires
instructions
description
authors
homepage
license
10
2
primitive
11
1
2
0.0.2
11
1
4
9
4
2
1
11
2
package
4
2
1
12
2
dictionary
4
2
1
15
2
int_proto
4
2
1
16
2
float_proto
4
2
1
18
2
str_proto
4
2
1
19
2
err_proto
4
2
1
20
2
list_proto
4
2
1
21
2
map_proto
4
2
1
22
2
lambda_proto
11
1
4
8
2
dictionary.int_proto
2
dictionary.float_proto
2
dictionary.str_proto
2
dictionary.err_proto
2
dictionary.list_proto
2
dictionary.map_proto
2
dictionary.lambda_proto
2
dictionary.frobs
11
1
4
1
4
2
2
kernel
2
>= 1.0.4
11
1
4
1
2
install-dictionary
11
1
2
The primitive package comprises prototype objects for LambdaMOO primitive data-types, utility operations on primitives, and objects for basic functional-style programming.
11
1
4
1
2
Todd Sundsted
11
1
2
http://stunt.io/packages/primitive
11
1
2
FreeBSD License
11
1
#12
Primitive Dictionary
0
11
1
11
4
0
1
-1
4
1
1
0
1
lambda
11
172
-1
8
int_proto
float_proto
str_proto
err_proto
list_proto
map_proto
frobs
lambda_proto
8
1
15
11
1
1
16
11
1
1
18
11
1
1
19
11
1
1
23
11
1
1
24
11
1
4
1
1
22
11
1
1
22
11
1
#13
Base Primitive
0
11
1
11
4
0
1
-1
4
6
1
15
1
16
1
18
1
19
1
20
1
21
3
_suspend_if_necessary
11
172
-1
type_of typeof
11
172
-1
to_json tojson
11
172
-1
0
0
#14
Numeric Primitive
0
11
1
11
4
0
1
-1
4
2
1
15
1
16
1
abs
11
172
-1
0
0
#15
Integer Prototype
0
11
1
11
4
0
4
2
1
13
1
14
4
0
2
up_to upto
5
172
-1
down_to downto
5
172
-1
0
0
#16
Float Prototype
0
11
1
11
4
0
4
2
1
13
1
14
4
0
0
0
0
#17
Sequence Primitive
0
11
1
11
4
0
1
-1
4
3
1
18
1
20
1
21
10
_lambdafy
11
172
-1
each
5
172
-1
collect map
5
172
-1
inject reduce fold
5
172
-1
detect find
5
172
-1
select find_all
5
172
-1
reject
5
172
-1
every
5
172
-1
some
5
172
-1
length
11
172
-1
0
0
#18
String Prototype
0
11
1
11
4
0
4
2
1
13
1
17
4
0
7
to_lambda tolambda
11
172
-1
eval
5
172
-1
index rindex match rmatch
11
172
-1
split explode
11
172
-1
trim triml trimr
11
172
-1
strsub
11
172
-1
strtr
11
172
-1
0
0
#19
Error Prototype
0
11
1
11
4
0
4
1
1
13
4
0
0
0
0
#20
List Prototype
0
11
1
11
4
0
4
2
1
13
1
17
4
1
1
23
12
to_lambda tolambda
11
172
-1
eval
5
172
-1
setadd
11
172
-1
setremove
11
172
-1
union
11
172
-1
intersection
11
172
-1
difference
11
172
-1
join
11
172
-1
sort
11
172
-1
reverse
11
172
-1
slice
11
172
-1
flatten
11
172
-1
0
0
#21
Map Prototype
0
11
1
11
4
0
4
2
1
13
1
17
4
1
1
24
6
keys
11
172
-1
values
11
172
-1
delete
11
172
-1
value_by_path
11
172
-1
set_value_by_path
11
172
-1
merge
11
172
-1
0
0
#22
Lambda Prototype
0
11
1
11
4
0
1
-1
4
0
8
create
11
172
-1
type_of typeof
11
172
-1
to_lambda tolambda
11
172
-1
_params_and_body
11
172
-1
_prepend_assignments
11
172
-1
partial
11
172
-1
bind
11
172
-1
call
5
172
-1
0
0
#23
List-Based Frob Prototype
0
11
1
11
4
0
4
1
1
20
4
0
1
*
5
172
-1
0
0
#24
Map-Based Frob Prototype
0
11
1
11
4
0
4
1
1
21
4
0
1
*
5
172
-1
0
0
#25
Changelog
0
11
1
11
4
0
1
-1
4
0
0
3
1321837971
1322305336
1329066914
3
2
Added support for functional-style programming via string lambdas.
11
1
2
Implemented first-pass primitives (with tests) including basic support for functional-style programming.
11
1
2
Updated verbs to use the new for loop syntax.
11
1
#26
Plastic, MOOcode Parser Toolkit Package
0
26
1
-1
4
30
1
27
1
28
1
29
1
30
1
31
1
32
1
33
1
34
1
35
1
36
1
37
1
38
1
39
1
40
1
41
1
42
1
43
1
44
1
45
1
46
1
47
1
48
1
49
1
50
1
51
1
52
1
53
1
54
1
55
1
56
1
-1
4
0
0
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
plastic
26
1
2
0.0.1
26
1
4
31
4
2
1
26
2
package
4
2
1
27
2
changelog
4
2
1
28
2
dictionary
4
2
1
29
2
utilities
4
2
1
30
2
compiler
4
2
1
31
2
printer
4
2
1
32
2
tokenizer_proto
4
2
1
33
2
parser_proto
4
2
1
34
2
symbol_proto
4
2
1
35
2
literal_proto
4
2
1
37
2
statement_proto
4
2
1
38
2
operator_proto
4
2
1
39
2
control_flow_statement_proto
4
2
1
41
2
assignment_operator_proto
4
2
1
42
2
prefix_operator_proto
4
2
1
40
2
infix_operator_proto
4
2
1
36
2
name_proto
4
2
1
43
2
bracket_operator_proto
4
2
1
44
2
brace_operator_proto
4
2
1
45
2
if_statement_proto
4
2
1
46
2
invocation_operator_proto
4
2
1
47
2
verb_selector_operator_proto
4
2
1
48
2
property_selector_operator_proto
4
2
1
49
2
error_catching_operator_proto
4
2
1
50
2
traditional_ternary_operator_proto
4
2
1
51
2
for_statement_proto
4
2
1
52
2
loop_statement_proto
4
2
1
53
2
fork_statement_proto
4
2
1
54
2
try_statement_proto
4
2
1
55
2
positional_symbol_proto
4
2
1
56
2
sign_operator_proto
26
1
4
34
2
dictionary.utilities
2
dictionary.compiler
2
dictionary.printer
2
dictionary.tokenizer_proto
2
dictionary.parser_proto
2
dictionary.symbol_proto
2
dictionary.literal_proto
2
dictionary.statement_proto
2
dictionary.operator_proto
2
dictionary.control_flow_statement_proto
2
dictionary.assignment_operator_proto
2
dictionary.prefix_operator_proto
2
dictionary.infix_operator_proto
2
dictionary.name_proto
2
dictionary.bracket_operator_proto
2
dictionary.brace_operator_proto
2
dictionary.if_statement_proto
2
dictionary.invocation_operator_proto
2
dictionary.verb_selector_operator_proto
2
dictionary.property_selector_operator_proto
2
dictionary.error_catching_operator_proto
2
dictionary.traditional_ternary_operator_proto
2
dictionary.for_statement_proto
2
dictionary.loop_statement_proto
2
dictionary.fork_statement_proto
2
dictionary.try_statement_proto
2
dictionary.positional_symbol_proto
2
dictionary.sign_operator_proto
2
utilities.plastic
2
compiler.plastic
2
printer.plastic
2
tokenizer_proto.plastic
2
parser_proto.plastic
2
symbol_proto.plastic
26
1
4
2
4
2
2
kernel
2
>= 1.1.1
4
2
2
primitive
2
>= 0.0.2
26
1
4
0
26
1
4
1
2
install-namespace
26
1
2
Plastic is the MOOcode parser toolkit.  It comprises an extended MOOcode language parser and compiler, and is compatible with the Stunt verb language extension mechanism.
26
1
4
1
2
Todd Sundsted
26
1
2
http://stunt.io/packages/plastic
26
1
2
FreeBSD License
26
1
#27
Changelog
0
26
1
26
4
0
1
-1
4
0
0
4
1331063405
1354983225
1355404149
1355712101
4
2
Initial revision.
26
1
2
First-cut at migration from frobs to anonymous objects.
26
1
2
The first-cut is complete.
26
1
2
Added rudimentary traversal support.
26
1
#28
Dictionary
0
26
1
26
4
0
1
-1
4
0
0
28
utilities
tokenizer_proto
parser_proto
symbol_proto
literal_proto
statement_proto
operator_proto
control_flow_statement_proto
assignment_operator_proto
prefix_operator_proto
infix_operator_proto
name_proto
bracket_operator_proto
brace_operator_proto
if_statement_proto
invocation_operator_proto
verb_selector_operator_proto
property_selector_operator_proto
error_catching_operator_proto
traditional_ternary_operator_proto
for_statement_proto
loop_statement_proto
positional_symbol_proto
fork_statement_proto
try_statement_proto
sign_operator_proto
compiler
printer
28
1
29
26
1
1
32
26
1
1
33
26
1
1
34
26
1
1
35
26
1
1
37
26
1
1
38
26
1
1
39
26
1
1
41
26
1
1
42
26
1
1
40
26
1
1
36
26
1
1
43
26
1
1
44
26
1
1
45
26
1
1
46
26
1
1
47
26
1
1
48
26
1
1
49
26
1
1
50
26
1
1
51
26
1
1
52
26
1
1
55
26
1
1
53
26
1
1
54
26
1
1
56
26
1
1
30
26
1
1
31
26
1
#29
Plastic Utilities
0
26
1
26
4
0
1
-1
4
0
5
parse_map_sequence
26
172
-1
parse_list_sequence
26
172
-1
validate_scattering_pattern
26
172
-1
children
26
172
-1
match
26
172
-1
1
plastic
1
1
28
26
0
#30
MOOcode Compiler
0
26
1
26
4
0
4
1
1
4
4
0
1
compile c
26
172
-1
1
plastic
2
1
28
26
0
5
26
4
#31
Syntax Tree Pretty Printer
0
26
1
26
4
0
4
1
1
4
4
0
2
_print
26
172
-1
print p
26
172
-1
1
plastic
2
1
28
26
0
5
26
4
#32
Tokenizer Prototype
0
26
1
26
4
0
1
-1
4
0
4
_ensure_instance
26
172
-1
create
26
172
-1
advance
26
172
-1
token
26
172
-1
6
plastic
errors
row
column
source
token
6
1
28
26
0
10
19
2
E_ARGS
3
11
2
E_DIV
3
2
2
E_EXEC
3
17
2
E_FILE
3
16
2
E_FLOAT
3
15
2
E_INTRPT
3
18
2
E_INVARG
3
13
2
E_INVIND
3
7
2
E_MAXREC
3
9
2
E_NACC
3
12
2
E_NONE
3
0
2
E_PERM
3
3
2
E_PROPNF
3
4
2
E_QUOTA
3
14
2
E_RANGE
3
10
2
E_RECMOVE
3
8
2
E_TYPE
3
1
2
E_VARNF
3
6
2
E_VERBNF
3
5
26
0
0
1
26
1
0
1
26
1
4
0
26
0
10
0
26
0
#33
Parser Prototype
0
26
1
26
4
0
1
-1
4
0
13
_ensure_instance
26
172
-1
create
26
172
-1
symbol
26
172
-1
reserve_statement reserve_keyword
26
172
-1
make_identifier make_variable
26
172
-1
token
26
172
-1
advance
26
172
-1
expression
26
172
-1
statement
26
172
-1
statements
26
172
-1
variables
26
172
-1
push
26
172
-1
pop
26
172
-1
6
plastic
tokenizer
symbols
token
loop_variables
loop_depth
6
1
28
26
0
1
-1
26
0
10
0
26
1
0
0
26
1
4
0
26
0
0
0
26
0
#34
Symbol Prototype
0
26
1
26
4
0
1
-1
4
6
1
35
1
36
1
38
1
43
1
44
1
55
5
create
26
172
-1
clone
26
172
-1
nud
26
172
-1
led
26
172
-1
p
26
172
-1
9
plastic
id
value
bp
type
reserved
eol
row
column
9
1
28
26
0
0
0
26
1
0
0
26
1
0
0
26
1
0
0
26
1
0
0
26
1
0
0
26
1
0
0
26
1
0
0
26
1
#35
Literal Prototype
0
26
1
26
4
0
4
1
1
34
4
0
2
nud
26
172
-1
p
26
172
-1
0
9
5
26
0
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
#36
Name Prototype
0
26
1
26
4
0
4
1
1
34
4
1
1
37
2
nud
26
172
-1
p
26
172
-1
2
reserved_names
builtin_names
11
4
19
2
if
2
else
2
elseif
2
endif
2
for
2
in
2
endfor
2
fork
2
endfork
2
return
2
while
2
endwhile
2
try
2
except
2
finally
2
endtry
2
ANY
2
break
2
continue
26
0
4
20
2
player
2
this
2
caller
2
verb
2
argstr
2
args
2
dobjstr
2
dobj
2
prepstr
2
iobjstr
2
iobj
2
err
2
num
2
int
2
float
2
str
2
obj
2
list
2
map
2
anon
26
0
5
26
0
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
#37
Statement Prototype
0
26
1
26
4
0
4
1
1
36
4
6
1
39
1
45
1
51
1
52
1
53
1
54
1
std
26
172
-1
0
11
5
26
0
5
26
0
5
26
0
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
#38
Operator Prototype
0
26
1
26
4
0
4
1
1
34
4
8
1
40
1
42
1
46
1
47
1
48
1
49
1
50
1
56
0
0
9
5
26
0
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
#39
Control Flow Statement Prototype
0
26
1
26
4
0
4
1
1
37
4
0
2
std
26
172
-1
p
26
172
-1
1
first
12
0
0
26
1
5
26
0
5
26
0
5
26
0
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
#40
Infix Operator Prototype
0
26
1
26
4
0
4
1
1
38
4
1
1
41
2
led
26
172
-1
p
26
172
-1
3
right
first
second
12
0
0
26
1
0
0
26
1
0
0
26
1
5
26
0
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
#41
Assignment Operator Prototype
0
26
1
26
4
0
4
1
1
40
4
0
2
led
26
172
-1
p
26
172
-1
0
12
5
26
1
5
26
1
5
26
1
5
26
0
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
#42
Prefix Operator Prototype
0
26
1
26
4
0
4
1
1
38
4
0
2
nud
26
172
-1
p
26
172
-1
1
first
10
0
0
26
1
5
26
0
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
#43
Bracket Operator Prototype
0
26
1
26
4
0
4
1
1
34
4
0
3
nud
26
172
-1
led
26
172
-1
p
26
172
-1
3
first
second
third
12
0
0
26
1
0
0
26
1
0
0
26
1
5
26
0
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
#44
Brace Operator Prototype
0
26
1
26
4
0
4
1
1
34
4
0
2
nud
26
172
-1
p
26
172
-1
1
first
10
0
0
26
1
5
26
0
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
#45
If Statement Prototype
0
26
1
26
4
0
4
1
1
37
4
0
2
std
26
172
-1
p
26
172
-1
0
11
5
26
0
5
26
0
5
26
0
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
#46
Invocation Operator
0
26
1
26
4
0
4
1
1
38
4
0
3
nud
26
172
-1
led
26
172
-1
p
26
172
-1
3
first
second
third
12
0
0
26
1
0
0
26
1
0
0
26
1
5
26
0
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
#47
Verb Selector Operator
0
26
1
26
4
0
4
1
1
38
4
0
1
led
26
172
-1
2
first
second
11
0
0
26
1
0
0
26
1
5
26
0
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
#48
Property Selector Operator
0
26
1
26
4
0
4
1
1
38
4
0
2
led
26
172
-1
p
26
172
-1
2
first
second
11
0
0
26
1
0
0
26
1
5
26
0
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
#49
Error Catching Operator Prototype
0
26
1
26
4
0
4
1
1
38
4
0
3
nud
26
172
-1
led
26
172
-1
p
26
172
-1
3
first
second
third
12
0
0
26
1
0
0
26
1
0
0
26
1
5
26
0
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
#50
Traditional Ternary Operator Proto
0
26
1
26
4
0
4
1
1
38
4
0
2
led
26
172
-1
p
26
172
-1
3
first
second
third
12
0
0
26
1
0
0
26
1
0
0
26
1
5
26
0
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
#51
For Statement Prototype
0
26
1
26
4
0
4
1
1
37
4
0
2
std
26
172
-1
p
26
172
-1
1
subtype
12
0
0
26
1
5
26
0
5
26
0
5
26
0
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
#52
Loop Statement Prototype
0
26
1
26
4
0
4
1
1
37
4
0
2
std
26
172
-1
p
26
172
-1
0
11
5
26
0
5
26
0
5
26
0
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
#53
Fork Statement Prototype
0
26
1
26
4
0
4
1
1
37
4
0
2
std
26
172
-1
p
26
172
-1
0
11
5
26
0
5
26
0
5
26
0
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
#54
Try Statement Prototype
0
26
1
26
4
0
4
1
1
37
4
0
2
std
26
172
-1
p
26
172
-1
1
subtype
12
0
0
26
1
5
26
0
5
26
0
5
26
0
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
#55
Positional Symbol Prototype
0
26
1
26
4
0
4
1
1
34
4
0
2
nud
26
172
-1
p
26
172
-1
0
9
5
26
0
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
#56
Sign Operator Prototype
0
26
1
26
4
0
4
1
1
38
4
0
3
nud
26
172
-1
led
26
172
-1
p
26
172
-1
2
first
second
11
0
0
26
1
0
0
26
1
5
26
0
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
5
26
1
#57
Text Tools
0
57
1
-1
4
2
1
58
1
59
1
-1
4
0
0
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
text_tools
57
1
2
0.0.1
57
1
4
3
4
2
1
57
2
package
4
2
1
58
2
changelog
4
2
1
59
2
patience_diff
57
1
4
0
57
1
4
2
4
1
2
kernel
4
2
2
primitive
2
>= 0.0.2
57
1
4
0
57
1
4
0
57
1
2
The Text Tools package provides tools for working with text.  Currently it only provides an implementation of the patience diff algorithm.
57
1
4
1
2
Todd Sundsted
57
1
2

57
1
2
FreeBSD License
57
1
#58
Changelog
0
57
1
57
4
0
1
-1
4
0
0
1
1338760427
1
2
Added patience diff.
57
1
#59
Patience Diff
0
57
1
57
4
0
4
1
1
4
4
0
6
_suspend_if_necessary
57
172
-1
_hash_lines
57
172
-1
_find_common_unique_lines
57
172
-1
_find_lcs
57
172
-1
_generate_diff
57
172
-1
diff
57
172
-1
1
default_hash_algo
2
2
md5
57
1
5
57
4
#60
Ask, Query Package
0
60
1
-1
4
3
1
61
1
62
1
63
1
-1
4
0
2
after_install
5
172
-1
before_uninstall
5
172
-1
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
ask
60
1
2
0.0.1
60
1
4
4
4
2
1
60
2
package
4
2
1
61
2
changelog
4
2
1
62
2
dictionary
4
2
1
63
2
ask_proto
60
1
4
1
2
dictionary.ask_proto
60
1
4
2
4
1
2
kernel
4
2
2
primitive
2
>= 0.0.2
60
1
4
0
60
1
4
1
2
install-dictionary
60
1
2
Ask implements queries based on relational algebra.
60
1
4
1
2
Todd Sundsted
60
1
2

60
1
2
FreeBSD License
60
1
#61
Changelog
0
60
1
60
4
0
1
-1
4
0
0
7
1338507037
1339588745
1341490029
1341492308
1341572860
1341574954
1341628401
7
2
First cut at `$ask'.
60
1
2
Replaced magic string "#" with `$ask:id()'/`$ask_proto.id'.
60
1
2
Instead of failing, return information about low-level (E_PERM, etc.) errors.
60
1
2
Added support for predicates with objects numbers.
60
1
2
Added support for predicates "is true"/"is false".
60
1
2
Added support for more logical operators.
60
1
2
Added support for the string matching operator.
60
1
#62
Dictionary
0
60
1
60
4
0
1
-1
4
1
1
0
0
2
ask
ask_proto
2
10
1
2
prototype
1
63
60
1
1
63
60
1
#63
Ask Prototype
16
60
1
60
4
0
1
-1
4
0
13
_lookup
5
172
-1
_query
5
172
-1
_match_literal_or_identifier
60
172
-1
_match_operator
60
172
-1
_parse_predicate
60
172
-1
from
60
172
-1
select
60
172
-1
where
60
172
-1
count
60
172
-1
all
60
172
-1
one
60
172
-1
id
60
172
-1
errors
60
172
-1
2
id
errors
2
1
-7
60
1
1
-11
60
1
#64
Model Package
0
64
1
-1
4
9
1
65
1
66
1
67
1
68
1
69
1
70
1
71
1
72
1
73
1
-1
4
0
0
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
model
64
1
2
0.0.1
64
1
4
10
4
2
1
64
2
package
4
2
1
65
2
dictionary
4
2
1
66
2
changelog
4
2
1
67
2
model_proto
4
2
1
68
2
constraint
4
2
1
69
2
validates_presence_of
4
2
1
70
2
validates_uniqueness_of
4
2
1
71
2
validates_immutability_of
4
2
1
72
2
validates_format_of
4
2
1
73
2
validates_revision_of
64
1
4
7
2
dictionary.model_proto
2
dictionary.constraint
2
dictionary.validates_presence_of
2
dictionary.validates_uniqueness_of
2
dictionary.validates_immutability_of
2
dictionary.validates_format_of
2
dictionary.validates_revision_of
64
1
4
2
4
1
2
kernel
4
2
2
ask
2
>= 0.0.1
64
1
4
0
64
1
4
1
2
install-namespace
64
1
2

64
1
4
0
64
1
2

64
1
2

64
1
#65
Dictionary
0
64
1
64
4
0
1
-1
4
0
6
validate
5
172
-1
create
5
172
-1
update
5
172
-1
read
5
172
-1
_before_* _after_*
5
172
-1
find find_by_*
64
172
-1
9
model_proto
constraint
id
errors
validates_presence_of
validates_uniqueness_of
validates_immutability_of
validates_format_of
validates_revision_of
9
1
67
64
1
1
68
64
1
1
-7
64
1
1
-11
64
1
1
69
64
1
1
70
64
1
1
71
64
1
1
72
64
1
1
73
64
1
#66
Changelog
0
64
1
64
4
0
1
-1
4
0
0
19
1316329109
1316332819
1317981980
1318420551
1320746708
1321644116
1321732614
1321750566
1339414278
1339498645
1339498974
1339505506
1339505587
1339507058
1339581632
1339581896
1339589892
1341418035
1343621398
19
2
Added package installation instructions.
64
1
2
Fixed validation breakage related to map operation changes.
64
1
2
Model create/update now uses $shape to write values -- normalizes `location' et al.
64
1
2
Verb `find_by_*' now uses $ask.
64
1
2
Updated package information.
64
1
2
Loosened the coupling between model actions and the model prototype object.  Added custom `respond_to()' verb.  Format validation now takes "pattern" instead of "regex".
64
1
2
Renamed model verb `show()' to `read()'.
64
1
2
Return the canonical representation on create/update.  Handle a few errors better.
64
1
2
Major rewrite.  Fixed magic markers for errors and object number/id.  Removed custom `respond_to()' verb.
64
1
2
Moved verbs from `$model.model' to `$model'.
64
1
2
Renamed `$model.model' to `$model.model_proto'.
64
1
2
Cleaned up `find()'.
64
1
2
Added prototype and instance delegation.
64
1
2
`update()' and `read()' now work with descendants and children.
64
1
2
`$model.validates_presence_of' is now forgiving if the property is set.
64
1
2
Added `$model.validates_revision_of'.
64
1
2
`$model:find()' and `$model:find_by_*()' automatically select accessible properties.
64
1
2
`validates_format_of()' handles the empty string correctly.
64
1
2
Validations improvements/fixes.
64
1
#67
Model Prototype
128
64
1
64
4
0
4
1
1
4
4
0
2
create find find_by_*
5
172
-1
validate update read
5
172
-1
2
accessible
constraints
3
4
0
64
5
10
0
64
5
5
64
4
#68
Constraint Prototype
0
64
1
64
4
0
4
1
1
4
4
5
1
69
1
70
1
71
1
72
1
73
3
validate
64
172
-1
add_error
64
172
-1
is_blank is_present
5
172
-1
0
1
5
64
4
#69
Validates Presence Of
0
64
1
64
4
0
4
1
1
68
4
0
1
validate
5
172
-1
0
1
5
64
4
#70
Validates Uniqueness Of
0
64
1
64
4
0
4
1
1
68
4
0
1
validate
5
172
-1
0
1
5
64
4
#71
Validates Immutability Of
0
64
1
64
4
0
4
1
1
68
4
0
1
validate
5
172
-1
0
1
5
64
4
#72
Validates Format Of
0
64
1
64
4
0
4
1
1
68
4
0
1
validate
64
172
-1
0
1
5
64
4
#73
Validates Revision Of
0
64
1
64
4
0
4
1
1
68
4
0
1
validate
5
172
-1
0
1
5
64
4
#74
Persistent Package
0
74
1
-1
4
3
1
75
1
76
1
77
1
-1
4
0
0
10
identifier
version
manifest
relocate
requires
instructions
description
authors
homepage
license
10
2
persistent
74
1
2
0.0.2
74
1
4
4
4
2
1
74
2
package
4
2
1
75
2
changelog
4
2
1
76
2
dictionary
4
2
1
77
2
attachable
74
1
4
1
2
dictionary.attachable
74
1
4
1
4
2
2
kernel
2
>= 1.0.6
74
1
4
1
2
install-dictionary
74
1
2
Persistent creates and manages the associated Stunt filesystem.  The package includes the $attachable mixin.
74
1
4
1
2
Todd Sundsted
74
1
2
http://stunt.io/packages/persistent
74
1
2
FreeBSD License
74
1
#75
Changelog
0
74
1
74
4
0
1
-1
4
0
0
5
1312670738
1313453111
1321630702
1329737917
1343820926
5
2
Added $attachable/Attachable.
74
1
2
Create directory structure under files/ on startup.
74
1
2
Cleanup in $attachable.  Removed use of `call_function()'.  Deal with missing helper executables better.
74
1
2
Updated code to use new `for' loop functionality.
74
1
2
Massive rework on `$attachable'.
74
1
#76
Dictionary
0
74
1
74
4
0
1
-1
4
1
1
0
1
server_started
5
172
-1
1
attachable
1
1
77
74
1
#77
Attachable
128
74
1
74
4
0
4
1
1
4
4
0
11
attachments
74
172
-1
attachment
5
172
-1
check_attachment
5
172
-1
recycle
5
172
-1
_path_for
5
172
-1
add_attachment
5
172
-1
add_attachment_from_tmp_file
5
172
-1
delete_attachment
5
172
-1
_identify
5
172
-1
_thumbnail
5
172
-1
_check_limit
74
172
-1
3
attachment_pools
attachments
attachment_limit
4
10
2
2
private
2
private/app
2
public
2
public/app
74
0
10
0
74
0
0
4
74
1
5
74
4
#78
Dialog, Web Server Package
0
78
1
-1
4
8
1
79
1
80
1
81
1
82
1
83
1
84
1
85
1
86
1
-1
4
0
2
after_install
5
172
-1
before_uninstall
5
172
-1
10
identifier
version
manifest
relocate
requires
instructions
description
authors
homepage
license
10
2
dialog
78
1
2
0.0.5
78
1
4
9
4
2
1
78
2
package
4
2
1
79
2
changelog
4
2
1
80
2
dictionary
4
2
1
81
2
utilities
4
2
1
82
2
server
4
2
1
83
2
request_proto
4
2
1
84
2
response_proto
4
2
1
85
2
route_proto
4
2
1
86
2
player_in_session
78
1
4
10
2
dictionary.utilities
2
dictionary.server
2
dictionary.request_proto
2
dictionary.response_proto
2
dictionary.route_proto
2
dictionary.player_in_session
2
server.utilities
2
server.request_proto
2
server.response_proto
2
server.route_proto
78
1
4
2
4
2
2
kernel
2
>= 1.0.6
4
2
2
primitive
2
>= 0.0.2
78
1
4
1
2
install-namespace
78
1
2
Dialog is the Stunt HTTP server.
78
1
4
1
2
Todd Sundsted
78
1
2
http://stunt.io/packages/dialog
78
1
2
FreeBSD License
78
1
#79
Changelog
0
78
1
78
4
0
1
-1
4
0
0
42
1316094194
1316358449
1318324724
1318324757
1318346368
1319025413
1319025667
1319388751
1319388831
1329657368
1329684677
1331257920
1331258266
1331905594
1331908171
1332104162
1332104693
1332106296
1332244717
1335621656
1336318579
1336480647
1336702845
1336991408
1337168940
1337216616
1337248289
1337250774
1337429755
1337431122
1337449915
1337453002
1341097958
1341100432
1341103044
1341232003
1341314273
1341320216
1343504254
1343580292
1343586836
1343591641
42
2
Added HTTP server framework (basic) including external file serving, routing to object/verb handlers and a database example.
78
1
2
Unescape URL encoded POST data.
78
1
2
Modified HTTP server `session()' verb to get session from task local value.
78
1
2
Modified HTTP server `internal()' verb to properly set `player' and perms.
78
1
2
Removed player()/set_player() from request; moved authenticated player persistence into task local storage.
78
1
2
Refactored HTTP server chaining; support external chain steps; removed upgrade from default chain; added external log and upgrade steps.
78
1
2
Removed internal dependency on storing the player in the HTTP session.
78
1
2
The HTTP server `external()' verb looks up mime type by extension and by exec'ing `identify'.
78
1
2
`_do_chain()' tries to be smarter about cleanup on error.
78
1
2
Moved HTTP status codes into a property.
78
1
2
Removed `external()' and renamed `internal()' to `serve()'.
78
1
2
Added a configurable session cookie name.
78
1
2
Fixed the ownership and perms of `key'.
78
1
2
Handle too-large bodies in cleanup.
78
1
2
Added better diagnostics in session validation.
78
1
2
Added support for flash socket policy file requests.
78
1
2
Fixed the handling of upgrade requests.
78
1
2
Renamed "route" to "route_proto" in all the right places.
78
1
2
Moved the flash socket policy logic back into `do_login_command()'.
78
1
2
Explicitly send a content length of zero (0) when the body is empty.  Safari seems to want this on redirects.
78
1
2
Package dictionary now has no parents.
78
1
2
Limit parameters map to 1000 items to foil DOS attacks.
78
1
2
Removed redundant code from `parse_query_string()'.
78
1
2
Added support for a synchronizer-style authenticity token.  Refactored the session code.  Fixed tests.
78
1
2
Roll the player step in the chain into the session step.
78
1
2
More useful error messages when chaining fails.
78
1
2
Broadened the 404/500 verb to handle (almost) any status.
78
1
2
Added authenticity token and player information as convenience parameters.
78
1
2
Handle bad requests more gracefully.
78
1
2
Added Server header to response.
78
1
2
Strip out query/body parameters that begin with "__".
78
1
2
Added Date header.
78
1
2
Force peeked-at input on the _front_ of the queue.
78
1
2
Surround system/convenience parameters with double-underscores.
78
1
2
Add `__xhr__' and `__url_base__' system/convenience parameters.
78
1
2
Strip parameters that begin with double-underscores.
78
1
2
Handle form data parameters more securely.
78
1
2
Handle request media type parameters
78
1
2
The session cookie must be http only.
78
1
2
Add `__ssh__' and `__remote_client__' system/convenience parameters.
78
1
2
Added timezone adjustments.
78
1
2
Fixed error properly closing files.
78
1
#80
Dialog Dictionary
0
78
1
78
4
0
1
-1
4
0
0
6
server
request_proto
response_proto
route_proto
utilities
player_in_session
6
1
82
78
1
1
83
78
1
1
84
78
1
1
85
78
1
1
81
78
1
1
86
78
1
#81
Dialog Utilities
0
78
1
78
4
0
4
1
1
4
4
0
4
generate_query_string
78
172
-1
parse_query_string
78
172
-1
escape
78
172
-1
unescape
78
172
-1
0
1
5
78
4
#82
HTTP Server
0
78
1
78
4
1
1
87
4
1
1
4
4
1
1
114
23
_log
5
172
-1
_key
78
172
-1
start
5
172
-1
stop
5
172
-1
_read_http
5
172
-1
_notify
5
172
-1
_session_cookie_name _flash_socket_policy
5
172
-1
_read_from_connection
78
172
-1
_write_to_connection
78
172
-1
_do_request
78
172
-1
do_login_command
5
172
-1
session
5
172
-1
route
78
172
-1
parameters
5
172
-1
protect_from_forgery
5
172
-1
serve
5
172
-1
cleanup
5
172
-1
2* 3* 4* 5*
78
172
-1
traceback
78
172
-1
trampoline
5
172
-1
_drop_perms_and_call_verb
5
172
-1
_do_chain
5
172
-1
_rfc1123_ctime
78
172
-1
10
port
key
default_chain
utilities
request_proto
response_proto
route_proto
status_codes
session_cookie_name
flash_socket_policy
11
0
8888
78
1
0
0
78
0
4
7
2
session
2
parameters
2
protect_from_forgery
2
route
2
serve
2
cleanup
2
404
78
4
1
81
78
1
1
83
78
1
1
84
78
1
1
85
78
1
10
13
0
200
2
Ok
0
201
2
Created
0
204
2
No Content
0
302
2
Moved
0
304
2
Not Modified
0
400
2
Bad Request
0
403
2
Forbidden
0
404
2
Not Found
0
406
2
Not Acceptable
0
413
2
Request Entity Too Large
0
415
2
Unsupported Media Type
0
422
2
Unprocessable Entity
0
500
2
Server Error
78
1
2
_stunt_session
78
4
0
0
78
4
5
78
4
#83
HTTP Request Prototype
16
78
1
78
4
0
1
-1
4
0
12
create
78
172
-1
method uri headers body parameters handler exception
78
172
-1
set_method set_uri set_headers set_body set_parameters set_handler set_exception
78
172
-1
cookies
78
172
-1
path
78
172
-1
query
78
172
-1
type
78
172
-1
set_type
78
172
-1
length
78
172
-1
set_length
78
172
-1
session
5
172
-1
set_session
5
172
-1
0
0
#84
HTTP Response Prototype
16
78
1
78
4
0
1
-1
4
0
4
create
78
172
-1
status headers body
78
172
-1
set_status set_headers set_body
78
172
-1
set_type set_length set_location
78
172
-1
0
0
#85
HTTP Route Prototype
0
78
1
78
4
0
4
1
1
4
4
4
1
87
1
90
1
91
1
120
1
match
78
172
-1
0
1
5
78
4
#86
Player in Session Capability
0
78
1
78
4
0
1
-1
4
0
2
set_player
5
172
-1
player
5
172
-1
1
prototypes
1
4
0
5
0
#87
It Works!
0
78
1
82
4
0
4
1
1
85
4
0
2
match
78
172
-1
it_works!
78
172
-1
0
1
5
78
4
#88
Dialog, Extras
0
88
1
-1
4
5
1
89
1
90
1
91
1
92
1
93
1
-1
4
0
0
10
identifier
version
manifest
relocate
requires
instructions
description
authors
homepage
license
10
2
dialog_extras
88
1
2
0.0.4
88
1
4
6
4
2
1
88
2
package
4
2
1
89
2
changelog
4
2
1
90
2
file_server
4
2
1
91
2
db_server
4
2
1
92
2
streaming_handler
4
2
1
93
2
logger
88
1
4
0
88
1
4
3
4
2
2
kernel
2
>= 1.0.7
4
2
2
primitive
2
>= 0.0.2
4
2
2
dialog
2
>= 0.0.2
88
1
4
0
88
1
2
The Dialog Extras package contains objects that extend Dialog: file server, db object server, upgrade protocol handler, and logger.
88
1
4
1
2
Todd Sundsted
88
1
2
http://stunt.io/packages/dialog_extras
88
1
2
FreeBSD License
88
1
#89
Changelog
0
88
1
88
4
0
1
-1
4
0
0
10
1335730720
1337172128
1337341716
1337342502
1337441502
1337453415
1341098950
1341100432
1343584453
1343591641
10
2
Deal with a few more errors in static file routing.
88
1
2
Deal with unparseable object numbers.
88
1
2
Smartened up the database POST, PUT and DELETE verbs.
88
1
2
Don't let invalid players create objects.
88
1
2
Prevent `index.html' file serving from shadowing `///' (the database handler path prefix).
88
1
2
Added last-modified and if-modified-since support.
88
1
2
Support "swf" and "htm" extensions.
88
1
2
Surround system/convenience parameters with double-underscores.
88
1
2
Log the correct client IP address.
88
1
2
Fixed error properly closing files.
88
1
#90
HTTP File Server
0
88
1
88
4
0
4
1
1
85
4
1
1
118
2
match
5
172
-1
get
5
172
-1
0
1
5
88
4
#91
HTTP Database Server
0
88
1
88
4
0
4
1
1
85
4
1
1
119
7
match
88
172
-1
_match_uri
88
172
-1
_toobj
88
172
-1
get
5
172
-1
put
5
172
-1
post
5
172
-1
delete
5
172
-1
0
1
5
88
4
#92
HTTP Streaming Handler
0
88
1
88
4
0
4
1
1
4
4
1
1
114
2
do_socket
5
172
-1
do_long_poll
5
172
-1
1
description
2
2
HTTP streaming handlers for player interaction.  Currently socket based and long-polling.
88
1
5
88
4
#93
HTTP Logger
0
88
1
88
4
0
4
1
1
4
4
1
1
114
1
log
5
172
-1
0
1
5
88
4
#94
Mustache Templating Language Package
0
94
1
-1
4
3
1
95
1
96
1
97
1
-1
4
0
2
after_install
5
172
-1
before_uninstall
5
172
-1
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
mustache
94
1
2
1.0.1
94
1
4
4
4
2
1
94
2
package
4
2
1
95
2
changelog
4
2
1
96
2
dictionary
4
2
1
97
2
compiler
94
1
4
1
2
dictionary.compiler
94
1
4
2
4
2
2
kernel
2
>= 1.1.1
4
2
2
primitive
2
>= 0.0.2
94
1
4
0
94
1
4
1
2
install-namespace
94
1
2
A MOO/Stunt port of the popular Mustache templating language (http://mustache.github.com/).
94
1
4
1
2
Todd Sundsted
94
1
2
http://stunt.io/packages/mustache
94
1
2
FreeBSD License
94
1
#95
Changelog
0
94
1
94
4
0
1
-1
4
0
0
9
1317769370
1317897840
1319399411
1337466158
1337553578
1341406402
1341407065
1355362911
1355403901
9
2
Initial release candidate.
94
1
2
Fixed a bug in pushing/popping context frames.
94
1
2
Fixed a bug in handling dotted notation.
94
1
2
Emit syntax errors for invalid mustache.
94
1
2
Improved the quality of the generated code.
94
1
2
Emit a syntax error for an empty tag.
94
1
2
Ensure `compile()' takes a list.
94
1
2
Created new version: 1.0.1.
94
1
2
Compiler output is now compatible.
94
1
#96
Dictionary
0
94
1
94
4
0
1
-1
4
0
0
1
compiler
1
1
97
94
1
#97
Mustache Compiler
0
94
1
94
4
0
4
1
1
4
4
0
2
_log
5
172
-1
compile
94
172
-1
0
1
5
94
4
#98
Identity Package
0
98
1
-1
4
5
1
99
1
100
1
101
1
102
1
103
1
-1
4
0
0
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
identity
98
1
2
0.0.2
98
1
4
6
4
2
1
98
2
package
4
2
1
99
2
changelog
4
2
1
100
2
dictionary
4
2
1
101
2
authenticatable
4
2
1
102
2
utilities
4
2
1
103
2
namespace
98
1
4
3
2
dictionary.authenticatable
2
dictionary.identity
2
namespace.utilities
98
1
4
1
4
2
2
kernel
2
>= 1.0.4
98
1
4
0
98
1
4
1
2
install-dictionary
98
1
2
The identity package provides mechanisms for establishing player/user identity.
98
1
4
1
2
Todd Sundsted
98
1
2
http://stunt.io/packages/identity
98
1
2
FreeBSD License
98
1
#99
Changelog
0
98
1
98
4
0
1
-1
4
0
0
4
1311598736
1336418462
1336419186
1339591932
4
2
Improved the fixed-time hash comparison in $authenticatable.
98
1
2
Moved utility verbs from the `$authenticatable' prototype mixin.
98
1
2
Updated `$authenticate()' to use the new utility verbs.
98
1
2
Added the `@password' command verb.
98
1
#100
Dictionary
0
98
1
98
4
0
1
-1
4
1
1
0
1
authenticate
5
172
-1
2
authenticatable
identity
2
1
101
98
1
1
103
98
1
#101
Authenticatable
0
98
1
98
4
0
4
1
1
4
4
0
1
@password
5
8
-1
1
hashed_password
2
10
0
5
0
5
98
4
#102
Identity Utilities
0
98
1
98
4
0
4
1
1
4
4
0
2
verify_hashed_password
98
172
-1
hash_password
98
172
-1
0
1
5
98
4
#103
Identity Namespace
0
98
1
98
4
0
1
-1
4
0
0
1
utilities
1
1
102
98
1
#104
Alt, Player Package
0
104
1
-1
4
6
1
105
1
106
1
107
1
108
1
109
1
110
1
-1
4
0
0
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
alt
104
1
2
0.0.3
104
1
4
7
4
2
1
104
2
package
4
2
1
105
2
changelog
4
2
1
106
2
dictionary
4
2
1
107
2
player_utilities
4
2
1
108
2
player_proto
4
2
1
109
2
programmer_proto
4
2
1
110
2
wizard_proto
104
1
4
3
2
dictionary.player_proto
2
dictionary.programmer_proto
2
dictionary.wizard_proto
104
1
4
4
4
2
2
kernel
2
>= 1.0.4
4
2
2
primitive
2
>= 0.0.2
4
2
2
text_tools
2
>= 0.0.1
4
2
2
plastic
2
>= 0.0.1
104
1
4
0
104
1
4
1
2
install-namespace
104
1
2
The Alt Package contains the basic player hierarchy and defines a basic set of VR verbs.
104
1
4
1
2
Todd Sundsted
104
1
2
http://stunt.io/packages/alt
104
1
2
FreeBSD License
104
1
#105
Changelog
0
104
1
104
4
0
1
-1
4
0
0
14
1333837145
1333839422
1338036321
1338208126
1338895941
1341148790
1341149402
1341174341
1341176019
1341179018
1341187815
1343595533
1351446849
1354988315
14
2
`match_verb()'/`match_property()' now match on "me" and "here".
104
1
2
Removed `utilities' property from `$player_proto'; using `$lookup()' instead.
104
1
2
In `set_verb_code()', the fourth arg is the content type.
104
1
2
Don't program verb if nothing changed.
104
1
2
Added `@diff/@difference' command verb.
104
1
2
Added argstr tail processing.
104
1
2
Made `@inspect' output much more attractive.
104
1
2
Improved property handling in `@list'/`@edit' and `@program'.
104
1
2
Fixed the verb-not-found case in `@diff'.
104
1
2
Added  `@commit' and `@revert'.
104
1
2
`@program' snarfs lines early to avoid accidental commands.
104
1
2
Fixed many usability problems with the `@inspect' command verb.
104
1
2
A few tweaks to make `@inspect' et al work better with anonymous objects.
104
1
2
Major revamp of `evaluate'.
104
1
#106
Dictionary
0
104
1
104
4
0
1
-1
4
0
0
3
player_proto
programmer_proto
wizard_proto
3
1
108
104
1
1
109
104
1
1
110
104
1
#107
Player Utilities
0
104
1
104
4
0
1
-1
4
0
5
match_verb match_property
5
172
-1
match_object
5
172
-1
_player_controls_verb _player_controls_property
5
172
-1
_player_controls_object
5
172
-1
extract_tail
104
172
-1
0
0
#108
Player Prototype
16
104
1
104
4
0
4
1
1
4
4
1
1
109
3
huh
5
172
-1
notify tell
5
172
-1
@quit
5
8
-1
0
1
5
104
4
#109
Programmer Prototype
16
104
1
104
4
0
4
1
1
108
4
2
1
110
1
6
7
_parse
104
172
-1
eval*uate
5
88
-2
@list @edit
5
24
-1
@program
5
88
-2
@in*spect
5
24
-1
@diff*erence
5
24
-1
@commit @revert
5
24
-1
1
alt_bindings
2
10
0
104
4
5
104
4
#110
Wizard Prototype
0
104
1
104
4
0
4
1
1
109
4
1
1
5
0
0
2
5
104
4
5
104
4
#111
Application Package
0
111
1
-1
4
3
1
112
1
113
1
114
1
-1
4
0
1
after_install
5
172
-1
11
identifier
version
manifest
requires
relocate
provides
instructions
description
authors
homepage
license
11
2
application
111
1
2
0.0.7
111
1
4
7
4
2
1
111
2
package
4
2
1
112
2
changelog
4
2
1
113
2
dictionary
4
2
1
114
2
server
4
2
1
115
2
home_controller
4
2
1
116
2
home_views
4
2
1
117
2
session_controller
111
1
4
2
4
2
2
dialog
2
>= 0.0.1
4
2
2
dialog_extras
2
>= 0.0.1
111
1
4
0
111
1
4
0
111
1
4
1
2
install-dictionary
111
1
2

111
1
4
0
111
1
2

111
1
2

111
1
#112
Changelog
0
111
1
111
4
0
1
-1
4
0
0
5
1335958995
1335960351
1335961601
1336184517
1336230042
5
2
Major refactoring.
111
1
2
Updated the authentication.
111
1
2
Autostart the web server.
111
1
2
Use jquery.console.
111
1
2
Handle multiline output correctly/better in the view.
111
1
#113
Dictionary
0
111
1
111
4
0
1
-1
4
1
1
0
1
server_started
5
172
-1
0
0
#114
HTTP Server
0
111
1
111
4
5
1
115
1
117
1
118
1
119
1
120
4
3
1
82
1
92
1
93
4
0
0
0
12
5
78
1
2
~04~16~B6P~EB~81~D7H~C0.~EFoa0~0D~D8~8E<u~00M~D5~D3F ~A3~12~09~CA~89~8Fh~E9~E1~D8~CA~C7~03~8B~C0~B0HD~E3q~93~AF~A7Z~E1~94@~DD~D3~8Ec~EA6~0D~D7~0CO~AE~B3~08~AA~E5H+~1B~B1~1Dq~D3|_wB~B9~B0~1E_d~A4~FFW~13~B6~99~F4~EA}~AA~9C~08~BF~DEP~F4~A2~11~0AI~C27~8E~BA~C1~E6~F8~A1~AF~8D~EE~B7~FF~D5~CF[~04~C8~FD~D1~8C~1Dt
78
0
4
10
2
session
2
parameters
2
protect_from_forgery
2
do_socket
2
do_long_poll
2
route
2
serve
2
cleanup
2
404
2
log
111
4
5
78
1
5
78
1
5
78
1
5
78
1
5
78
1
5
111
4
2
<?xml version="1.0"?><cross-domain-policy><allow-access-from domain="localhost" to-ports="*"/></cross-domain-policy>
111
4
5
111
4
5
88
1
#115
Home Controller
0
111
1
114
4
1
1
116
1
-1
4
0
3
_common
111
172
-1
home
111
172
-1
browse
111
172
-1
0
0
#116
Home Views
0
111
1
115
4
0
1
-1
4
0
6
_head
111
172
-1
_foot
111
172
-1
_nav
111
172
-1
public
111
172
-1
home
111
172
-1
browse
111
172
-1
0
0
#117
Session Controller
0
111
1
114
4
0
1
-1
4
0
2
create
5
172
-1
destroy
5
172
-1
0
0
#118
File Server
0
111
1
114
4
0
4
1
1
90
4
0
0
0
1
5
111
4
#119
Database Server
0
111
1
114
4
0
4
1
1
91
4
0
0
0
1
5
111
4
#120
Routes
0
111
1
114
4
0
4
1
1
85
4
0
1
match
111
172
-1
0
1
5
111
4
0
372
#0:0
$private();
{e} = args;
desc = e[2];
{line, @lines} = e[4];
server_log(tostr(line[4], ":", line[2], (line[4] != line[1]) ? tostr(" (this == ", line[1], ")") | "", ", line ", line[6], ":  ", desc));
for line in (lines)
server_log(tostr("... called from ", line[4], ":", line[2], (line[4] != line[1]) ? tostr(" (this == ", line[1], ")") | "", ", line ", line[6]));
endfor
server_log("(End of traceback)");
.
#0:1
$restrict_to_server();
for parent in (parents(this))
if (respond_to(parent, "server_started"))
try
parent:server_started(@args);
except e (ANY)
this:_log_error(e);
endtry
endif
endfor
.
#0:2
$restrict_to_server();
try
subject = $nothing;
set_connection_option(player, "hold-input", 1);
if (!args)
if ((player < this.last_login_connection) && this.welcome_message)
this.last_login_connection = player;
notify(player, this.welcome_message);
endif
return;
elseif (args[1] != "connect")
notify(player, "*** Invalid ***");
return;
endif
try
subject = $authenticate(@args[2..$]);
except e (ANY)
this:_log_error(e);
notify(player, "*** Failed ***");
subject = $nothing;
return;
endtry
if ((!valid(subject)) || (!is_player(subject)))
suspend(2);
notify(player, "*** Failed ***");
subject = $nothing;
return;
endif
finally
set_connection_option(player, "hold-input", 0);
return subject;
endtry
.
#0:3
$permit("wizard");
valid = 1;
for arg in (args)
if (typeof(arg) != STR)
valid = 0;
endif
endfor
valid || raise(E_INVARG);
for parent in (parents(this))
if (respond_to(parent, "authenticate") && `valid(subject = parent:authenticate(@args)) ! ANY')
return subject;
endif
endfor
return $failed_match;
.
#0:4
clients = args;
callers = callers();
(length(callers) > 1) || raise(E_PERM, "Private verb");
((((callers[1][4] == callers[2][4]) && valid(callers[1][4])) && (callers[1][1] == callers[2][1])) && valid(callers[1][1])) || raise(E_PERM, "Private verb");
((!clients) || (callers[2][2] in clients)) || raise(E_PERM, tostr("Private verb:  \"", callers[2][2], "\" not in verb list ", toliteral(clients)));
return;
"clients = args;";
"callers = callers();";
"length(callers) > 1 || raise(E_PERM, \"Private verb\");";
"callers[1][4] == callers[2][4] && valid(callers[1][4]) && callers[1][1] == callers[2][1] && valid(callers[1][1]) || raise(E_PERM, \"Private verb\");";
"!clients || callers[2][2] in clients || raise(E_PERM, tostr(\"Private verb:  \\\"\", callers[2][2], \"\\\" not in verb list \", toliteral(clients)));";
"/*";
"Only allow the call if the caller and the callee were both defined";
"on the same object and the call between caller and callee was";
"performed on the same instance.";
"*/";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"content_type:application/x-moocode";
"updated_at:Tue Sep 13 19:26:52 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:5
clients = args;
callers = callers();
(length(callers) > 1) || raise(E_PERM, "Protected verb");
((callers[1][1] == callers[2][1]) && valid(callers[1][1])) || raise(E_PERM, "Protected verb");
((!clients) || (callers[2][2] in clients)) || raise(E_PERM, tostr("Protected verb:  \"", callers[2][2], "\" not in verb list ", toliteral(clients)));
return;
"clients = args;";
"callers = callers();";
"length(callers) > 1 || raise(E_PERM, \"Protected verb\");";
"callers[1][1] == callers[2][1] && valid(callers[1][1]) || raise(E_PERM, \"Protected verb\");";
"!clients || callers[2][2] in clients || raise(E_PERM, tostr(\"Protected verb:  \\\"\", callers[2][2], \"\\\" not in verb list \", toliteral(clients)));";
"/*";
"Only allow the call if the call between caller and the callee was";
"performed on the same instance.";
"*/";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"content_type:application/x-moocode";
"updated_at:Tue Sep 13 19:26:52 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:6
args && raise(E_ARGS);
{dummy, @callers} = callers();
callers && raise(E_PERM, "Server-only verb");
return;
"args && raise(E_ARGS);";
"{dummy, @callers} = callers();";
"callers && raise(E_PERM, \"Server-only verb\");";
"/*";
"Only allow the call if the caller is the server.";
"*/";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"updated_at:Tue Oct 18 07:27:43 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:7
clients = args;
{dummy, @callers} = callers();
callers || raise(E_PERM, "Builtin-only verb");
(((callers[1][4] == $nothing) && (callers[1][3] == $nothing)) && (callers[1][2] != "")) || raise(E_PERM, "Builtin-only verb");
((!clients) || (callers[1][2] in clients)) || raise(E_PERM, tostr("Builtin-only verb:  \"", callers[1][2], "\" not in verb list ", toliteral(clients)));
return;
"clients = args;";
"{dummy, @callers} = callers();";
"callers || raise(E_PERM, \"Builtin-only verb\");";
"callers[1][4] == $nothing && callers[1][3] == $nothing && callers[1][2] != \"\" || raise(E_PERM, \"Builtin-only verb\");";
"!clients || callers[1][2] in clients || raise(E_PERM, tostr(\"Builtin-only verb:  \\\"\", callers[1][2], \"\\\" not in verb list \", toliteral(clients)));";
"/*";
"Only allow the call if the caller is a built-in function.";
"*/";
"/* fixed incorrect implementation of specified test Sat Sep 10 15:39:39 2011 EDT*/";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"updated_at:Tue Oct 18 07:27:43 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:8
{caller, @clients} = args;
{dummy, @callers} = callers();
callers || raise(E_PERM, "Restricted verb");
((callers[1][4] == caller) && valid(callers[1][1])) || raise(E_PERM, "Restricted verb");
((!clients) || (callers[1][2] in clients)) || raise(E_PERM, tostr("Restricted verb:  \"", callers[1][2], "\" not in verb list ", toliteral(clients)));
return;
"{caller, @clients} = args;";
"{dummy, @callers} = callers();";
"callers || raise(E_PERM, \"Restricted verb\");";
"callers[1][4] == caller && valid(callers[1][1]) || raise(E_PERM, \"Restricted verb\");";
"!clients || callers[1][2] in clients || raise(E_PERM, tostr(\"Restricted verb:  \\\"\", callers[1][2], \"\\\" not in verb list \", toliteral(clients)));";
"/*";
"Only allow the call if the specified caller matches the actual";
"caller.";
"*/";
"/* changed to check the object on which the verb was defined, instead of used Tue Oct 18 07:26:02 2011 EDT */";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"updated_at:Tue Oct 18 07:27:43 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:9
subjects = args;
callers = callers();
(length(callers) > 1) || raise(E_PERM);
(valid(callers[2][3]) && valid(callers[1][1])) || raise(E_PERM);
if (("wizard" in subjects) && callers[2][3].wizard)
return;
endif
if (("owner" in subjects) && (callers[2][3] == callers[1][1].owner))
return;
endif
if (("programmer" in subjects) && (callers[2][3] == callers[1][3]))
return;
endif
raise(E_PERM);
return;
"subjects = args;";
"callers = callers();";
"length(callers) > 1 || raise(E_PERM);";
"valid(callers[2][3]) && valid(callers[1][1]) || raise(E_PERM);";
"if (\"wizard\" in subjects && callers[2][3].wizard)";
"  return;";
"endif";
"if (\"owner\" in subjects && callers[2][3] == callers[1][1].owner)";
"  return;";
"endif";
"if (\"programmer\" in subjects && callers[2][3] == callers[1][3])";
"  return;";
"endif";
"raise(E_PERM);";
"/*";
"Only allow the call if the caller is a wizard (if the subject";
"\"wizard\" is specified) or the owner of the object the verb was";
"called on (AKA this) (if the subject \"owner\" is specified) or the";
"verb's programmer (if the subject \"programmer\" is specified).";
"*/";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"updated_at:Mon Oct 24 00:04:09 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:10
{owner, object} = args;
(caller_perms().wizard || (caller_perms() == owner)) || raise(E_PERM);
if (LIST == typeof(object))
for object in (object)
(((object == $nothing) || (valid(object) && object.f)) || (valid(object) && (owner.wizard || (owner == object.owner)))) || raise(E_PERM);
endfor
else
(((object == $nothing) || (valid(object) && object.f)) || (valid(object) && (owner.wizard || (owner == object.owner)))) || raise(E_PERM);
endif
return;
"{owner, object} = args;";
"caller_perms().wizard || caller_perms() == owner || raise(E_PERM);";
"/* `object' can be $nothing, an object number, or a list of object numbers */";
"if (LIST == typeof(object))";
"  for object in (object)";
"    object == $nothing || (valid(object) && object.f) || (valid(object) && (owner.wizard || owner == object.owner)) || raise(E_PERM);";
"  endfor";
"else";
"  object == $nothing || (valid(object) && object.f) || (valid(object) && (owner.wizard || owner == object.owner)) || raise(E_PERM);";
"endif";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"content_type:application/x-moocode";
"updated_at:Tue Sep 13 19:26:52 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:11
{owner, object} = args;
(caller_perms().wizard || (caller_perms() == owner)) || raise(E_PERM);
(valid(object) && (owner.wizard || (owner == object.owner))) || raise(E_PERM);
return;
"{owner, object} = args;";
"caller_perms().wizard || caller_perms() == owner || raise(E_PERM);";
"valid(object) && (owner.wizard || owner == object.owner) || raise(E_PERM);";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"content_type:application/x-moocode";
"updated_at:Tue Sep 13 19:26:52 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:12
{code} = args;
(typeof(code) == LIST) || raise(E_INVARG);
state = 1;
chunks = {};
chunk = [];
chunk_length = 0;
i = length(code);
while (state && i)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
line = code[i];
i = i - 1;
if ((state == 1) && (line == "\"-=-=-mxyzptlk-=-=-\";"))
chunk = ["metadata" -> []];
chunk_length = 0;
state = 2;
elseif (state == 1)
i = i + 1;
state = 0;
elseif ((state == 2) && (r = match(line, "^\"%([-_a-z0-9]+%)%:%(.+%)\";$")))
key = r[4][r[3][1][1]..r[3][1][2]];
value = r[4][r[3][2][1]..r[3][2][2]];
chunk_length = (key == "chunk_length") ? toint(value) | 0;
chunk["metadata"][key] = value;
elseif ((state == 2) && (line == "\"\";"))
chunk["source"] = {};
for line in (code[(i - chunk_length) + 1..i])
chunk["source"] = {@chunk["source"], strsub(strsub(line[2..$ - 2], "\\\"", "\""), "\\\\", "\\")};
endfor
i = i - chunk_length;
state = 3;
elseif ((state == 3) && (line == "return;"))
chunks = {chunk, @chunks};
state = 0;
elseif ((state == 3) && (line == "\"-=-=-mxyzptlk-=-=-\";"))
chunks = {chunk, @chunks};
chunk = ["metadata" -> []];
chunk_length = 0;
state = 2;
elseif ((state == 3) && (r = match(line, ((((("^\"%(%(" + "[^\\\"]+") + "%|") + "\\\\") + "%|") + "\\\"") + "%)*%)\";$")))
line = strsub(strsub(r[4][r[3][1][1]..r[3][1][2]], "\\\"", "\""), "\\\\", "\\");
chunk["source"] = {line, @chunk["source"]};
elseif (state == 2)
raise(E_INVARG, tostr("Bad metadata:  ", line));
elseif (state == 3)
raise(E_INVARG, tostr("Missing return:  ", line));
else
raise(E_INVARG);
endif
endwhile
if (state > 1)
raise(E_INVARG, "Corrupt source");
endif
chunks = {["code" -> code[1..i]], @chunks};
return chunks;
return;
"{code} = args;";
"";
"/* Not $private() but maybe should be.  The existance and interface";
" * are subject to change.  No obvious security problems, though.";
" */";
"";
"typeof(code) == LIST || raise(E_INVARG);";
"";
"/* State:";
" *   0 = done";
" *   1 = looking for a boundary";
" *   2 = reading metadata";
" *   3 = reading source";
" */";
"state = 1;";
"";
"/* Strinctly speaking, \"chunk_length\" is optional.  If it's present,";
" * use the value to skip past lines of source.  Otherwise, use the";
" * more error-prone search-for-the-boundary method.";
" */";
"chunks = {};";
"chunk = [];";
"chunk_length = 0;";
"";
"i = length(code);";
"while (state && i)";
"  (ticks_left() < 10000 || seconds_left() < 2) &&";
"    suspend(0);";
"  line = code[i];";
"  i = i - 1;";
"  if (state == 1 && line == \"\\\"-=-=-mxyzptlk-=-=-\\\";\")";
"    chunk = [\"metadata\" -> []];";
"    chunk_length = 0;";
"    state = 2;";
"  elseif (state == 1)";
"    i = i + 1;";
"    state = 0;";
"  elseif (state == 2 && (r = match(line, \"^\\\"%([-_a-z0-9]+%)%:%(.+%)\\\";$\")))";
"    key = r[4][r[3][1][1]..r[3][1][2]];";
"    value = r[4][r[3][2][1]..r[3][2][2]];";
"    chunk_length = (key == \"chunk_length\" ) ? toint(value) | 0;";
"    chunk[\"metadata\"][key] = value;";
"  elseif (state == 2 && line == \"\\\"\\\";\")";
"    chunk[\"source\"] = {};";
"    for line in (code[i - chunk_length + 1..i])";
"      chunk[\"source\"] = {@chunk[\"source\"], strsub(strsub(line[2..$ - 2], \"\\\\\\\"\", \"\\\"\"), \"\\\\\\\\\", \"\\\\\")};";
"    endfor";
"    i = i - chunk_length;";
"    state = 3;";
"  elseif (state == 3 && line == \"return;\")";
"    chunks = {chunk, @chunks};";
"    state = 0;";
"  elseif (state == 3 && line == \"\\\"-=-=-mxyzptlk-=-=-\\\";\")";
"    chunks = {chunk, @chunks};";
"    chunk = [\"metadata\" -> []];";
"    chunk_length = 0;";
"    state = 2;";
"  elseif (state == 3 && (r = match(line, \"^\\\"%(%(\" + \"[^\\\\\\\"]+\" +  \"%|\" + \"\\\\\\\\\" +  \"%|\" + \"\\\\\\\"\" + \"%)*%)\\\";$\")))";
"    line = strsub(strsub(r[4][r[3][1][1]..r[3][1][2]], \"\\\\\\\"\", \"\\\"\"), \"\\\\\\\\\", \"\\\\\");";
"    chunk[\"source\"] = {line, @chunk[\"source\"]};";
"  elseif (state == 2)";
"    raise(E_INVARG, tostr(\"Bad metadata:  \", line));";
"  elseif (state == 3)";
"    raise(E_INVARG, tostr(\"Missing return:  \", line));";
"  else";
"    raise(E_INVARG);";
"  endif";
"endwhile";
"if (state > 1)";
"  raise(E_INVARG, \"Corrupt source\");";
"endif";
"chunks = {[\"code\" -> code[1..i]], @chunks};";
"";
"return chunks;";
"";
"/* security audit on Tue Sep 13 18:59:04 2011 EDT */";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:77";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:92A11D466C5630A29FF7229853670F7554C38A4E";
"state:clean";
"updated_at:Tue Jul  3 08:43:38 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#0:13
{chunks} = args;
(typeof(chunks) == LIST) || raise(E_INVARG);
state = 1;
code = {};
for chunk in (chunks)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (state > 1)
source = {};
if (state == 2)
source = {"return;"};
state = 3;
endif
for line in (chunk["source"])
source = {@source, toliteral(line) + ";"};
endfor
metadata = {};
for value, key in (chunk["metadata"])
metadata = {@metadata, toliteral(tostr(key, ":", value)) + ";"};
endfor
code = {@code, @source, "\"\";", @metadata, "\"-=-=-mxyzptlk-=-=-\";"};
else
code = chunk["code"];
state = 2;
endif
endfor
return code;
return;
"{chunks} = args;";
"";
"/* Not $private() but maybe should be.  The existance and interface";
" * are subject to change.  No obvious security problems, though.";
" */";
"";
"typeof(chunks) == LIST || raise(E_INVARG);";
"";
"/* State:";
" *   1 = adding code chunk";
" *   2 = adding first source chunk";
" *   3 = adding source chunk";
" */";
"state = 1;";
"";
"code = {};";
"";
"for chunk in (chunks)";
"  (ticks_left() < 10000 || seconds_left() < 2) &&";
"    suspend(0);";
"  if (state > 1)";
"    source = {};";
"    if (state == 2)";
"      source = {\"return;\"};";
"      state = 3;";
"    endif";
"    for line in (chunk[\"source\"])";
"      source = {@source, toliteral(line) + \";\"};";
"    endfor";
"    metadata = {};";
"    for value, key in (chunk[\"metadata\"])";
"      metadata = {@metadata, toliteral(tostr(key, \":\", value)) + \";\"};";
"    endfor";
"    code = {@code, @source, \"\\\"\\\";\", @metadata, \"\\\"-=-=-mxyzptlk-=-=-\\\";\"};";
"  else";
"    code = chunk[\"code\"];";
"    state = 2;";
"  endif";
"endfor";
"";
"return code;";
"";
"/* security audit on Tue Sep 13 18:59:04 2011 EDT */";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:44";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:9CAE265C4C667DE8BFFE28FE6856683DA259F29B";
"state:clean";
"updated_at:Tue Jul  3 08:42:40 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#0:14
{object, verb, @options} = args;
valid(object) || raise(E_INVARG);
`{owner, flags, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);
perms = caller_perms();
((perms.wizard || (perms == owner)) || index(flags, "r")) || raise(E_PERM);
perms.programmer || raise(E_PERM);
set_task_perms(perms);
raw = 0;
fully_parenthesize = 0;
indent = 1;
if (options)
if (typeof(options[1]) == MAP)
`raw = options[1]["raw"] ! E_RANGE';
`fully_parenthesize = options[1]["fully_parenthesize"] || options[1]["fully-parenthesize"] ! E_RANGE';
`indent = options[1]["indent"] ! E_RANGE';
`revision = options[1]["revision"] ! E_RANGE';
elseif (typeof(options[1]) == STR)
raw = "raw" in options;
fully_parenthesize = ("fully_parenthesize" in options) || ("fully-parenthesize" in options);
indent = "indent" in options;
elseif (typeof(options[1]) == INT)
`fully_parenthesize = options[1] ! E_RANGE';
`indent = options[2] ! E_RANGE';
endif
endif
code = verb_code(object, verb, fully_parenthesize, indent);
chunks = this:_unpack_verb_code(code);
if (`revision ! ANY' != E_VARNF)
n = 0;
for chunk, i in (chunks)
if ((`toint(chunk["metadata"]["revision"]) ! E_RANGE, E_TYPE' == revision) && revision)
n = i;
break;
endif
endfor
(!n) && raise(E_INVARG, "No such revision");
else
n = 2;
endif
return ((!raw) && (length(chunks) > 1)) ? chunks[n]["source"] | chunks[1]["code"];
return;
"{object, verb, @options} = args;";
"";
"/* check arguments and permissions */";
"valid(object) || raise(E_INVARG);";
"`{owner, flags, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"perms = caller_perms();";
"perms.wizard || (perms == owner) || index(flags, \"r\") || raise(E_PERM);";
"perms.programmer || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(perms);";
"";
"/* interpret optional arguments */";
"raw = 0;";
"fully_parenthesize = 0;";
"indent = 1;";
"if (options)";
"  if (typeof(options[1]) == MAP)";
"    `raw = options[1][\"raw\"] ! E_RANGE';";
"    `fully_parenthesize = options[1][\"fully_parenthesize\"] || options[1][\"fully-parenthesize\"] ! E_RANGE';";
"    `indent = options[1][\"indent\"] ! E_RANGE';";
"    `revision = options[1][\"revision\"] ! E_RANGE';";
"  elseif (typeof(options[1]) == STR)";
"    raw = (\"raw\" in options);";
"    fully_parenthesize = (\"fully_parenthesize\" in options) || (\"fully-parenthesize\" in options) ;";
"    indent = (\"indent\" in options);";
"  elseif (typeof(options[1]) == INT)";
"    `fully_parenthesize = options[1] ! E_RANGE';";
"    `indent = options[2] ! E_RANGE';";
"  endif";
"endif";
"";
"code = verb_code(object, verb, fully_parenthesize, indent);";
"chunks = this:_unpack_verb_code(code);";
"";
"if (`revision ! ANY' != E_VARNF)";
"  n = 0;";
"  for chunk, i in (chunks)";
"    if (`toint(chunk[\"metadata\"][\"revision\"]) ! E_RANGE, E_TYPE' == revision && revision)";
"      n = i;";
"      break;";
"    endif";
"  endfor";
"  !n && raise(E_INVARG, \"No such revision\");";
"else";
"  n = 2;";
"endif";
"";
"return (!raw && length(chunks) > 1) ? chunks[n][\"source\"] | chunks[1][\"code\"];";
"";
"/* security audit on Tue Sep 13 18:59:04 2011 EDT */";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:52";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:93F4856A7AF92AD16B1806C1421B76C27C8E24A6";
"state:clean";
"updated_at:Sun May 27 12:50:21 2012 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:15
{object, verb, code, @options} = args;
valid(object) || raise(E_INVARG);
`{owner, flags, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);
perms = caller_perms();
((perms.wizard || (perms == owner)) || index(flags, "w")) || raise(E_PERM);
perms.programmer || raise(E_PERM);
set_task_perms(perms);
raw = 1;
content_type = 0;
do_not_version = 0;
do_not_stamp = 0;
if (options)
if (typeof(options[1]) == MAP)
raw = `options[1]["raw"] ! E_RANGE';
content_type = `options[1]["content_type"] ! E_RANGE' || `options[1]["content-type"] ! E_RANGE';
do_not_version = `options[1]["do_not_version"] ! E_RANGE' || `options[1]["do-not-version"] ! E_RANGE';
do_not_stamp = `options[1]["do_not_stamp"] ! E_RANGE' || `options[1]["do-not-stamp"] ! E_RANGE';
elseif ((typeof(options[1]) == STR) && (options[1] == "raw"))
raw = "raw";
elseif (typeof(options[1]) == STR)
raw = 0;
content_type = options[1];
endif
if (raw && content_type)
raise(E_INVARG);
endif
endif
chunks = {};
if (temp = verb_code(object, verb))
chunks = this:_unpack_verb_code(temp);
endif
if ((!options) && (!content_type))
if (`content_type = chunks[2]["metadata"]["content_type"] ! E_RANGE')
raw = 0;
endif
endif
(do_not_version && chunks) && raise(E_INVARG);
(do_not_stamp && chunks) && raise(E_INVARG);
if ((raw && code) && (code[$] == "\"-=-=-mxyzptlk-=-=-\";"))
return {"Illegal use of marker"};
elseif (content_type)
source = code;
{type, attributes} = this:_parse_content_type(content_type);
content_type = this:_generate_content_type({type, attributes});
if (type == "application/x-moocode")
elseif (`valid(compiler = $external_compilers[type]) ! E_RANGE, E_TYPE')
{status, code} = compiler:compile(code, attributes);
if (!status)
return code;
endif
else
return {tostr("Invalid content type:  ", type)};
endif
if (length(chunks) > 1)
if (`chunks[2]["metadata"]["state"] ! E_RANGE' == "clean")
revision = `toint(chunks[2]["metadata"]["revision"]) + 1 ! E_RANGE => 1';
keep = chunks[2..$];
else
revision = `toint(chunks[2]["metadata"]["revision"]) ! E_RANGE => 1';
keep = chunks[3..$];
endif
else
revision = 1;
keep = {};
endif
metadata = ["chunk_type" -> "source", "chunk_length" -> length(source), "content_type" -> content_type, "sha1" -> value_hash(source, "sha1")];
if ((!do_not_version) || chunks)
metadata["state"] = "dirty";
metadata["revision"] = revision;
endif
if ((!do_not_stamp) || chunks)
metadata["updated_at"] = ctime(time());
metadata["updated_by"] = perms;
endif
code = this:_pack_verb_code({["code" -> code], ["metadata" -> metadata, "source" -> source], @keep});
endif
return set_verb_code(object, verb, code);
return;
"{object, verb, code, @options} = args;";
"";
"/* check arguments and permissions */";
"valid(object) || raise(E_INVARG);";
"`{owner, flags, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"perms = caller_perms();";
"perms.wizard || (perms == owner) || index(flags, \"w\") || raise(E_PERM);";
"perms.programmer || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(perms);";
"";
"/* interpret optional arguments */";
"raw = 1;";
"content_type = 0;";
"do_not_version = 0;";
"do_not_stamp = 0;";
"if (options)";
"  if (typeof(options[1]) == MAP)";
"    raw = `options[1][\"raw\"] ! E_RANGE';";
"    content_type = `options[1][\"content_type\"] ! E_RANGE' || `options[1][\"content-type\"] ! E_RANGE';";
"    do_not_version = `options[1][\"do_not_version\"] ! E_RANGE' || `options[1][\"do-not-version\"] ! E_RANGE';";
"    do_not_stamp = `options[1][\"do_not_stamp\"] ! E_RANGE' || `options[1][\"do-not-stamp\"] ! E_RANGE';";
"  elseif (typeof(options[1]) == STR && options[1] == \"raw\")";
"    raw = \"raw\";";
"  elseif (typeof(options[1]) == STR)";
"    raw = 0;";
"    content_type = options[1];";
"  endif";
"  if (raw && content_type)";
"    raise(E_INVARG);";
"  endif";
"endif";
"";
"chunks = {};";
"if (temp = verb_code(object, verb))";
"  chunks = this:_unpack_verb_code(temp);";
"endif";
"";
"/* Iff no options are specified, use the content type of the verb";
" * source as the content type.  This alternative exists only to support";
" * legacy editors/tools.  It may be removed.";
" */";
"if (!options && !content_type)";
"  if (`content_type = chunks[2][\"metadata\"][\"content_type\"] ! E_RANGE')";
"    raw = 0;";
"  endif";
"endif";
"";
"/* Programmers can disable versioning (writing \"state\" and \"revision\")";
" * and stamping (writing \"updated_at\" and \"updated_by\"), however this";
" * only works the first time the verb code is set (the purpose of this";
" * functionality is to support package loading and other kinds of";
" * object migration).";
" */";
"do_not_version && chunks && raise(E_INVARG);";
"do_not_stamp && chunks && raise(E_INVARG);";
"";
"if (raw && code && code[$] == \"\\\"-=-=-mxyzptlk-=-=-\\\";\")";
"  return {\"Illegal use of marker\"};";
"";
"elseif (content_type)";
"  source = code;";
"";
"  /* parse the content type to validate it, then generate it in canonical form */";
"  {type, attributes} = this:_parse_content_type(content_type);";
"  content_type = this:_generate_content_type({type, attributes});";
"";
"  /* natively supported... no external compilation necessary */";
"  if (type == \"application/x-moocode\")";
"    ;";
"";
"  /* find an external compiler and compile */";
"  elseif (`valid(compiler = $external_compilers[type]) ! E_RANGE, E_TYPE')";
"    {status, code} = compiler:compile(code, attributes);";
"    if (!status)";
"      return code;";
"    endif";
"";
"  /* fail */";
"  else";
"    return {tostr(\"Invalid content type:  \", type)};";
"  endif";
"";
"  /* If the most recent revision is clean, increment the revision and";
"   * keep all prior revisions.  Else, replace the revision.";
"   */";
"  if (length(chunks) > 1)";
"    if (`chunks[2][\"metadata\"][\"state\"] ! E_RANGE' == \"clean\")";
"      revision = `toint(chunks[2][\"metadata\"][\"revision\"]) + 1 ! E_RANGE => 1';";
"      keep = chunks[2..$];";
"    else";
"      revision = `toint(chunks[2][\"metadata\"][\"revision\"]) ! E_RANGE => 1';";
"      keep = chunks[3..$];";
"    endif";
"  else";
"    revision = 1;";
"    keep = {};";
"  endif";
"";
"  metadata = [";
"    \"chunk_type\" -> \"source\",";
"    \"chunk_length\" -> length(source),";
"    \"content_type\" -> content_type,";
"    \"sha1\" -> value_hash(source, \"sha1\")";
"  ];";
"  if (!do_not_version || chunks)";
"    metadata[\"state\"] = \"dirty\";";
"    metadata[\"revision\"] = revision;";
"  endif";
"  if (!do_not_stamp || chunks)";
"    metadata[\"updated_at\"] = ctime(time());";
"    metadata[\"updated_by\"] = perms;";
"  endif";
"";
"  code = this:_pack_verb_code({[\"code\" -> code], [\"metadata\" -> metadata, \"source\" -> source], @keep});";
"";
"endif";
"";
"return set_verb_code(object, verb, code);";
"";
"/* security audit on Tue Sep 13 18:59:04 2011 EDT */";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:123";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:4";
"sha1:331D0374823E49B367CF562E48625F45DD0F8066";
"state:clean";
"updated_at:Thu Dec 13 07:27:09 2012 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"{object, verb, code, @options} = args;";
"";
"/* check arguments and permissions */";
"valid(object) || raise(E_INVARG);";
"`{owner, flags, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"perms = caller_perms();";
"perms.wizard || (perms == owner) || index(flags, \"w\") || raise(E_PERM);";
"perms.programmer || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(perms);";
"";
"/* interpret optional arguments */";
"raw = 1;";
"content_type = 0;";
"do_not_version = 0;";
"do_not_stamp = 0;";
"if (options)";
"  if (typeof(options[1]) == MAP)";
"    raw = `options[1][\"raw\"] ! E_RANGE';";
"    content_type = `options[1][\"content_type\"] ! E_RANGE' || `options[1][\"content-type\"] ! E_RANGE';";
"    do_not_version = `options[1][\"do_not_version\"] ! E_RANGE' || `options[1][\"do-not-version\"] ! E_RANGE';";
"    do_not_stamp = `options[1][\"do_not_stamp\"] ! E_RANGE' || `options[1][\"do-not-stamp\"] ! E_RANGE';";
"  elseif (typeof(options[1]) == STR && options[1] == \"raw\")";
"    raw = \"raw\";";
"  elseif (typeof(options[1]) == STR)";
"    raw = 0;";
"    content_type = options[1];";
"  endif";
"  if (raw && content_type)";
"    raise(E_INVARG);";
"  endif";
"endif";
"";
"chunks = {};";
"if (temp = verb_code(object, verb))";
"  chunks = this:_unpack_verb_code(temp);";
"endif";
"";
"/* Iff no options are specified, use the content type of the verb";
" * source as the content type.  This alternative exists only to support";
" * legacy editors/tools.  It may be removed.";
" */";
"if (!options && !content_type)";
"  if (`content_type = chunks[2][\"metadata\"][\"content_type\"] ! E_RANGE')";
"    raw = 0;";
"  endif";
"endif";
"";
"/* Programmers can disable versioning (writing \"state\" and \"revision\")";
" * and stamping (writing \"updated_at\" and \"updated_by\"), however this";
" * only works the first time the verb code is set (the purpose of this";
" * functionality is to support package loading and other kinds of";
" * object migration).";
" */";
"do_not_version && chunks && raise(E_INVARG);";
"do_not_stamp && chunks && raise(E_INVARG);";
"";
"if (raw && code && code[$] == \"\\\"-=-=-mxyzptlk-=-=-\\\";\")";
"  return {\"Illegal use of marker\"};";
"";
"elseif (content_type)";
"  source = code;";
"";
"  /* parse the content type to validate it, then generate it in canonical form */";
"  {type, attributes} = this:_parse_content_type(content_type);";
"  content_type = this:_generate_content_type({type, attributes});";
"";
"  /* natively supported... no external compilation necessary */";
"  if (type == \"application/x-moocode\")";
"    ;";
"";
"  /* find an external compiler and compile */";
"  elseif (`valid(compiler = $external_compilers[type]) ! E_RANGE, E_TYPE')";
"    code = compiler:compile(code, attributes);";
"";
"  /* fail */";
"  else";
"    return {tostr(\"Invalid content type:  \", type)};";
"  endif";
"";
"  /* If the most recent revision is clean, increment the revision and";
"   * keep all prior revisions.  Else, replace the revision.";
"   */";
"  if (length(chunks) > 1)";
"    if (`chunks[2][\"metadata\"][\"state\"] ! E_RANGE' == \"clean\")";
"      revision = `toint(chunks[2][\"metadata\"][\"revision\"]) + 1 ! E_RANGE => 1';";
"      keep = chunks[2..$];";
"    else";
"      revision = `toint(chunks[2][\"metadata\"][\"revision\"]) ! E_RANGE => 1';";
"      keep = chunks[3..$];";
"    endif";
"  else";
"    revision = 1;";
"    keep = {};";
"  endif";
"";
"  metadata = [";
"    \"chunk_type\" -> \"source\",";
"    \"chunk_length\" -> length(source),";
"    \"content_type\" -> content_type,";
"    \"sha1\" -> value_hash(source, \"sha1\")";
"  ];";
"  if (!do_not_version || chunks)";
"    metadata[\"state\"] = \"dirty\";";
"    metadata[\"revision\"] = revision;";
"  endif";
"  if (!do_not_stamp || chunks)";
"    metadata[\"updated_at\"] = ctime(time());";
"    metadata[\"updated_by\"] = perms;";
"  endif";
"";
"  code = this:_pack_verb_code({[\"code\" -> code], [\"metadata\" -> metadata, \"source\" -> source], @keep});";
"";
"endif";
"";
"return set_verb_code(object, verb, code);";
"";
"/* security audit on Tue Sep 13 18:59:04 2011 EDT */";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:120";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:3";
"sha1:68360A844092C7A98B6F05C66C2D028240946236";
"state:clean";
"updated_at:Thu Jun  7 08:12:38 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"{object, verb, code, @options} = args;";
"";
"/* check arguments and permissions */";
"valid(object) || raise(E_INVARG);";
"`{owner, flags, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"perms = caller_perms();";
"perms.wizard || (perms == owner) || index(flags, \"w\") || raise(E_PERM);";
"perms.programmer || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(perms);";
"";
"/* interpret optional arguments */";
"raw = 1;";
"content_type = 0;";
"if (options)";
"  if (typeof(options[1]) == MAP)";
"    raw = `options[1][\"raw\"] ! E_RANGE';";
"    content_type = `options[1][\"content_type\"] ! E_RANGE' || `options[1][\"content-type\"] ! E_RANGE';";
"  elseif (typeof(options[1]) == STR && options[1] == \"raw\")";
"    raw = \"raw\";";
"  elseif (typeof(options[1]) == STR)";
"    raw = 0;";
"    content_type = options[1];";
"  endif";
"  if (raw && content_type)";
"    raise(E_INVARG);";
"  endif";
"endif";
"";
"chunks = {};";
"if (temp = verb_code(object, verb))";
"  chunks = this:_unpack_verb_code(temp);";
"endif";
"";
"/* Iff no options are specified, use the content type of the verb";
" * source as the content type.  This alternative exists only to support";
" * legacy editors/tools.  It may be removed.";
" */";
"if (!options && !content_type)";
"  if (`content_type = chunks[2][\"metadata\"][\"content_type\"] ! E_RANGE')";
"    raw = 0;";
"  endif";
"endif";
"";
"if (raw && code && code[$] == \"\\\"-=-=-mxyzptlk-=-=-\\\";\")";
"  return {\"Illegal use of marker\"};";
"";
"elseif (content_type)";
"  source = code;";
"";
"  /* parse the content type to validate it, then generate it in canonical form */";
"  {type, attributes} = this:_parse_content_type(content_type);";
"  content_type = this:_generate_content_type({type, attributes});";
"";
"  /* natively supported... no external compilation necessary */";
"  if (type == \"application/x-moocode\")";
"    ;";
"";
"  /* find an external compiler and compile */";
"  elseif (`valid(compiler = $external_compilers[type]) ! E_RANGE, E_TYPE')";
"    code = compiler:compile(code, attributes);";
"";
"  /* fail */";
"  else";
"    return {tostr(\"Invalid content type:  \", type)};";
"  endif";
"";
"  /* If the most recent revision is clean, increment the revision and";
"   * keep all prior revisions.  Else, replace the revision.";
"   */";
"  if (length(chunks) > 1)";
"    if (`chunks[2][\"metadata\"][\"state\"] ! E_RANGE' == \"clean\")";
"      revision = `toint(chunks[2][\"metadata\"][\"revision\"]) + 1 ! E_RANGE => 1';";
"      keep = chunks[2..$];";
"    else";
"      revision = `toint(chunks[2][\"metadata\"][\"revision\"]) ! E_RANGE => 1';";
"      keep = chunks[3..$];";
"    endif";
"  else";
"    revision = 1;";
"    keep = {};";
"  endif";
"";
"  metadata = [";
"    \"chunk_type\" -> \"source\",";
"    \"chunk_length\" -> length(source),";
"    \"updated_at\" -> ctime(time()),";
"    \"updated_by\" -> caller_perms(),";
"    \"content_type\" -> content_type,";
"    \"sha1\" -> value_hash(source, \"sha1\"),";
"    \"state\" -> \"dirty\",";
"    \"revision\" -> revision";
"  ];";
"  code = this:_pack_verb_code({[\"code\" -> code], [\"metadata\" -> metadata, \"source\" -> source], @keep});";
"";
"endif";
"";
"return set_verb_code(object, verb, code);";
"";
"/* security audit on Tue Sep 13 18:59:04 2011 EDT */";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:102";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:B08019A181F1E20328F2B83072D42C20044630C1";
"state:clean";
"updated_at:Sun May 27 13:03:56 2012 EDT";
"updated_by:#5";
"-=-=-mxyzptlk-=-=-";
"{object, verb, code, @options} = args;";
"";
"/* check arguments and permissions */";
"valid(object) || raise(E_INVARG);";
"`{owner, flags, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"perms = caller_perms();";
"perms.wizard || (perms == owner) || index(flags, \"w\") || raise(E_PERM);";
"perms.programmer || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(perms);";
"";
"/* interpret optional arguments */";
"raw = 1;";
"content_type = 0;";
"if (options)";
"  if (typeof(options[1]) == MAP)";
"    raw = `options[1][\"raw\"] ! E_RANGE';";
"    content_type = `options[1][\"content_type\"] ! E_RANGE' || `options[1][\"content-type\"] ! E_RANGE';";
"  elseif (typeof(options[1]) == STR && options[1] == \"raw\")";
"    raw = \"raw\";";
"  elseif (typeof(options[1]) == STR)";
"    raw = 0;";
"    content_type = options[1];";
"  endif";
"  if (raw && content_type)";
"    raise(E_INVARG);";
"  endif";
"endif";
"";
"chunks = {};";
"if (temp = verb_code(object, verb))";
"  chunks = this:_unpack_verb_code(temp);";
"endif";
"";
"/* Iff no options are specified, use the content type of the verb";
" * source as the content type.  This alternative exists only to support";
" * legacy editors/tools.  It may be removed.";
" */";
"if (!options && !content_type)";
"  if (`content_type = chunks[2][\"metadata\"][\"content_type\"] ! E_RANGE')";
"    raw = 0;";
"  endif";
"endif";
"";
"if (raw && code && code[$] == \"\\\"-=-=-mxyzptlk-=-=-\\\";\")";
"  return {\"Illegal use of marker\"};";
"";
"elseif (content_type)";
"  source = code;";
"";
"  /* parse the content type to validate it, then generate it in canonical form */";
"  {type, attributes} = this:_parse_content_type(content_type);";
"  content_type = this:_generate_content_type({type, attributes});";
"";
"  /* natively supported... no external compilation necessary */";
"  if (type == \"application/x-moocode\")";
"    ;";
"";
"  /* find an external compiler and compile */";
"  elseif (`valid(compiler = $external_compilers[type]) ! E_RANGE, E_TYPE')";
"    code = compiler:compile(code, attributes);";
"";
"  /* fail */";
"  else";
"    return {tostr(\"Invalid content type:  \", type)};";
"  endif";
"";
"  /* If the most recent revision is clean, increment the revision and";
"   * keep all prior revisions.  Else, replace the revision.";
"   */";
"  if (length(chunks) > 1)";
"    if (`chunks[2][\"metadata\"][\"state\"] ! E_RANGE' == \"clean\")";
"      revision = `toint(chunks[2][\"metadata\"][\"revision\"]) + 1 ! E_RANGE => 1';";
"      keep = chunks[2..$];";
"    else";
"      revision = `toint(chunks[2][\"metadata\"][\"revision\"]) ! E_RANGE => 1';";
"      keep = chunks[3..$];";
"    endif";
"  else";
"    revision = 1;";
"    keep = {};";
"  endif";
"";
"  metadata = [";
"    \"chunk_type\" -> \"source\",";
"    \"chunk_length\" -> length(source),";
"    \"updated_at\" -> ctime(time()),";
"    \"content_type\" -> content_type,";
"    \"sha1\" -> value_hash(source, \"sha1\"),";
"    \"state\" -> \"dirty\",";
"    \"revision\" -> revision";
"  ];";
"  code = this:_pack_verb_code({[\"code\" -> code], [\"metadata\" -> metadata, \"source\" -> source], @keep});";
"";
"endif";
"";
"return set_verb_code(object, verb, code);";
"";
"/* security audit on Tue Sep 13 18:59:04 2011 EDT */";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:101";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:3FEC4BE4DEDAED95270BF07692B6CF0DFCC4F5D3";
"state:clean";
"updated_at:Sun May 27 07:16:24 2012 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:16
{object, verb, @options} = args;
valid(object) || raise(E_INVARG);
`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);
callerp = caller_perms();
((`callerp.wizard ! E_INVIND' || (valid(callerp) && (callerp == owner))) || index(perms, "r")) || raise(E_PERM);
`callerp.programmer ! E_INVIND' || raise(E_PERM);
set_task_perms(callerp);
{dobj, prep, iobj} = verb_args(object, verb);
ret = ["owner" -> owner, "perms" -> perms, "names" -> name, "dobj" -> dobj, "prep" -> prep, "iobj" -> iobj];
code = verb_code(object, verb);
chunks = this:_unpack_verb_code(code);
`ret["updated_at"] = chunks[2]["metadata"]["updated_at"] ! E_RANGE';
`ret["updated_by"] = toobj(chunks[2]["metadata"]["updated_by"]) ! E_RANGE';
`ret["content_type"] = chunks[2]["metadata"]["content_type"] ! E_RANGE';
`ret["sha1"] = chunks[2]["metadata"]["sha1"] ! E_RANGE';
`ret["state"] = chunks[2]["metadata"]["state"] ! E_RANGE';
`ret["revision"] = toint(chunks[2]["metadata"]["revision"]) ! E_RANGE';
return ret;
return;
"{object, verb, @options} = args;";
"";
"/* check arguments */";
"valid(object) || raise(E_INVARG);";
"`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"";
"/* check permissions */";
"callerp = caller_perms();";
"`callerp.wizard ! E_INVIND' || (valid(callerp) && callerp == owner) || index(perms, \"r\") || raise(E_PERM);";
"`callerp.programmer ! E_INVIND' || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(callerp);";
"";
"{dobj, prep, iobj} = verb_args(object, verb);";
"";
"ret = [\"owner\" -> owner, \"perms\" -> perms, \"names\" -> name, \"dobj\" -> dobj, \"prep\" -> prep, \"iobj\" -> iobj];";
"";
"code = verb_code(object, verb);";
"chunks = this:_unpack_verb_code(code);";
"";
"`ret[\"updated_at\"] = chunks[2][\"metadata\"][\"updated_at\"] ! E_RANGE';";
"`ret[\"updated_by\"] = toobj(chunks[2][\"metadata\"][\"updated_by\"]) ! E_RANGE';";
"`ret[\"content_type\"] = chunks[2][\"metadata\"][\"content_type\"] ! E_RANGE';";
"`ret[\"sha1\"] = chunks[2][\"metadata\"][\"sha1\"] ! E_RANGE';";
"`ret[\"state\"] = chunks[2][\"metadata\"][\"state\"] ! E_RANGE';";
"`ret[\"revision\"] = toint(chunks[2][\"metadata\"][\"revision\"]) ! E_RANGE';";
"";
"return ret;";
"";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:31";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:172E3B6EFAB13F7D5C64774D3E6BBB8592442EF5";
"state:clean";
"updated_at:Sun May 27 13:06:44 2012 EDT";
"updated_by:#5";
"-=-=-mxyzptlk-=-=-";
"{object, verb, @options} = args;";
"";
"/* check arguments */";
"valid(object) || raise(E_INVARG);";
"`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"";
"/* check permissions */";
"callerp = caller_perms();";
"`callerp.wizard ! E_INVIND' || (valid(callerp) && callerp == owner) || index(perms, \"r\") || raise(E_PERM);";
"`callerp.programmer ! E_INVIND' || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(callerp);";
"";
"{dobj, prep, iobj} = verb_args(object, verb);";
"";
"ret = [\"owner\" -> owner, \"perms\" -> perms, \"names\" -> name, \"dobj\" -> dobj, \"prep\" -> prep, \"iobj\" -> iobj];";
"";
"code = verb_code(object, verb);";
"chunks = this:_unpack_verb_code(code);";
"";
"`ret[\"updated_at\"] = chunks[2][\"metadata\"][\"updated_at\"] ! E_RANGE';";
"`ret[\"content_type\"] = chunks[2][\"metadata\"][\"content_type\"] ! E_RANGE';";
"`ret[\"sha1\"] = chunks[2][\"metadata\"][\"sha1\"] ! E_RANGE';";
"`ret[\"state\"] = chunks[2][\"metadata\"][\"state\"] ! E_RANGE';";
"`ret[\"revision\"] = toint(chunks[2][\"metadata\"][\"revision\"]) ! E_RANGE';";
"";
"return ret;";
"";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:30";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:035A143B93AC8FDFCCBC50884B755B42489EBCAE";
"state:clean";
"updated_at:Sun May 27 10:01:53 2012 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:17
{content_type} = args;
parts = {};
while (content_type && (i = index(content_type, ";")))
parts = {@parts, content_type[1..i - 1]};
content_type = content_type[i + 1..$];
endwhile
parts = {@parts, content_type};
if (parts)
{type, @parts} = parts;
r = match(type, "^ *%([^ ]+%) *$");
type = type[r[3][1][1]..r[3][1][2]];
attributes = [];
for part in (parts)
r = match(part, "^ *%([^ ]+%) *%= *%([^ ]+%) *$");
key = part[r[3][1][1]..r[3][1][2]];
value = part[r[3][2][1]..r[3][2][2]];
attributes[key] = value;
endfor
return {type, attributes};
endif
return {};
return;
"{content_type} = args;";
"";
"/* Not $private() but maybe should be.  The existance and interface";
" * are subject to change.  No obvious security problems, though.";
" */";
"";
"parts = {};";
"while (content_type && (i = index(content_type, \";\")))";
"  parts = {@parts, content_type[1..i - 1]};";
"  content_type = content_type[i + 1..$];";
"endwhile";
"parts = {@parts, content_type};";
"if (parts)";
"  {type, @parts} = parts;";
"  r = match(type, \"^ *%([^ ]+%) *$\");";
"  type = type[r[3][1][1]..r[3][1][2]];";
"  attributes = [];";
"  for part in (parts)";
"    r = match(part, \"^ *%([^ ]+%) *%= *%([^ ]+%) *$\");";
"    key = part[r[3][1][1]..r[3][1][2]];";
"    value = part[r[3][2][1]..r[3][2][2]];";
"    attributes[key] = value;";
"  endfor";
"  return {type, attributes};";
"endif";
"";
"return {};";
"";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:29";
"chunk_type:source";
"content_type:application/x-moocode";
"updated_at:Sat Oct  1 18:22:18 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:18
{content_type} = args;
{type, attributes} = content_type;
for attribute in (mapkeys(attributes))
type = tostr(type, ";", attribute, "=", attributes[attribute]);
endfor
return type;
return;
"{content_type} = args;";
"";
"/* Not $private() but maybe should be.  The existance and interface";
" * are subject to change.  No obvious security problems, though.";
" */";
"";
"{type, attributes} = content_type;";
"";
"for attribute in (mapkeys(attributes))";
"  type = tostr(type, \";\", attribute, \"=\", attributes[attribute]);";
"endfor";
"";
"return type;";
"";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"updated_at:Sat Oct  1 18:22:18 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:19
{object, verb} = args;
valid(object) || raise(E_INVARG);
`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);
callerp = caller_perms();
((`callerp.wizard ! ANY' || (valid(callerp) && (callerp == owner))) || index(perms, "r")) || raise(E_PERM);
`callerp.programmer ! ANY' || raise(E_PERM);
set_task_perms(callerp);
code = verb_code(object, verb);
chunks = this:_unpack_verb_code(code);
if (length(chunks) == 1)
raise(E_INVARG, "Nothing to commit:  old-style verb");
endif
if (`chunks[2]["metadata"]["state"] ! E_RANGE' != "dirty")
raise(E_INVARG, "Nothing to commit:  not dirty");
endif
chunks[2]["metadata"]["state"] = "clean";
code = this:_pack_verb_code(chunks);
return set_verb_code(object, verb, code);
return;
"{object, verb} = args;";
"";
"/* check arguments */";
"valid(object) || raise(E_INVARG);";
"`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"";
"/* check permissions */";
"callerp = caller_perms();";
"`callerp.wizard ! ANY' || (valid(callerp) && callerp == owner) || index(perms, \"r\") || raise(E_PERM);";
"`callerp.programmer ! ANY' || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(callerp);";
"";
"code = verb_code(object, verb);";
"chunks = this:_unpack_verb_code(code);";
"";
"if (length(chunks) == 1)";
"  raise(E_INVARG, \"Nothing to commit:  old-style verb\");";
"endif";
"";
"if (`chunks[2][\"metadata\"][\"state\"] ! E_RANGE' != \"dirty\")";
"  raise(E_INVARG, \"Nothing to commit:  not dirty\");";
"endif";
"";
"chunks[2][\"metadata\"][\"state\"] = \"clean\";";
"";
"code = this:_pack_verb_code(chunks);";
"";
"return set_verb_code(object, verb, code);";
"";
"chunk_length:30";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:C97460810709B14FD371C31B1E0EF65510578A5F";
"state:clean";
"updated_at:Sun May 27 10:01:53 2012 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:20
{object, verb} = args;
valid(object) || raise(E_INVARG);
`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);
callerp = caller_perms();
((`callerp.wizard ! ANY' || (valid(callerp) && (callerp == owner))) || index(perms, "r")) || raise(E_PERM);
`callerp.programmer ! ANY' || raise(E_PERM);
set_task_perms(callerp);
code = verb_code(object, verb);
chunks = this:_unpack_verb_code(code);
if (length(chunks) == 1)
raise(E_INVARG, "Nothing to revert:  old-style verb");
endif
if (`chunks[2]["metadata"]["state"] ! E_RANGE' != "dirty")
raise(E_INVARG, "Nothing to revert:  not dirty");
endif
if (length(chunks) < 3)
raise(E_INVARG, "Nothing to revert");
endif
keep = chunks[3..$];
chunk = keep[1];
content_type = chunk["metadata"]["content_type"];
{type, attributes} = this:_parse_content_type(content_type);
content_type = this:_generate_content_type({type, attributes});
if (type == "application/x-moocode")
code = chunk["source"];
elseif (`valid(compiler = $external_compilers[type]) ! E_RANGE, E_TYPE')
code = compiler:compile(chunk["source"], attributes);
else
return {tostr("Invalid content type:  ", type)};
endif
code = this:_pack_verb_code({["code" -> code], @keep});
return set_verb_code(object, verb, code);
return;
"{object, verb} = args;";
"";
"/* check arguments */";
"valid(object) || raise(E_INVARG);";
"`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"";
"/* check permissions */";
"callerp = caller_perms();";
"`callerp.wizard ! ANY' || (valid(callerp) && callerp == owner) || index(perms, \"r\") || raise(E_PERM);";
"`callerp.programmer ! ANY' || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(callerp);";
"";
"code = verb_code(object, verb);";
"chunks = this:_unpack_verb_code(code);";
"";
"if (length(chunks) == 1)";
"  raise(E_INVARG, \"Nothing to revert:  old-style verb\");";
"endif";
"";
"if (`chunks[2][\"metadata\"][\"state\"] ! E_RANGE' != \"dirty\")";
"  raise(E_INVARG, \"Nothing to revert:  not dirty\");";
"endif";
"";
"if (length(chunks) < 3)";
"  raise(E_INVARG, \"Nothing to revert\");";
"endif";
"";
"/* discard the raw code and the dirty revision */";
"keep = chunks[3..$];";
"chunk = keep[1];";
"";
"/* a revision should _always_ have a content type */";
"content_type = chunk[\"metadata\"][\"content_type\"];";
"";
"/* parse the content type to validate it, then generate it in canonical form */";
"{type, attributes} = this:_parse_content_type(content_type);";
"content_type = this:_generate_content_type({type, attributes});";
"";
"/* natively supported... no external compilation necessary */";
"if (type == \"application/x-moocode\")";
"  code = chunk[\"source\"];";
"";
"/* find an external compiler and compile */";
"elseif (`valid(compiler = $external_compilers[type]) ! E_RANGE, E_TYPE')";
"  code = compiler:compile(chunk[\"source\"], attributes);";
"";
"/* fail */";
"else";
"  return {tostr(\"Invalid content type:  \", type)};";
"endif";
"";
"code = this:_pack_verb_code({[\"code\" -> code], @keep});";
"";
"return set_verb_code(object, verb, code);";
"";
"chunk_length:56";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:2DAA5677A2901D79B60C15C1A1FA9E068DBD8796";
"state:clean";
"updated_at:Fri Jun  8 08:31:17 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"{object, verb} = args;";
"";
"/* check arguments */";
"valid(object) || raise(E_INVARG);";
"`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"";
"/* check permissions */";
"callerp = caller_perms();";
"`callerp.wizard ! ANY' || (valid(callerp) && callerp == owner) || index(perms, \"r\") || raise(E_PERM);";
"`callerp.programmer ! ANY' || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(callerp);";
"";
"code = verb_code(object, verb);";
"chunks = this:_unpack_verb_code(code);";
"";
"if (length(chunks) == 1)";
"  raise(E_INVARG, \"Nothing to revert:  old-style verb\");";
"endif";
"";
"if (`chunks[2][\"metadata\"][\"state\"] ! E_RANGE' != \"dirty\")";
"  raise(E_INVARG, \"Nothing to revert:  not dirty\");";
"endif";
"";
"if (length(chunks) < 3)";
"  raise(E_INVARG, \"Nothing to revert\");";
"endif";
"";
"chunks = {chunks[1], @chunks[3..$]};";
"";
"code = this:_pack_verb_code(chunks);";
"";
"return set_verb_code(object, verb, code);";
"";
"chunk_length:34";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:C055EA137DC455E211ACF1EDC5C85327AED1A6EA";
"state:clean";
"updated_at:Sun May 27 10:01:53 2012 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:21
{reference, ?options = []} = args;
packages = $composed.packages;
provides_cache = $composed.provides_cache;
requires_cache = $composed.requires_cache;
set_task_perms(perms = caller_perms());
if (typeof(`enclosing_package = options["package"] ! E_RANGE') != ERR)
if ((valid(enclosing_package) && (enclosing_package in packages)) && perms.wizard)
elseif (perms.wizard)
raise(E_INVARG);
else
raise(E_PERM);
endif
else
enclosing_package = callers()[1][4];
while (valid(enclosing_package) && (!(enclosing_package in packages)))
enclosing_package = enclosing_package.location;
endwhile
endif
if (!valid(enclosing_package))
raise(E_INVIND, "Invalid indirection:  no enclosing package");
endif
if (reference == "__package__")
return enclosing_package;
elseif (reference == "__owner__")
return enclosing_package.owner;
elseif (r = match(reference, "^%([a-z_][a-z0-9_]*%)%(|%([a-z][a-z0-9_]*%)%)?$"))
reference = r[4][r[3][1][1]..r[3][1][2]];
package = `r[4][r[3][3][1]..r[3][3][2]] ! E_RANGE';
if ((!package) || (package == enclosing_package.identifier))
package = enclosing_package;
else
if (`versions = requires_cache[package] ! E_RANGE')
for packages, version in (versions)
if (enclosing_package in packages)
package = provides_cache[package][version][1];
break;
endif
endfor
else
package = $nothing;
endif
endif
for entry in (`package.manifest ! ANY => {}')
{object, label} = entry;
if (reference == label)
return object;
endif
endfor
endif
return $failed_match;
return;
"{reference, ?options = []} = args;";
"";
"/* get package info... */";
"packages = $composed.packages;";
"provides_cache = $composed.provides_cache;";
"requires_cache = $composed.requires_cache;";
"";
"/* ...then drop perms... */";
"set_task_perms(perms = caller_perms());";
"";
"/* If the caller has wiz-perms, it can set the enclosing package";
" * explicitly.  The enclosing package is the point-of-view from";
" * which we look up references.";
" */";
"if (typeof(`enclosing_package = options[\"package\"] ! E_RANGE') != ERR)";
"  if (valid(enclosing_package) && (enclosing_package in packages) && perms.wizard)";
"    ;";
"  elseif (perms.wizard)";
"    raise(E_INVARG);";
"  else";
"    raise(E_PERM);";
"  endif";
"";
"/* Otherwise, start where the verb was defined and search for";
" * the enclosing package.";
" */";
"else";
"  enclosing_package = callers()[1][4];";
"  while (valid(enclosing_package) && !(enclosing_package in packages))";
"    enclosing_package = enclosing_package.location;";
"  endwhile";
"";
"endif";
"";
"/* Raise an error if we make it to the top without finding an";
" * enclosing package -- this typically means that `$lookup()' has been";
" * called from a verb on an object that is in a package that has not";
" * yet been _installed_.";
" */";
"if (!valid(enclosing_package))";
"  raise(E_INVIND, \"Invalid indirection:  no enclosing package\");";
"endif";
"";
"/* find the reference */";
"if (reference == \"__package__\")";
"  return enclosing_package;";
"";
"elseif (reference == \"__owner__\")";
"  return enclosing_package.owner;";
"";
"elseif (r = match(reference, \"^%([a-z_][a-z0-9_]*%)%(|%([a-z][a-z0-9_]*%)%)?$\"))";
"  reference = r[4][r[3][1][1]..r[3][1][2]];";
"  package = `r[4][r[3][3][1]..r[3][3][2]] ! E_RANGE';";
"  if (!package || (package == enclosing_package.identifier))";
"    package = enclosing_package;";
"  else";
"    if (`versions = requires_cache[package] ! E_RANGE')";
"      for packages, version in (versions)";
"        if (enclosing_package in packages)";
"          package = provides_cache[package][version][1];";
"          break;";
"        endif";
"      endfor";
"    else";
"      package = $nothing;";
"    endif";
"  endif";
"  for entry in (`package.manifest ! ANY => {}')";
"    {object, label} = entry;";
"    if (reference == label)";
"      return object;";
"    endif";
"  endfor";
"endif";
"";
"return $failed_match;";
"";
"chunk_length:76";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:47F06BC1BFE0AF565C3F48257B346AB3F86F6F74";
"state:clean";
"updated_at:Tue Jul 10 07:24:45 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"{reference, ?options = []} = args;";
"";
"/* get package info... */";
"packages = $composed.packages;";
"provides_cache = $composed.provides_cache;";
"requires_cache = $composed.requires_cache;";
"";
"/* ...then drop perms... */";
"set_task_perms(perms = caller_perms());";
"";
"/* If the caller has wiz-perms, it can set the enclosing package";
" * explicitly.  The enclosing package is the point-of-view from";
" * which we look up references.";
" */";
"if (typeof(`enclosing_package = options[\"package\"] ! E_RANGE') != ERR)";
"  if (valid(enclosing_package) && (enclosing_package in packages) && perms.wizard)";
"    ;";
"  elseif (perms.wizard)";
"    raise(E_INVARG);";
"  else";
"    raise(E_PERM);";
"  endif";
"";
"/* Otherwise, start where the verb was defined and search for";
" * the enclosing package.";
" */";
"else";
"  enclosing_package = callers()[1][4];";
"  while (valid(enclosing_package) && !(enclosing_package in packages))";
"    enclosing_package = enclosing_package.location;";
"  endwhile";
"";
"endif";
"";
"/* Raise an error if we make it to the top without finding an";
" * enclosing package -- this typically means that `$lookup()' has been";
" * called from a verb on an object that is in a package that has not";
" * yet been _installed_.";
" */";
"if (!valid(enclosing_package))";
"  raise(E_INVIND, \"Invalid indirection:  no enclosing package\");";
"endif";
"";
"/* find the reference */";
"if (reference == \"__package__\")";
"  return enclosing_package;";
"";
"elseif (reference == \"__owner__\")";
"  return enclosing_package.owner;";
"";
"elseif (r = match(reference, \"^%([a-z_][a-z0-9_]*%)%(|%([a-z][a-z0-9_]*%)%)?$\"))";
"  reference = r[4][r[3][1][1]..r[3][1][2]];";
"  package = `r[4][r[3][3][1]..r[3][3][2]] ! E_RANGE';";
"  if (package)";
"    if (`versions = requires_cache[package] ! E_RANGE')";
"      for packages, version in (versions)";
"        if (enclosing_package in packages)";
"          package = provides_cache[package][version][1];";
"          break;";
"        endif";
"      endfor";
"    else";
"      package = $nothing;";
"    endif";
"  else";
"    package = enclosing_package;";
"  endif";
"  for entry in (`package.manifest ! ANY => {}')";
"    {object, label} = entry;";
"    if (reference == label)";
"      return object;";
"    endif";
"  endfor";
"endif";
"";
"return $failed_match;";
"";
"chunk_length:76";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:7F52AC72A1975B9D81567EBD29438F08E5A46C18";
"state:clean";
"updated_at:Mon Jun  4 07:46:49 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#3:0
{code, message, value, traceback, formatted} = args;
callers() && raise(E_PERM, "Server task");
for line in (formatted)
server_log(line);
endfor
.
#3:1
{resource, traceback, formatted} = args;
callers() && raise(E_PERM, "Server task");
for line in (formatted)
server_log(line);
endfor
.
#3:2
$restrict_to_caller($system, "server_started");
$last_login_connection = #-1;
if (!$disable_passkey_login)
server_log(tostr("WARNING: Log-in via passkey is enabled for the following players (specified in $passkey_players):"));
for player in ($passkey_players)
server_log(tostr("WARNING:   \"", player.name, "\" (", player, ")"));
endfor
server_log("WARNING: This is a severe security vulnerability.  In a secure environment you should:");
server_log("WARNING:   disable passkey login:");
server_log("WARNING:     ; $disable_passkey_login = 1");
server_log("WARNING:     ; $passkey_players = {}");
server_log("WARNING:   disable existing passkeys:");
for player in ($passkey_players)
server_log(tostr("WARNING:     ; ", player, ".passkey = 0"));
endfor
server_log("WARNING:   and for good measure:");
for player in ($passkey_players)
server_log(tostr("WARNING:     ; set_player_flag(", player, ", 0)"));
endfor
i = random(100000) + 100000;
for player in ($passkey_players)
passkey = string_hash((tostr(random()) + ctime(time())) + player.name);
while (i)
((!(i % 100)) && ((ticks_left() < 2000) || (seconds_left() < 2))) && suspend(0);
passkey = string_hash(passkey);
i = i - 1;
endwhile
server_log(tostr("PASSKEY for \"", player.name, "\" (", player, ("): " + passkey) + " (keep it secret)"));
player.passkey = passkey;
endfor
endif
.
#3:3
$restrict_to_caller($system, "authenticate");
if (length(args) == 1)
{passkey} = args;
if (!$disable_passkey_login)
for player in ($passkey_players)
if (length(passkey) == length(player.passkey))
count = 0;
for i in [1..length(passkey)]
count = ((passkey[i] == player.passkey[i]) ? 1 | 0) + count;
endfor
if (length(passkey) == count)
return player;
endif
endif
endfor
endif
endif
return $failed_match;
.
#5:0
if (player != this)
notify(player, "I couldn't understand that.");
return;
endif
if (!player.wizard)
notify(player, "You must be a wizard to do that!");
return;
endif
if (length($composed.packages) > 1)
notify(player, "You have non-kernel packages installed.");
return;
endif
notify(player, "Bye!");
boot_player(player);
for task in (queued_tasks())
kill_task(task[1]);
endfor
$external_compilers = [];
$last_login_connection = 0;
$disable_passkey_login = 0;
#5.passkey = 0;
#6.passkey = 0;
$composed.last_fetch_index = 0;
$composed.archived = [];
$composed.cached = [];
$composed.archive_host = "stunt.io";
$composed.archive_port = 80;
$composed.archive_base_uri = "/v1";
chparents(#0, {#3});
chparents(#5, {});
chparents(#6, {});
package = $composed:export(#2);
json = generate_json(package, "embedded-types");
while (len = length(json))
len = (len > 60000) ? 60000 | len;
line = json[1..len];
json[1..len] = "";
server_log(line);
endwhile
reset_max_object();
shutdown();
return;
"if (player != this)";
"  notify(player, \"I couldn't understand that.\");";
"  return;";
"endif";
"if (!player.wizard)";
"  notify(player, \"You must be a wizard to do that!\");";
"  return;";
"endif";
"";
"if (length($composed.packages) > 1)";
"  notify(player, \"You have non-kernel packages installed.\");";
"  return;";
"endif";
"";
"notify(player, \"Bye!\");";
"boot_player(player);";
"";
"for task in (queued_tasks())";
"  kill_task(task[1]);";
"endfor";
"";
"#0.external_compilers = [];";
"#0.last_login_connection = 0;";
"";
"#0.disable_passkey_login = 0;";
"#5.passkey = 0;";
"#6.passkey = 0;";
"";
"$composed.last_fetch_index = 0;";
"$composed.archived = [];";
"$composed.cached = [];";
"$composed.archive_host = \"stunt.io\";";
"$composed.archive_port = 80;";
"$composed.archive_base_uri = \"/v1\";";
"";
"chparents(#0, {#3});";
"chparents(#5, {});";
"chparents(#6, {});";
"";
"package = $composed:export(#2);";
"json = generate_json(package, \"embedded-types\");";
"while (len = length(json))";
"  len = len > 60000 ? 60000 | len;";
"  line = json[1..len];";
"  json[1..len] = \"\";";
"  server_log(line);";
"endwhile";
"";
"reset_max_object();";
"shutdown();";
"";
"chunk_length:50";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:5C95C676E18ED894FEA3815168B45C61A676C384";
"state:clean";
"updated_at:Fri Jun 15 08:16:15 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"if (player != this)";
"  notify(player, \"I couldn't understand that.\");";
"  return;";
"endif";
"if (!player.wizard)";
"  notify(player, \"You must be a wizard to do that!\");";
"  return;";
"endif";
"";
"notify(player, \"Bye!\");";
"boot_player(player);";
"";
"for task in (queued_tasks())";
"  kill_task(task[1]);";
"endfor";
"";
"#0.external_compilers = [];";
"#0.last_login_connection = 0;";
"";
"#0.disable_passkey_login = 0;";
"#5.passkey = 0;";
"#6.passkey = 0;";
"";
"$composed.last_fetch_index = 0;";
"$composed.archived = [];";
"$composed.cached = [];";
"$composed.archive_host = \"stunt.io\";";
"$composed.archive_port = 80;";
"$composed.archive_base_uri = \"/v1\";";
"";
"chparents(#0, {#3});";
"chparents(#5, {});";
"chparents(#6, {});";
"";
"package = $composed:export(#2);";
"json = generate_json(package, \"embedded-types\");";
"while (len = length(json))";
"  len = len > 60000 ? 60000 | len;";
"  line = json[1..len];";
"  json[1..len] = \"\";";
"  server_log(line);";
"endwhile";
"";
"reset_max_object();";
"shutdown();";
"";
"chunk_length:45";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:5F2772CC24EF8919388024B96775CCE52D7FE6D0";
"state:clean";
"updated_at:Thu Jun 14 07:35:02 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#5:1
callers() && raise(E_PERM, "Server task");
set_task_perms(player);
"very simple, really primitive matching";
if (((prepstr == "with") && (iobjstr == "$composed")) && `valid($composed) ! ANY')
if ((verb in {"@install", "@uninstall", "@list"}) && `respond_to($composed, verb) ! ANY')
return $composed:(verb)(@args);
endif
endif
notify(player, "I couldn't understand that.");
.
#7:0
if (player.location != this)
notify(player, "I couldn't understand that.");
return;
elseif (!player.programmer)
notify(player, "You need to be a programmer to evaluate code.");
return;
endif
set_task_perms(player);
if (!(args[1] in {";", "if", "for", "while", "fork", "return"}))
notify(player, toliteral(eval(("return " + argstr) + ";")[2]));
else
notify(player, toliteral(eval(argstr + ";")[2]));
endif
.
#8:0
$private();
notify(player, tostr(@args));
return;
"$private();";
"notify(player, tostr(@args));";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:4D3218AE4E5E033F8DEBE454635C738FD9A8FC0A";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:1
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
return;
"/* intentionally not $private() */";
"(ticks_left() < 10000 || seconds_left() < 2) && suspend(0);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:2C1EA11D12899B2BA0E13071EB96FB49B19F22AE";
"state:clean";
"updated_at:Fri Jun  8 06:28:02 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:2
{who, what} = args;
return (who == what.owner) || who.wizard;
return;
"{who, what} = args;";
"return who == what.owner || who.wizard;";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:9DD4270A2909D7E9B7ACF51318A725A3B6018DAE";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:3
{who, what, name} = args;
$private();
return (who == verb_info(what, name)[1]) || who.wizard;
return;
"{who, what, name} = args;";
"$private();";
"return who == verb_info(what, name)[1] || who.wizard;";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:1CD475E09642CB93FFE212FC6EBC0D3AE8C6FC0A";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:4
{who, what, name} = args;
$private();
return (who == property_info(what, name)[1]) || who.wizard;
return;
"{who, what, name} = args;";
"$private();";
"return who == property_info(what, name)[1] || who.wizard;";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:E2A6A9525DE1893AB0B8744CC406118FABF8A208";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:5
args && raise(E_ARGS);
set_task_perms(caller_perms());
r = [];
r["Objects"] = {};
return r;
return;
"args && raise(E_ARGS);";
"set_task_perms(caller_perms());";
"r = [];";
"r[\"Objects\"] = {};";
"return r;";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:2A97664DD035B6AD7F03BA1868859F92532B37D5";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:6
{o, ?options = []} = args;
((ticks_left() < 2000) || (seconds_left() < 2)) && suspend(0);
if (`valid(o) ! E_TYPE => 0')
pcount = length(properties(o));
vcount = length(verbs(o));
set_task_perms(caller_perms());
r = ["Attributes" -> []];
v = parents(o);
m = ["id" -> "parents"];
m["status"] = this:_controls(caller_perms(), o) ? "writable" | "readable";
r["Attributes"]["parents"] = ["Meta" -> m, "Value" -> ["value" -> v]];
v = is_player(o);
m = ["id" -> "player"];
m["status"] = `caller_perms().wizard ! E_INVIND' ? "writable" | "readable";
r["Attributes"]["player"] = ["Meta" -> m, "Value" -> ["value" -> v]];
r["Values"] = [];
for a in (this:_values(o))
this:_suspend_if_necessary();
r["Values"][a] = this:read_value(o, a);
endfor
r["Properties"] = {};
for p in [1..pcount]
this:_suspend_if_necessary();
r["Properties"] = {@r["Properties"], this:read_property(o, p)};
endfor
r["Verbs"] = {};
for v in [1..vcount]
this:_suspend_if_necessary();
r["Verbs"] = {@r["Verbs"], this:read_verb(o, v)};
endfor
if (p = o.w || this:_controls(caller_perms(), o))
status = "writable";
elseif (o.r)
status = "readable";
else
status = "";
endif
r["Meta"] = ["id" -> toint(o), "status" -> status];
return r;
else
r = ["Meta" -> ["id" -> toint(o), "status" -> "invalid"]];
return r;
endif
return;
"{o, ?options = []} = args;";
"";
"ticks_left() < 2000 || seconds_left() < 2 && suspend(0);";
"";
"if (`valid(o) ! E_TYPE => 0')";
"";
"  /* inform ourselves about basic object structure before losing perms */";
"  pcount = length(properties(o));";
"  vcount = length(verbs(o));";
"";
"  set_task_perms(caller_perms());";
"";
"  r = [\"Attributes\" -> []];";
"  v = parents(o);";
"  m = [\"id\" -> \"parents\"];";
"  m[\"status\"] = this:_controls(caller_perms(), o) ? \"writable\" | \"readable\";";
"  r[\"Attributes\"][\"parents\"] = [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];";
"";
"  v = is_player(o);";
"  m = [\"id\" -> \"player\"];";
"  m[\"status\"] = `caller_perms().wizard ! E_INVIND' ? \"writable\" | \"readable\";";
"  r[\"Attributes\"][\"player\"] = [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];";
"";
"  r[\"Values\"] = [];";
"  for a in (this:_values(o))";
"    this:_suspend_if_necessary();";
"    r[\"Values\"][a] = this:read_value(o, a);";
"  endfor";
"";
"  r[\"Properties\"] = {};";
"  for p in [1..pcount]";
"    this:_suspend_if_necessary();";
"    r[\"Properties\"] = {@r[\"Properties\"], this:read_property(o, p)};";
"  endfor";
"";
"  r[\"Verbs\"] = {};";
"  for v in [1..vcount]";
"    this:_suspend_if_necessary();";
"    r[\"Verbs\"] = {@r[\"Verbs\"], this:read_verb(o, v)};";
"  endfor";
"";
"  if (p = o.w || this:_controls(caller_perms(), o))";
"    status = \"writable\";";
"  elseif (o.r)";
"    status = \"readable\";";
"  else";
"    status = \"\";";
"  endif";
"";
"  r[\"Meta\"] = [\"id\" -> toint(o), \"status\" -> status];";
"  return r;";
"else";
"  r = [\"Meta\" -> [\"id\" -> toint(o), \"status\" -> \"invalid\"]];";
"  return r;";
"endif";
"";
"chunk_length:55";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:7E46C2270B6829A9A4C363E630847151A5F1D518";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:7
{o, r, ?options = []} = args;
((ticks_left() < 2000) || (seconds_left() < 2)) && suspend(0);
if (`valid(o) ! E_TYPE => 0')
properties = properties(o);
verbs = verbs(o);
set_task_perms(caller_perms());
try
r["Attributes"];
r["Values"];
r["Properties"];
r["Verbs"];
errors = 0;
parents = `r["Attributes"]["parents"]["Value"]["value"] ! E_RANGE => parents(o)';
if (parents(o) != parents)
x = this:_write_parents(o, ["Value" -> ["value" -> {}]]);
errors = errors + ("Error" in mapkeys(x));
endif
location = `r["Values"]["location"]["Value"]["value"] ! E_RANGE => o.location';
if (o.location != location)
x = this:write_value(o, "location", ["Value" -> ["value" -> $nothing]]);
errors = errors + ("Error" in mapkeys(x));
endif
owner = `r["Values"]["owner"]["Value"]["value"] ! E_RANGE => o.owner';
if ("owner" in mapkeys(r["Values"]))
r["Values"]["owner"] = this:write_value(o, "owner", r["Values"]["owner"]);
errors = errors + ("Error" in mapkeys(r["Values"]["owner"]));
endif
if ("parents" in mapkeys(r["Attributes"]))
r["Attributes"]["parents"] = this:_write_parents(o, r["Attributes"]["parents"]);
errors = errors + ("Error" in mapkeys(r["Attributes"]["parents"]));
endif
if ("player" in mapkeys(r["Attributes"]))
r["Attributes"]["player"] = this:_write_player(o, r["Attributes"]["player"]);
errors = errors + ("Error" in mapkeys(r["Attributes"]["player"]));
endif
if ("location" in mapkeys(r["Values"]))
r["Values"]["location"] = this:write_value(o, "location", r["Values"]["location"]);
errors = errors + ("Error" in mapkeys(r["Values"]["location"]));
endif
if ((lp1 = length(properties)) < (lp2 = length(r["Properties"])))
for p in [lp1 + 1..lp2]
this:_suspend_if_necessary();
`add_property(o, tostr("___", p, "___"), 0, {owner, ""}) ! E_PERM';
endfor
else
for p in [lp2 + 1..lp1]
this:_suspend_if_necessary();
delete_property(o, properties[p]);
endfor
endif
if ((lv1 = length(verbs)) < (lv2 = length(r["Verbs"])))
for v in [lv1 + 1..lv2]
this:_suspend_if_necessary();
`add_verb(o, {owner, "", tostr("___", v, "___")}, {"this", "none", "this"}) ! E_PERM';
endfor
else
for v in [lv2 + 1..lv1]
this:_suspend_if_necessary();
delete_verb(o, lv2 + 1);
endfor
endif
for p in [1..length(r["Properties"])]
this:_suspend_if_necessary();
r["Properties"][p] = this:write_property(o, p, r["Properties"][p]);
if ("Error" in mapkeys(r["Properties"][p]))
if ((lp1 < lp2) && (r["Properties"][p]["Error"]["diagnostic"] == "property is invalid"))
r["Properties"][p]["Error"]["diagnostic"] = "permission denied";
endif
errors = errors + 1;
endif
endfor
for v in [1..length(r["Verbs"])]
this:_suspend_if_necessary();
r["Verbs"][v] = this:write_verb(o, v, r["Verbs"][v], `options["verbs"] ! E_RANGE => []');
if ("Error" in mapkeys(r["Verbs"][v]))
if ((lv1 < lv2) && (r["Verbs"][v]["Error"]["diagnostic"] == "verb is invalid"))
r["Verbs"][v]["Error"]["diagnostic"] = "permission denied";
endif
errors = errors + 1;
endif
endfor
values = setremove(setremove(mapkeys(r["Values"]), "location"), "owner");
for a in (values)
this:_suspend_if_necessary();
r["Values"][a] = this:write_value(o, a, r["Values"][a]);
errors = errors + ("Error" in mapkeys(r["Values"][a]));
endfor
if (errors < 1)
r = this:read_object(o);
else
r["Meta"] = ["id" -> toint(o), "status" -> "unknown"];
r["Error"] = ["diagnostic" -> "errors in sub-operations"];
endif
return r;
except (E_RANGE, E_TYPE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
endtry
else
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
endif
return;
"{o, r, ?options = []} = args;";
"";
"ticks_left() < 2000 || seconds_left() < 2 && suspend(0);";
"";
"if (`valid(o) ! E_TYPE => 0')";
"";
"  /* inform ourselves about basic object structure before losing perms */";
"  properties = properties(o);";
"  verbs = verbs(o);";
"";
"  set_task_perms(caller_perms());";
"";
"  try";
"    /* get basic message format checks out of the way */";
"    r[\"Attributes\"];";
"    r[\"Values\"];";
"    r[\"Properties\"];";
"    r[\"Verbs\"];";
"";
"    errors = 0;";
"";
"    /* Before doing anything else, reset the object to a known";
"     * state. If the parents are going to change, set the parents";
"     * to an empty list; if the location is going to change, move";
"     * the object to $nothing.";
"     */";
"";
"    parents = `r[\"Attributes\"][\"parents\"][\"Value\"][\"value\"] ! E_RANGE => parents(o)';";
"";
"    if (parents(o) != parents)";
"      x = this:_write_parents(o, [\"Value\" -> [\"value\" -> {}]]);";
"      errors = errors + (\"Error\" in mapkeys(x));";
"    endif";
"";
"    location = `r[\"Values\"][\"location\"][\"Value\"][\"value\"] ! E_RANGE => o.location';";
"";
"    if (o.location != location)";
"      x = this:write_value(o, \"location\", [\"Value\" -> [\"value\" -> $nothing]]);";
"      errors = errors + (\"Error\" in mapkeys(x));";
"    endif";
"";
"    owner = `r[\"Values\"][\"owner\"][\"Value\"][\"value\"] ! E_RANGE => o.owner';";
"";
"    /* Do the owner, parents, player and location values first, in that";
"     * order.  Then properties and verbs.  Then the rest of the";
"     * values.";
"     */";
"";
"    if (\"owner\" in mapkeys(r[\"Values\"]))";
"      r[\"Values\"][\"owner\"] = this:write_value(o, \"owner\", r[\"Values\"][\"owner\"]);";
"      errors = errors + (\"Error\" in mapkeys(r[\"Values\"][\"owner\"]));";
"    endif";
"";
"    if (\"parents\" in mapkeys(r[\"Attributes\"]))";
"      r[\"Attributes\"][\"parents\"] = this:_write_parents(o, r[\"Attributes\"][\"parents\"]);";
"      errors = errors + (\"Error\" in mapkeys(r[\"Attributes\"][\"parents\"]));";
"    endif";
"";
"    if (\"player\" in mapkeys(r[\"Attributes\"]))";
"      r[\"Attributes\"][\"player\"] = this:_write_player(o, r[\"Attributes\"][\"player\"]);";
"      errors = errors + (\"Error\" in mapkeys(r[\"Attributes\"][\"player\"]));";
"    endif";
"";
"    if (\"location\" in mapkeys(r[\"Values\"]))";
"      r[\"Values\"][\"location\"] = this:write_value(o, \"location\", r[\"Values\"][\"location\"]);";
"      errors = errors + (\"Error\" in mapkeys(r[\"Values\"][\"location\"]));";
"    endif";
"";
"    if ((lp1 = length(properties)) < (lp2 = length(r[\"Properties\"])))";
"      for p in [lp1 + 1..lp2]";
"        this:_suspend_if_necessary();";
"        `add_property(o, tostr(\"___\", p, \"___\"), 0, {owner, \"\"}) ! E_PERM';";
"      endfor";
"    else";
"      for p in [lp2 + 1..lp1]";
"        this:_suspend_if_necessary();";
"        delete_property(o, properties[p]);";
"      endfor";
"    endif";
"";
"    if ((lv1 = length(verbs)) < (lv2 = length(r[\"Verbs\"])))";
"      for v in [lv1 + 1..lv2]";
"        this:_suspend_if_necessary();";
"        `add_verb(o, {owner, \"\", tostr(\"___\", v, \"___\")}, {\"this\", \"none\", \"this\"}) ! E_PERM';";
"      endfor";
"    else";
"      for v in [lv2 + 1..lv1]";
"        this:_suspend_if_necessary();";
"        delete_verb(o, lv2 + 1);";
"      endfor";
"    endif";
"";
"    for p in [1..length(r[\"Properties\"])]";
"      this:_suspend_if_necessary();";
"      r[\"Properties\"][p] = this:write_property(o, p, r[\"Properties\"][p]);";
"      if (\"Error\" in mapkeys(r[\"Properties\"][p]))";
"        if (lp1 < lp2 && r[\"Properties\"][p][\"Error\"][\"diagnostic\"] == \"property is invalid\")";
"          /* if we had to add properties but the property does not actually exist it should have been... */";
"          r[\"Properties\"][p][\"Error\"][\"diagnostic\"] = \"permission denied\";";
"        endif";
"        errors = errors + 1;";
"      endif";
"    endfor";
"";
"    for v in [1..length(r[\"Verbs\"])]";
"      this:_suspend_if_necessary();";
"      r[\"Verbs\"][v] = this:write_verb(o, v, r[\"Verbs\"][v], `options[\"verbs\"] ! E_RANGE => []');";
"      if (\"Error\" in mapkeys(r[\"Verbs\"][v]))";
"        if (lv1 < lv2 && r[\"Verbs\"][v][\"Error\"][\"diagnostic\"] == \"verb is invalid\")";
"          /* if we had to add verbs but the verb does not actually exist it should have been... */";
"          r[\"Verbs\"][v][\"Error\"][\"diagnostic\"] = \"permission denied\";";
"        endif";
"        errors = errors + 1;";
"      endif";
"    endfor";
"";
"    /* do the rest of the values */";
"";
"    values = setremove(setremove(mapkeys(r[\"Values\"]), \"location\"), \"owner\");";
"";
"    for a in (values)";
"      this:_suspend_if_necessary();";
"      r[\"Values\"][a] = this:write_value(o, a, r[\"Values\"][a]);";
"      errors = errors + (\"Error\" in mapkeys(r[\"Values\"][a]));";
"    endfor";
"";
"    if (errors < 1)";
"      r = this:read_object(o);";
"    else";
"      r[\"Meta\"] = [\"id\" -> toint(o), \"status\" -> \"unknown\"];";
"      r[\"Error\"] = [\"diagnostic\" -> \"errors in sub-operations\"];";
"    endif";
"";
"    return r;";
"";
"  except (E_RANGE, E_TYPE)";
"    r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"    return r;";
"  except (E_PERM)";
"    r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];";
"    return r;";
"  endtry";
"else";
"  r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];";
"  return r;";
"endif";
"";
"chunk_length:146";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:2599BC910CE8865857727CC8C76455A1013330DC";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:8
{object, property} = args;
$private();
for parent in (parents(object))
this:_suspend_if_necessary();
if (ret = `property_info(parent, property) ! E_PROPNF')
return ret;
endif
endfor
return {};
return;
"{object, property} = args;";
"$private();";
"for parent in (parents(object))";
"  this:_suspend_if_necessary();";
"  if (ret = `property_info(parent, property) ! E_PROPNF')";
"    return ret;";
"  endif";
"endfor";
"return {};";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:6828227C67A26B9EB2F5086E7854A55943E5A2C5";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:9
{o} = args;
$private();
x = {};
for t in ({o, @ancestors(o)})
this:_suspend_if_necessary();
y = {};
for z in (properties(t))
this:_suspend_if_necessary();
y = {z, @y};
endfor
x = {@y, @x};
endfor
x = {"name", "owner", "location", "programmer", "wizard", "r", "w", "f", @x};
return x;
return;
"{o} = args;";
"$private();";
"x = {};";
"for t in ({o, @ancestors(o)})";
"  this:_suspend_if_necessary();";
"  y = {};";
"  for z in (properties(t))";
"    this:_suspend_if_necessary();";
"    y = {z, @y};";
"  endfor";
"  x = {@y, @x};";
"endfor";
"x = {\"name\", \"owner\", \"location\", \"programmer\", \"wizard\", \"r\", \"w\", \"f\", @x};";
"return x;";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:78C6751317BA2FCD27B13194182091EDF75588E2";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:10
{o} = args;
set_task_perms(caller_perms());
r = ["Values" -> {}];
for value in (this:_values(o))
this:_suspend_if_necessary();
r["Values"] = {@r["Values"], this:read_value(o, value)};
endfor
return r;
return;
"{o} = args;";
"set_task_perms(caller_perms());";
"r = [\"Values\" -> {}];";
"for value in (this:_values(o))";
"  this:_suspend_if_necessary();";
"  r[\"Values\"] = {@r[\"Values\"], this:read_value(o, value)};";
"endfor";
"return r;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:9AA9361F32A2726062ACD072432C55955CD1CAB1";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:11
{o, a, ?options = []} = args;
set_task_perms(caller_perms());
try
if (a == "location")
v = o.location;
p = this:_controls(caller_perms(), o) ? "rw" | "r";
elseif (a in {"owner", "programmer", "wizard"})
v = o.(a);
p = `caller_perms().wizard ! E_INVIND => 0' ? "rw" | "r";
elseif (a in {"r", "w", "f"})
v = o.(a);
p = this:_controls(caller_perms(), o) ? "rw" | "r";
elseif (a in {"name"})
v = o.(a);
p = (`caller_perms().wizard ! E_INVIND' || (this:_controls(caller_perms(), o) && (!is_player(o)))) ? "rw" | "r";
else
v = o.(a);
pi = property_info(o, a);
p = (index(pi[2], "w") || this:_controls_property(caller_perms(), o, a)) ? "rw" | "r";
c = is_clear_property(o, a);
endif
except (E_INVIND, E_PROPNF)
r = ["Meta" -> ["id" -> a, "status" -> "invalid"]];
return r;
except (E_PERM)
r = ["Meta" -> ["id" -> a, "status" -> "denied"]];
return r;
endtry
m = ["id" -> a];
m["status"] = index(p, "w") ? "writable" | "readable";
r = ["Meta" -> m, "Value" -> ["value" -> v]];
`r["Value"]["clear"] = c ! E_VARNF';
if (`pi ! E_VARNF')
if ((ppi = this:_parent_property_info(o, a)) && (ppi != pi))
r["Value"]["owner"] = pi[1];
r["Value"]["perms"] = pi[2];
endif
endif
return r;
return;
"{o, a, ?options = []} = args;";
"";
"set_task_perms(caller_perms());";
"";
"try";
"  if (a == \"location\")";
"    v = o.location;";
"    p = this:_controls(caller_perms(), o) ? \"rw\" | \"r\";";
"  elseif (a in {\"owner\", \"programmer\", \"wizard\"})";
"    v = o.(a);";
"    p = `caller_perms().wizard ! E_INVIND => 0' ? \"rw\" | \"r\";";
"  elseif (a in {\"r\", \"w\", \"f\"})";
"    v = o.(a);";
"    p = this:_controls(caller_perms(), o) ? \"rw\" | \"r\";";
"  elseif (a in {\"name\"})";
"    v = o.(a);";
"    p = `caller_perms().wizard ! E_INVIND' || (this:_controls(caller_perms(), o) && !is_player(o)) ? \"rw\" | \"r\";";
"  else";
"    v = o.(a);";
"    pi = property_info(o, a);";
"    p = index(pi[2], \"w\") || this:_controls_property(caller_perms(), o, a) ? \"rw\" | \"r\";";
"    c = is_clear_property(o, a);";
"  endif";
"except (E_INVIND, E_PROPNF)";
"  r = [\"Meta\" -> [\"id\" -> a, \"status\" -> \"invalid\"]];";
"  return r;";
"except (E_PERM)";
"  r = [\"Meta\" -> [\"id\" -> a, \"status\" -> \"denied\"]];";
"  return r;";
"endtry";
"m = [\"id\" -> a];";
"m[\"status\"] = index(p, \"w\") ? \"writable\" | \"readable\";";
"r = [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];";
"`r[\"Value\"][\"clear\"] = c ! E_VARNF'; /* `c' is not defined for built-in properties */";
"if (`pi ! E_VARNF')";
"  if ((ppi = this:_parent_property_info(o, a)) && ppi != pi)";
"    r[\"Value\"][\"owner\"] = pi[1];";
"    r[\"Value\"][\"perms\"] = pi[2];";
"  endif";
"endif";
"";
"return r;";
"";
"chunk_length:42";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:2E8CB4270CA662D0DF1515975B7B7F28232A5325";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:12
{o, a, r, ?options = []} = args;
set_task_perms(caller_perms());
mk = mapkeys(r);
if ((!("Meta" in mk)) && (!("Value" in mk)))
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
endif
old = this:read_value(o, a);
if (`old["Value"] ! E_RANGE' == `r["Value"] ! E_RANGE')
return old;
endif
try
mk = mapkeys(r["Value"]);
if (a in {"name", "owner", "location", "programmer", "wizard", "r", "w", "f"})
if ("clear" in mk)
r["Error"] = ["diagnostic" -> "clear is not applicable"];
return r;
endif
if ("owner" in mk)
r["Error"] = ["diagnostic" -> "owner is not applicable"];
return r;
endif
if ("perms" in mk)
r["Error"] = ["diagnostic" -> "perms is not applicable"];
return r;
endif
endif
c = `r["Value"]["clear"] ! E_RANGE';
if (c)
clear_property(o, a);
else
v = r["Value"]["value"];
if (a == "location")
(o.location != v) && move(o, v);
else
o.(a) = v;
endif
endif
if (("owner" in mk) || ("perms" in mk))
set_property_info(o, a, {`r["Value"]["owner"] ! E_RANGE => caller_perms()', r["Value"]["perms"]});
endif
except (E_RANGE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_INVIND)
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
except (E_PROPNF)
r["Error"] = ["diagnostic" -> "value is invalid"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
except (E_TYPE)
r["Error"] = ["diagnostic" -> "data type is invalid"];
return r;
except (E_NACC)
r["Error"] = ["diagnostic" -> "move refused by destination"];
return r;
except (E_RECMOVE)
r["Error"] = ["diagnostic" -> "recursive move"];
return r;
endtry
return this:read_value(o, a);
return;
"{o, a, r, ?options = []} = args;";
"";
"set_task_perms(caller_perms());";
"";
"/* My thinking is that a valid input will either have meta data";
" * (from a prior read) or a value.  If both are missing, this";
" * input is garbage of some sort.";
" */";
"mk = mapkeys(r);";
"if (!(\"Meta\" in mk) && !(\"Value\" in mk))";
"  r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"  return r;";
"endif";
"";
"old = this:read_value(o, a);";
"if (`old[\"Value\"] ! E_RANGE' == `r[\"Value\"] ! E_RANGE')";
"  return old;";
"endif";
"";
"try";
"  mk = mapkeys(r[\"Value\"]);";
"  if (a in {\"name\", \"owner\", \"location\", \"programmer\", \"wizard\", \"r\", \"w\", \"f\"})";
"    if (\"clear\" in mk)";
"      r[\"Error\"] = [\"diagnostic\" -> \"clear is not applicable\"];";
"      return r;";
"    endif";
"    if (\"owner\" in mk)";
"      r[\"Error\"] = [\"diagnostic\" -> \"owner is not applicable\"];";
"      return r;";
"    endif";
"    if (\"perms\" in mk)";
"      r[\"Error\"] = [\"diagnostic\" -> \"perms is not applicable\"];";
"      return r;";
"    endif";
"  endif";
"  c = `r[\"Value\"][\"clear\"] ! E_RANGE';";
"  if (c)";
"    clear_property(o, a);";
"  else";
"    v = r[\"Value\"][\"value\"];";
"    if (a == \"location\")";
"      o.location != v && move(o, v);";
"    else";
"      o.(a) = v;";
"    endif";
"  endif";
"  if (\"owner\" in mk || \"perms\" in mk)";
"    set_property_info(o, a, {`r[\"Value\"][\"owner\"] ! E_RANGE => caller_perms()', r[\"Value\"][\"perms\"]});";
"  endif";
"except (E_RANGE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"  return r;";
"except (E_INVIND)";
"  r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];";
"  return r;";
"except (E_PROPNF)";
"  r[\"Error\"] = [\"diagnostic\" -> \"value is invalid\"];";
"  return r;";
"except (E_PERM)";
"  r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];";
"  return r;";
"except (E_TYPE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"data type is invalid\"];";
"  return r;";
"except (E_NACC)";
"  r[\"Error\"] = [\"diagnostic\" -> \"move refused by destination\"];";
"  return r;";
"except (E_RECMOVE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"recursive move\"];";
"  return r;";
"endtry";
"";
"return this:read_value(o, a);";
"";
"chunk_length:73";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:CF452BA63F8E905475FC4C9A5F601EB8FE65FA1B";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:13
{o, r} = args;
$private();
set_task_perms(caller_perms());
try
v = r["Value"]["value"];
(parents(o) != v) && chparents(o, v);
except (E_RANGE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_INVARG)
r["Error"] = ["diagnostic" -> "argument is invalid"];
return r;
except (E_TYPE)
r["Error"] = ["diagnostic" -> "data type is invalid"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
endtry
v = parents(o);
m = ["id" -> "parents"];
m["status"] = this:_controls(caller_perms(), o) ? "writable" | "readable";
return ["Meta" -> m, "Value" -> ["value" -> v]];
return;
"{o, r} = args;";
"";
"$private();";
"";
"set_task_perms(caller_perms());";
"";
"try";
"  v = r[\"Value\"][\"value\"];";
"  parents(o) != v && chparents(o, v);";
"except (E_RANGE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"  return r;";
"except (E_INVARG)";
"  r[\"Error\"] = [\"diagnostic\" -> \"argument is invalid\"];";
"  return r;";
"except (E_TYPE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"data type is invalid\"];";
"  return r;";
"except (E_PERM)";
"  r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];";
"  return r;";
"endtry";
"v = parents(o);";
"m = [\"id\" -> \"parents\"];";
"m[\"status\"] = this:_controls(caller_perms(), o) ? \"writable\" | \"readable\";";
"";
"return [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];";
"";
"chunk_length:27";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:13295564FAFF9F44B09B6E7E1EBA217EACD36506";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:14
{o, r} = args;
$private();
set_task_perms(caller_perms());
try
v = r["Value"]["value"];
(is_player(o) != v) && set_player_flag(o, v);
except (E_RANGE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_INVARG)
r["Error"] = ["diagnostic" -> "argument is invalid"];
return r;
except (E_TYPE)
r["Error"] = ["diagnostic" -> "data type is invalid"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
endtry
v = is_player(o);
m = ["id" -> "player"];
m["status"] = `caller_perms().wizard ! E_INVIND' ? "writable" | "readable";
return ["Meta" -> m, "Value" -> ["value" -> v]];
return;
"{o, r} = args;";
"";
"$private();";
"";
"set_task_perms(caller_perms());";
"";
"try";
"  v = r[\"Value\"][\"value\"];";
"  is_player(o) != v && set_player_flag(o, v);";
"except (E_RANGE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"  return r;";
"except (E_INVARG)";
"  r[\"Error\"] = [\"diagnostic\" -> \"argument is invalid\"];";
"  return r;";
"except (E_TYPE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"data type is invalid\"];";
"  return r;";
"except (E_PERM)";
"  r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];";
"  return r;";
"endtry";
"v = is_player(o);";
"m = [\"id\" -> \"player\"];";
"m[\"status\"] = `caller_perms().wizard ! E_INVIND' ? \"writable\" | \"readable\";";
"";
"return [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];";
"";
"chunk_length:27";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:2F9B28A8C6CB72E794788386CBEC7597681A088E";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:15
{o, v, ?options = []} = args;
try
vx = verbs(o);
except (E_TYPE, E_INVARG)
r = ["Meta" -> ["id" -> o, "status" -> "invalid"]];
return r;
endtry
try
vn = vx[v];
except (E_TYPE, E_RANGE)
r = ["Meta" -> ["id" -> v, "status" -> "invalid"]];
return r;
endtry
set_task_perms(caller_perms());
try
vd = $verb_detail(o, v);
d = ["owner" -> vd["owner"], "perms" -> vd["perms"], "names" -> vd["names"], "dobj" -> vd["dobj"], "prep" -> vd["prep"], "iobj" -> vd["iobj"], "code" -> verb_code(o, v)];
`d["content_type"] = vd["content_type"] ! E_RANGE';
p = (index(d["perms"], "w") || this:_controls_verb(caller_perms(), o, v)) ? "rw" | "r";
except (E_TYPE, E_INVARG, E_VERBNF)
r = ["Meta" -> ["id" -> v, "status" -> "invalid"]];
return r;
except (E_PERM)
r = ["Meta" -> ["id" -> v, "status" -> "denied"]];
return r;
endtry
m = ["id" -> v];
m["status"] = index(p, "w") ? "writable" | "readable";
r = ["Meta" -> m, "Verb" -> d];
return r;
return;
"{o, v, ?options = []} = args;";
"";
"try";
"  vx = verbs(o);";
"except (E_TYPE, E_INVARG)";
"  r = [\"Meta\" -> [\"id\" -> o, \"status\" -> \"invalid\"]];";
"  return r;";
"endtry";
"try";
"  vn = vx[v];";
"except (E_TYPE, E_RANGE)";
"  r = [\"Meta\" -> [\"id\" -> v, \"status\" -> \"invalid\"]];";
"  return r;";
"endtry";
"";
"set_task_perms(caller_perms());";
"";
"try";
"  vd = $verb_detail(o, v);";
"  d = [\"owner\" -> vd[\"owner\"], \"perms\" -> vd[\"perms\"], \"names\" -> vd[\"names\"], \"dobj\" -> vd[\"dobj\"], \"prep\" -> vd[\"prep\"], \"iobj\" -> vd[\"iobj\"], \"code\" -> verb_code(o, v)];";
"  `d[\"content_type\"] = vd[\"content_type\"] ! E_RANGE';";
"  p = index(d[\"perms\"], \"w\") || this:_controls_verb(caller_perms(), o, v) ? \"rw\" | \"r\";";
"except (E_TYPE, E_INVARG, E_VERBNF)";
"  r = [\"Meta\" -> [\"id\" -> v, \"status\" -> \"invalid\"]];";
"  return r;";
"except (E_PERM)";
"  r = [\"Meta\" -> [\"id\" -> v, \"status\" -> \"denied\"]];";
"  return r;";
"endtry";
"m = [\"id\" -> v];";
"m[\"status\"] = index(p, \"w\") ? \"writable\" | \"readable\";";
"r = [\"Meta\" -> m, \"Verb\" -> d];";
"";
"return r;";
"";
"chunk_length:34";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:367EFEFF3C7E1489CF550095CC307D080EFB64A0";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:16
{o, v, r, ?options = []} = args;
error1 = error2 = 0;
try
vx = verbs(o);
except (E_TYPE, E_INVARG)
error1 = 1;
endtry
try
vn = vx[v];
except (E_VARNF)
except (E_TYPE, E_RANGE)
error2 = 1;
endtry
set_task_perms(caller_perms());
old = this:read_verb(o, v);
if (`old["Verb"] ! E_RANGE' == `r["Verb"] ! E_RANGE')
return old;
endif
if (error1)
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
elseif (error2)
r["Error"] = ["diagnostic" -> "verb is invalid"];
return r;
endif
try
r1 = r["Verb"];
set_verb_info(o, v, {`r1["owner"] ! E_RANGE => caller_perms()', r1["perms"], r1["names"]});
set_verb_args(o, v, {r1["dobj"], r1["prep"], r1["iobj"]});
vc = `r1["code"] ! E_RANGE => {}';
t = options;
`t["content_type"] = r1["content_type"] ! E_RANGE';
if (set_verb_code(o, v, vc, t))
r["Error"] = ["diagnostic" -> "compilation errors"];
return r;
endif
except (E_RANGE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_INVIND, E_INVARG)
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
except (E_TYPE)
r["Error"] = ["diagnostic" -> "data type is invalid"];
return r;
endtry
return this:read_verb(o, v);
return;
"{o, v, r, ?options = []} = args;";
"";
"/* measure, then drop perms, then take action if necessary */";
"";
"error1 = error2 = 0;";
"";
"try";
"  vx = verbs(o);";
"except (E_TYPE, E_INVARG)";
"  error1 = 1;";
"endtry";
"try";
"  vn = vx[v];";
"except (E_VARNF)";
"  /* vx is not defined because `verbs(o)' failed */";
"except (E_TYPE, E_RANGE)";
"  error2 = 1;";
"endtry";
"";
"set_task_perms(caller_perms());";
"";
"old = this:read_verb(o, v);";
"if (`old[\"Verb\"] ! E_RANGE' == `r[\"Verb\"] ! E_RANGE')";
"  return old;";
"endif";
"";
"if (error1)";
"  r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];";
"  return r;";
"elseif (error2)";
"  r[\"Error\"] = [\"diagnostic\" -> \"verb is invalid\"];";
"  return r;";
"endif";
"";
"try";
"  r1 = r[\"Verb\"];";
"";
"  set_verb_info(o, v, {`r1[\"owner\"] ! E_RANGE => caller_perms()', r1[\"perms\"], r1[\"names\"]});";
"  set_verb_args(o, v, {r1[\"dobj\"], r1[\"prep\"], r1[\"iobj\"]});";
"";
"  vc = `r1[\"code\"] ! E_RANGE => {}';";
"";
"  t = options;";
"  `t[\"content_type\"] = r1[\"content_type\"] ! E_RANGE';";
"  if (set_verb_code(o, v, vc, t))";
"    r[\"Error\"] = [\"diagnostic\" -> \"compilation errors\"];";
"    return r;";
"  endif";
"";
"except (E_RANGE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"  return r;";
"except (E_INVIND, E_INVARG)";
"  r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];";
"  return r;";
"except (E_PERM)";
"  r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];";
"  return r;";
"except (E_TYPE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"data type is invalid\"];";
"  return r;";
"endtry";
"";
"return this:read_verb(o, v);";
"";
"chunk_length:64";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:5A8575C934879C2B75E8CC91E6481163FA7C565F";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:17
{o, p, ?options = []} = args;
try
px = properties(o);
except (E_TYPE, E_INVARG)
r = ["Meta" -> ["id" -> o, "status" -> "invalid"]];
return r;
endtry
try
pn = px[p];
except (E_TYPE, E_RANGE)
r = ["Meta" -> ["id" -> p, "status" -> "invalid"]];
return r;
endtry
set_task_perms(caller_perms());
try
pi = property_info(o, pn);
pv = o.(pn);
s = (index(pi[2], "w") || this:_controls_property(caller_perms(), o, pn)) ? "rw" | "r";
except (E_TYPE, E_INVARG, E_PROPNF)
r = ["Meta" -> ["id" -> p, "status" -> "invalid"]];
return r;
except (E_PERM)
r = ["Meta" -> ["id" -> p, "status" -> "denied"]];
return r;
endtry
m = ["id" -> p];
m["status"] = index(s, "w") ? "writable" | "readable";
r = ["Meta" -> m, "Property" -> ["owner" -> pi[1], "perms" -> pi[2], "name" -> pn, "value" -> pv]];
return r;
return;
"{o, p, ?options = []} = args;";
"";
"try";
"  px = properties(o);";
"except (E_TYPE, E_INVARG)";
"  r = [\"Meta\" -> [\"id\" -> o, \"status\" -> \"invalid\"]];";
"  return r;";
"endtry";
"try";
"  pn = px[p];";
"except (E_TYPE, E_RANGE)";
"  r = [\"Meta\" -> [\"id\" -> p, \"status\" -> \"invalid\"]];";
"  return r;";
"endtry";
"";
"set_task_perms(caller_perms());";
"";
"try";
"  pi = property_info(o, pn);";
"  pv = o.(pn);";
"  s = index(pi[2], \"w\") || this:_controls_property(caller_perms(), o, pn) ? \"rw\" | \"r\";";
"except (E_TYPE, E_INVARG, E_PROPNF)";
"  r = [\"Meta\" -> [\"id\" -> p, \"status\" -> \"invalid\"]];";
"  return r;";
"except (E_PERM)";
"  r = [\"Meta\" -> [\"id\" -> p, \"status\" -> \"denied\"]];";
"  return r;";
"endtry";
"m = [\"id\" -> p];";
"m[\"status\"] = index(s, \"w\") ? \"writable\" | \"readable\";";
"r = [\"Meta\" -> m, \"Property\" -> [\"owner\" -> pi[1], \"perms\" -> pi[2], \"name\" -> pn, \"value\" -> pv]];";
"";
"return r;";
"";
"chunk_length:33";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:A68B9AEA6EB6F822FAFF6105D1A109B9F99D6025";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:18
{o, p, r, ?options = []} = args;
error1 = error2 = 0;
try
px = properties(o);
except (E_TYPE, E_INVARG)
error1 = 1;
endtry
try
pn = px[p];
except (E_VARNF)
except (E_TYPE, E_RANGE)
error2 = 1;
endtry
set_task_perms(caller_perms());
old = this:read_property(o, p);
if (`old["Property"] ! E_RANGE' == `r["Property"] ! E_RANGE')
return old;
endif
if (error1)
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
elseif (error2)
r["Error"] = ["diagnostic" -> "property is invalid"];
return r;
endif
try
r1 = r["Property"];
set_property_info(o, pn, {`r1["owner"] ! E_RANGE => caller_perms()', r1["perms"], r1["name"]});
o.(r1["name"]) = r1["value"];
except (E_RANGE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_INVIND, E_INVARG)
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
except (E_TYPE)
r["Error"] = ["diagnostic" -> "data type is invalid"];
return r;
endtry
return this:read_property(o, p);
return;
"{o, p, r, ?options = []} = args;";
"";
"/* measure, then drop perms, then take action if necessary */";
"";
"error1 = error2 = 0;";
"";
"try";
"  px = properties(o);";
"except (E_TYPE, E_INVARG)";
"  error1 = 1;";
"endtry";
"try";
"  pn = px[p];";
"except (E_VARNF)";
"  /* px is not defined because `properties(o)' failed */";
"except (E_TYPE, E_RANGE)";
"  error2 = 1;";
"endtry";
"";
"set_task_perms(caller_perms());";
"";
"old = this:read_property(o, p);";
"if (`old[\"Property\"] ! E_RANGE' == `r[\"Property\"] ! E_RANGE')";
"  return old;";
"endif";
"";
"if (error1)";
"  r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];";
"  return r;";
"elseif (error2)";
"  r[\"Error\"] = [\"diagnostic\" -> \"property is invalid\"];";
"  return r;";
"endif";
"";
"try";
"  r1 = r[\"Property\"];";
"";
"  set_property_info(o, pn, {`r1[\"owner\"] ! E_RANGE => caller_perms()', r1[\"perms\"], r1[\"name\"]});";
"  o.(r1[\"name\"]) = r1[\"value\"];";
"";
"except (E_RANGE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"  return r;";
"except (E_INVIND, E_INVARG)";
"  r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];";
"  return r;";
"except (E_PERM)";
"  r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];";
"  return r;";
"except (E_TYPE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"data type is invalid\"];";
"  return r;";
"endtry";
"";
"return this:read_property(o, p);";
"";
"chunk_length:55";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:D78DD21D8FA7CEC926AF6779C32C69E66E7F2311";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:19
{?parents = {}} = args;
o = ["Attributes" -> [], "Values" -> [], "Properties" -> {}, "Verbs" -> {}];
if (parents)
o["Attributes"]["parents"] = ["Value" -> ["value" -> parents]];
endif
return o;
return;
"{?parents = {}} = args;";
"o = [\"Attributes\" -> [], \"Values\" -> [], \"Properties\" -> {}, \"Verbs\" -> {}];";
"if (parents)";
"  o[\"Attributes\"][\"parents\"] = [\"Value\" -> [\"value\" -> parents]];";
"endif";
"return o;";
"";
"chunk_length:6";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:9969B59DEBF0F2BC6F62679AF94EBE480E3A6B38";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:20
{t, n, v} = args;
t["Values"][n] = ["Value" -> ["value" -> v]];
return t;
return;
"{t, n, v} = args;";
"";
"t[\"Values\"][n] = [\"Value\" -> [\"value\" -> v]];";
"";
"return t;";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:6B7C622565FB5DA32263B609A8125AB3BCF3F229";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:21
{t, pn, pv, pi} = args;
p = ["Property" -> ["owner" -> pi[1], "perms" -> pi[2], "name" -> pn, "value" -> pv]];
t["Properties"] = {@t["Properties"], p};
return t;
return;
"{t, pn, pv, pi} = args;";
"";
"p = [\"Property\" -> [\"owner\" -> pi[1], \"perms\" -> pi[2], \"name\" -> pn, \"value\" -> pv]];";
"";
"t[\"Properties\"] = {@t[\"Properties\"], p};";
"";
"return t;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:4EA890888B90932C61B555A4FF4158BEDB2B945E";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:22
{t, vi, va, ?vc = {}} = args;
v = ["Verb" -> ["owner" -> vi[1], "perms" -> vi[2], "names" -> vi[3], "dobj" -> va[1], "prep" -> va[2], "iobj" -> va[3], "code" -> vc]];
t["Verbs"] = {@t["Verbs"], v};
return t;
return;
"{t, vi, va, ?vc = {}} = args;";
"";
"v = [\"Verb\" -> [\"owner\" -> vi[1], \"perms\" -> vi[2], \"names\" -> vi[3], \"dobj\" -> va[1], \"prep\" -> va[2], \"iobj\" -> va[3], \"code\" -> vc]];";
"";
"t[\"Verbs\"] = {@t[\"Verbs\"], v};";
"";
"return t;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:8A4B8E29A09479CE3DED7B5855A8AEA121411BCB";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:0
$private();
notify(player, tostr(@args));
.
#9:1
{what, where} = args;
$private();
`move(what, where) ! ANY';
.
#9:2
((ticks_left() < 5000) || (seconds_left() < 2)) && suspend(0);
.
#9:3
{specifier} = args;
$private();
if (r = match(specifier, "^%([0-9]+%.[0-9]+%.[0-9]+%),%([_a-zA-Z0-9]+%)$"))
version = specifier[r[3][1][1]..r[3][1][2]];
identifier = specifier[r[3][2][1]..r[3][2][2]];
return {identifier, version};
else
raise(E_INVARG, tostr("Invalid package specifier:  ", specifier));
endif
.
#9:4
{operation} = args;
$private();
if (r = match(operation, "^%(<=%|>=%|<%|>%|=%)? *%([0-9]+%)?%(%.%([0-9]+%)%)?%(%.%([0-9]+%)%)?$"))
op = operation[r[3][1][1]..r[3][1][2]] || "=";
major = operation[r[3][2][1]..r[3][2][2]];
minor = operation[r[3][4][1]..r[3][4][2]];
build = operation[r[3][6][1]..r[3][6][2]];
return {op, major, minor, build};
else
raise(E_INVARG, tostr("Invalid operation:  ", operation));
endif
.
#9:5
{version} = args;
$private();
if (r = match(version, "^%([0-9]+%)%(%.%([0-9]+%)%)%(%.%([0-9]+%)%)$"))
major = version[r[3][1][1]..r[3][1][2]];
minor = version[r[3][3][1]..r[3][3][2]];
build = version[r[3][5][1]..r[3][5][2]];
return {major, minor, build};
else
raise(E_INVARG, tostr("Invalid version:  ", version));
endif
.
#9:6
{ver1, ver2} = args;
$private();
res = 0;
if (ver1[1] && ver2[1])
if (((!(res = toint(ver1[1]) - toint(ver2[1]))) && ver1[2]) && ver2[2])
if (((!(res = toint(ver1[2]) - toint(ver2[2]))) && ver1[3]) && ver2[3])
res = toint(ver1[3]) - toint(ver2[3]);
endif
endif
endif
return res;
.
#9:7
{vers} = args;
$private();
l = length(vers);
i = 1;
while (i <= l)
v = vers[i];
j = i - 1;
while (j > 0)
if (this:_compare_versions(vers[j], v) >= 0)
break;
endif
vers[j + 1] = vers[j];
j = j - 1;
endwhile
vers[j + 1] = v;
i = i + 1;
endwhile
return vers;
.
#9:8
{identifier, @args} = args;
if (args && (typeof(args[$]) == MAP))
patterns = args[1..$ - 1];
provides = args[$];
else
patterns = args;
provides = this.provides_cache;
endif
if ((patterns && (length(patterns) == 1)) && (typeof(patterns[1]) == LIST))
patterns = patterns[1];
endif
if ((versions = `provides[identifier] ! E_RANGE => $nothing') == $nothing)
return {$failed_match};
endif
operations = {};
for pattern in (patterns)
this:_suspend_if_necessary();
operations = {@operations, this:_parse_operation(pattern)};
endfor
for _, version in (versions)
this:_suspend_if_necessary();
v1 = this:_parse_version(version);
for operation in (operations)
this:_suspend_if_necessary();
{op, @v2} = operation;
if (((((("=" == op) && this:_compare_versions(v1, v2)) || ((">=" == op) && (this:_compare_versions(v1, v2) < 0))) || (("<=" == op) && (this:_compare_versions(v1, v2) > 0))) || ((">" == op) && (this:_compare_versions(v1, v2) <= 0))) || (("<" == op) && (this:_compare_versions(v1, v2) >= 0)))
versions = mapdelete(versions, version);
break;
endif
endfor
endfor
if (length(versions) < 1)
return {$failed_match};
elseif (length(versions) > 1)
return {$ambiguous_match};
else
version = mapkeys(versions)[1];
object = mapvalues(versions)[1][1];
return {object, identifier, version};
endif
.
#9:9
{MAP, specifier, object} = args;
$private();
if (typeof(specifier) == LIST)
{identifier, version} = specifier;
else
{identifier, version} = this:_parse_specifier(specifier);
endif
(identifier in mapkeys(MAP)) || (MAP[identifier] = []);
(version in mapkeys(MAP[identifier])) || (MAP[identifier][version] = {});
MAP[identifier][version] = setadd(MAP[identifier][version], object);
return MAP;
.
#9:10
{MAP, specifier, object} = args;
$private();
if (typeof(specifier) == LIST)
{identifier, version} = specifier;
else
{identifier, version} = this:_parse_specifier(specifier);
endif
((identifier in mapkeys(MAP)) && (version in mapkeys(MAP[identifier]))) && (MAP[identifier][version] = setremove(MAP[identifier][version], object));
`MAP[identifier][version] ! E_RANGE => 1' || (MAP[identifier] = mapdelete(MAP[identifier], version));
`MAP[identifier] ! E_RANGE => 1' || (MAP = mapdelete(MAP, identifier));
return MAP;
.
#9:11
{identifier, version, object} = args;
$private();
this.packages = setadd(this.packages, object);
this.provides_cache = this:_map_specifier(this.provides_cache, {identifier, version}, object);
for provides in (`object.provides ! E_INVIND, E_TYPE, E_PROPNF => {}')
this.provides_cache = this:_map_specifier(this.provides_cache, provides, object);
endfor
for requires in (`object.requires ! E_INVIND, E_TYPE, E_PROPNF => {}')
provider = this:_match(@requires, this.provides_cache);
this.requires_cache = this:_map_specifier(this.requires_cache, provider[2..3], object);
endfor
.
#9:12
{identifier, version, object} = args;
$private();
this.packages = setremove(this.packages, object);
this.provides_cache = this:_unmap_specifier(this.provides_cache, {identifier, version}, object);
for provides in (`object.provides ! E_INVIND, E_TYPE, E_PROPNF => {}')
this.provides_cache = this:_unmap_specifier(this.provides_cache, provides, object);
endfor
for requires in (`object.requires ! E_INVIND, E_TYPE, E_PROPNF => {}')
provider = this:_find_requires_provider(requires[1], object);
this.requires_cache = this:_unmap_specifier(this.requires_cache, provider[2..3], object);
endfor
.
#9:13
{identifier, object} = args;
$private();
for _, version in (this.requires_cache[identifier])
if (object in this.requires_cache[identifier][version])
return {this.provides_cache[identifier][version][1], identifier, version};
endif
endfor
.
#9:14
objects = (args && (typeof(args[1]) == LIST)) ? args[1] | args;
$permit("wizard");
this.packages = {};
this.provides_cache = [];
this.requires_cache = [];
for object in (objects)
this:_install(object.identifier, object.version, object);
endfor
.
#9:15
{required} = args;
$private();
for selector in (required)
object = this:_match(@selector, this.provides_cache)[1];
if (valid(object))
required = setremove(required, selector);
endif
endfor
return required;
.
#9:16
{provided} = args;
$private();
for package in (provided)
{identifier, version} = package;
object = `this.requires_cache[identifier][version][1] ! E_RANGE => $failed_match';
if (!valid(object))
provided = setremove(provided, package);
endif
endfor
return provided;
.
#9:17
{specifiers} = args;
$private();
global = [];
for specifier in (specifiers)
this:_suspend_if_necessary();
{package, ?identifier, ?version} = this:_match(@specifier, this.provides_cache);
if ($failed_match == package)
raise(E_INVARG, tostr("Failed match:  ", toliteral(specifier)));
elseif ($ambiguous_match == package)
raise(E_INVARG, tostr("Ambiguous match:  ", toliteral(specifier)));
endif
for item in (`package.manifest ! E_PROPNF => {}')
{object, label} = item;
global[object] = tostr(label, "|", identifier);
endfor
endfor
global[$nothing] = "__nothing__";
return global;
.
#9:18
{specifiers} = args;
$private();
global = [];
for specifier in (specifiers)
this:_suspend_if_necessary();
{package, ?identifier, ?version} = this:_match(@specifier, this.provides_cache);
if ($failed_match == package)
raise(E_INVARG, tostr("Failed match:  ", toliteral(specifier)));
elseif ($ambiguous_match == package)
raise(E_INVARG, tostr("Ambiguous match:  ", toliteral(specifier)));
endif
for item in (`package.manifest ! E_PROPNF => {}')
{object, label} = item;
global[tostr(label, "|", identifier)] = object;
endfor
endfor
global["__nothing__"] = $nothing;
return global;
.
#9:19
{verb, LIST, @options} = args;
$private();
for i in [1..length(LIST)]
this:_suspend_if_necessary();
LIST[i] = this:(verb)(LIST[i], @options);
endfor
return LIST;
.
#9:20
{object, global, local, package, ?target = ""} = args;
$private();
if (typeof(object) == LIST)
return this:_map(verb, @args);
endif
if (`ret = local[object] ! E_RANGE' != E_RANGE)
return ret;
elseif (`ret = global[object] ! E_RANGE' != E_RANGE)
return ret;
elseif (`object.wizard ! E_INVIND')
return "__wizard__";
elseif (object == caller_perms())
return "__owner__";
elseif (object == package)
return "__package__";
endif
if (target)
raise(E_INVARG, tostr("Lookup failed for:  ", object, " on ", target));
else
raise(E_INVARG, tostr("Lookup failed for:  ", object));
endif
.
#9:21
{label, global, local, package} = args;
$private();
if (typeof(label) == LIST)
return this:_map(verb, @args);
endif
if ("__nothing__" == label)
return global["__nothing__"];
elseif ("__wizard__" == label)
return caller_perms();
elseif ("__owner__" == label)
return caller_perms();
elseif ("__package__" == label)
return package;
elseif (r = match(label, "^%([a-z_][a-z0-9_]*%)%(|%([a-z][a-z0-9_]*%)%)?$"))
reference = label[r[3][1][1]..r[3][1][2]];
identifier = label[r[3][3][1]..r[3][3][2]];
try
if (reference && identifier)
return global[label];
else
return local[label];
endif
except (E_RANGE)
endtry
endif
raise(E_INVARG, tostr("Lookup failed for:  ", toliteral(label)));
.
#9:22
{subject, target, MAP} = args;
$private();
keys = mapkeys(MAP);
stack = {target};
while (stack)
this:_suspend_if_necessary();
{target, @stack} = stack;
if (target in keys)
parents = `MAP[target]["Attributes"]["parents"]["Value"]["value"] ! E_RANGE => "__nothing__"';
if (typeof(parents) == LIST)
if (subject in parents)
return 1;
else
stack = {@parents, @stack};
endif
else
if (subject == parents)
return 1;
else
stack = {parents, @stack};
endif
endif
endif
endwhile
return 0;
.
#9:23
{object} = args;
$private();
objects = {};
if (valid(object))
stack = {object};
while (stack)
top = stack[1];
stack = {@top.contents, @stack[2..$]};
objects = {@objects, top};
endwhile
endif
return objects;
.
#9:24
$permit("wizard");
`{package, @options} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  package, @options")';
if (options)
if (typeof(options[1]) != MAP)
{?identifier, ?version, ?options = []} = options;
else
options = options[1];
endif
endif
try
identifier;
version;
except (E_VARNF)
identifier = package.identifier;
version = package.version;
endtry
(!valid(package.location)) || raise(E_INVARG, "Not in $nothing");
(package in this.packages) && raise(E_INVARG, "Package is already installed");
provides = `package.provides ! E_PROPNF => {}';
provides = {{identifier, version}, @provides};
for p in (provides)
{id, v} = p;
valid(this:_match(id, v)[1]) && raise(E_INVARG, tostr("Package is already installed:  identifier = ", id, ", version = ", v));
endfor
requires = `package.requires ! E_PROPNF => {}';
(requires = this:_check_required_provides(requires)) && raise(E_INVARG, tostr("Package requires:  ", toliteral(requires)));
errors = [];
if (respond_to(package, "before_install"))
try
package:before_install();
except ex (ANY)
errors["before_install"] = ex;
endtry
endif
if (`options["follow-instructions"] ! ANY')
this:_do_instructions(identifier, version, package);
endif
this:_install(identifier, version, package);
if (respond_to(package, "after_install"))
try
package:after_install();
except ex (ANY)
errors["after_install"] = ex;
endtry
endif
return errors || 0;
.
#9:25
$permit("wizard");
`{identifier, version, ?options = []} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  identifier, version, ?options")';
valid(object = this:_match(identifier, version)[1]) || raise(E_INVARG, tostr("Package is not installed:  identifier = ", identifier, ", version = ", version));
provides = `object.provides ! E_PROPNF => {}';
provides = {{identifier, version}, @provides};
(provides = this:_check_provided_requires(provides)) && raise(E_INVARG, tostr("Package provides:  ", toliteral(provides)));
errors = [];
if (respond_to(object, "before_uninstall"))
try
object:before_uninstall();
except ex (ANY)
errors["before_uninstall"] = ex;
endtry
endif
if (`options["follow-instructions"] ! ANY')
this:_undo_instructions(identifier, version, object);
endif
this:_uninstall(identifier, version, object);
if (respond_to(object, "after_uninstall"))
try
object:after_uninstall();
except ex (ANY)
errors["after_uninstall"] = ex;
endtry
endif
return errors || 0;
.
#9:26
args || raise(E_ARGS);
packages = this.packages;
set_task_perms(caller_perms());
if (typeof(args[1]) == OBJ)
{object, ?options = []} = args;
identifier = version = "";
else
{identifier, version, ?options = []} = args;
object = this:_match(identifier, version)[1];
(object == $failed_match) && raise(E_INVARG, tostr("Package is not installed:  identifier = ", identifier, ", version = ", version));
endif
(object == $lookup("__package__")) && raise(E_INVARG, tostr("Can't delete privileged package:  identifier = ", object.identifier, ", version = ", object.version));
p = caller_perms();
while (valid(p))
(p == object) && raise(E_INVARG, tostr(caller_perms(), " is/is inside of ", object));
p = p.location;
endwhile
errors = [];
if (object in packages)
identifier = identifier || object.identifier;
version = version || object.version;
provides = {{identifier, version}};
(provides = this:_check_provided_requires(provides)) && raise(E_INVARG, tostr("Package provides:  ", toliteral(provides)));
if (valid(object) && respond_to(object, "before_uninstall"))
try
object:before_uninstall();
except ex (ANY)
errors["before_uninstall"] = ex;
endtry
endif
if (`options["follow-instructions"] ! ANY')
this:_undo_instructions(identifier, version, object);
endif
this:_uninstall(identifier, version, object);
if (valid(object) && respond_to(object, "after_uninstall"))
try
object:after_uninstall();
except ex (ANY)
errors["after_uninstall"] = ex;
endtry
endif
endif
if (valid(object))
for item in (this:_contents(object))
`recycle(item) ! ANY => 0';
endfor
endif
return errors || 0;
.
#9:27
$private();
bg_seconds = $server_options.bg_seconds;
bg_ticks = $server_options.bg_ticks;
$server_options.bg_seconds = 60 * 60;
$server_options.bg_ticks = (1024 * 1024) * 1024;
suspend(0);
return {bg_seconds, bg_ticks};
.
#9:28
$private();
{args} = args;
{bg_seconds, bg_ticks} = args;
$server_options.bg_seconds = bg_seconds;
$server_options.bg_ticks = bg_ticks;
.
#9:29
{package} = args;
set_task_perms(caller_perms());
try
configuration = package["Configuration"];
version = configuration["version"];
top = configuration["top"];
objects = package["Objects"];
objects[top];
except ex (E_TYPE, E_RANGE)
raise(E_INVARG, "Incompatible package format");
endtry
(version == "0.1") || raise(E_INVARG, "Unsupported package version");
requires = `objects[top]["Values"]["requires"]["Value"]["value"] ! E_RANGE => {}';
manifest = `objects[top]["Values"]["manifest"]["Value"]["value"] ! E_RANGE => {}';
relocate = `objects[top]["Values"]["relocate"]["Value"]["value"] ! E_RANGE => {}';
(missing = this:_check_required_provides(requires)) && raise(E_INVARG, tostr("Package requires:  ", toliteral(missing)));
global = this:_generate_global_mapping_keyed_on_identifier(requires);
labels = {};
mapkeys_objects = mapkeys(objects);
for label in (manifest)
(label in mapkeys_objects) || raise(E_INVARG, tostr("Invalid value in `manifest':  ", label));
labels = setadd(labels, label);
endfor
for label in (mapkeys_objects)
labels = setadd(labels, label);
endfor
unsorted = labels;
labels = {};
for label in (unsorted)
i = 1;
for target in (labels)
if (this:_is_ancestor(label, target, objects))
break;
endif
i = i + 1;
endfor
labels = {@labels[1..i - 1], label, @labels[i..$]};
endfor
success = 0;
try
local = [];
locations = [];
local[top] = create($nothing);
for label in (setremove(labels, top))
this:_suspend_if_necessary();
local[label] = create($nothing);
this:_move(local[label], local[top]);
endfor
relocate_map = [];
for reference in (relocate)
this:_suspend_if_necessary();
if (r = match(reference, "^%([a-z_][a-z0-9_]*%)%.%([a-z_][a-z0-9_]*%)$"))
r1 = reference[r[3][1][1]..r[3][1][2]];
r2 = reference[r[3][2][1]..r[3][2][2]];
if (!(r2 in {"owner", "parents", "location"}))
(r1 in mapkeys(relocate_map)) || (relocate_map[r1] = {});
relocate_map[r1] = {@relocate_map[r1], r2};
endif
else
raise(E_INVARG, tostr("Invalid reference in `relocate':  ", reference));
endif
endfor
for label in (labels)
this:_suspend_if_necessary();
object = local[label];
definition = objects[label];
if (`definition["Values"]["owner"] ! E_RANGE' != E_RANGE)
if (caller_perms().wizard)
definition["Values"]["owner"]["Value"]["value"] = this:_lookup_by_label(definition["Values"]["owner"]["Value"]["value"], global, local, local[top]);
else
definition["Values"] = mapdelete(definition["Values"], "owner");
endif
endif
if (`definition["Attributes"]["parents"] ! E_RANGE' != E_RANGE)
definition["Attributes"]["parents"]["Value"]["value"] = this:_lookup_by_label(definition["Attributes"]["parents"]["Value"]["value"], global, local, local[top]);
endif
if (`definition["Values"]["location"] ! E_RANGE' != E_RANGE)
locations[label] = definition["Values"]["location"]["Value"]["value"];
definition["Values"] = mapdelete(definition["Values"], "location");
endif
if (`relocate_map[label] ! E_RANGE => 0')
for name in (relocate_map[label])
this:_suspend_if_necessary();
if (`definition["Values"][name]["Value"]["value"] ! E_RANGE => 0')
definition["Values"][name]["Value"]["value"] = this:_lookup_by_label(definition["Values"][name]["Value"]["value"], global, local, local[top]);
else
for property in (definition["Properties"])
this:_suspend_if_necessary();
if (property["Property"]["name"] == name)
value = this:_lookup_by_label(property["Property"]["value"], global, local, local[top]);
definition["Values"][name] = ["Value" -> ["value" -> value]];
endif
endfor
endif
endfor
endif
for _, value in (definition["Values"])
this:_suspend_if_necessary();
if (`definition["Values"][value]["Value"]["owner"] ! E_RANGE' != E_RANGE)
if (caller_perms().wizard)
definition["Values"][value]["Value"]["owner"] = this:_lookup_by_label(definition["Values"][value]["Value"]["owner"], global, local, local[top]);
else
definition["Values"][value]["Value"] = mapdelete(definition["Values"][value]["Value"], "owner");
endif
endif
endfor
for index in [1..length(definition["Verbs"])]
this:_suspend_if_necessary();
if (`definition["Verbs"][index]["Verb"]["owner"] ! E_RANGE' != E_RANGE)
if (caller_perms().wizard)
definition["Verbs"][index]["Verb"]["owner"] = this:_lookup_by_label(definition["Verbs"][index]["Verb"]["owner"], global, local, local[top]);
else
definition["Verbs"][index]["Verb"] = mapdelete(definition["Verbs"][index]["Verb"], "owner");
endif
endif
endfor
for index in [1..length(definition["Properties"])]
this:_suspend_if_necessary();
if (`definition["Properties"][index]["Property"]["owner"] ! E_RANGE' != E_RANGE)
if (caller_perms().wizard)
definition["Properties"][index]["Property"]["owner"] = this:_lookup_by_label(definition["Properties"][index]["Property"]["owner"], global, local, local[top]);
else
definition["Properties"][index]["Property"] = mapdelete(definition["Properties"][index]["Property"], "owner");
endif
endif
endfor
definition = $shapes:write_object(object, definition, ["verbs" -> ["do-not-version" -> 1, "do-not-stamp" -> 1]]);
objects[label] = definition;
package["Objects"] = objects;
endfor
for label in (labels)
this:_suspend_if_necessary();
if ("Error" in mapkeys(package["Objects"][label]))
raise("E_PACKAGE", "Error in package operation", package);
endif
endfor
for label in (labels)
this:_suspend_if_necessary();
if (label != top)
object = local[label];
value = `locations[label] ! E_RANGE => "__package__"';
value = (value == "__package__") ? local[top] | local[value];
this:_move(object, value);
endif
endfor
for entry in [1..`length(local[top].manifest) ! E_PROPNF => 0']
this:_suspend_if_necessary();
local[top].manifest[entry] = {local[local[top].manifest[entry]], local[top].manifest[entry]};
endfor
success = 1;
finally
success || this:delete(local[top]);
endtry
return local[top];
.
#9:30
{package, ?options = []} = args;
set_task_perms(caller_perms());
strip = `options["strip"] ! E_RANGE => {}';
truncate = `options["truncate"] ! E_RANGE => {}';
`valid(package) ! E_TYPE => 0' || raise(E_INVARG, "Not a valid package");
(!valid(package.location)) || raise(E_INVARG, "Not a valid package:  must not have a location");
requires = `package.requires ! E_PROPNF => {}';
manifest = `package.manifest ! E_PROPNF => {}';
relocate = `package.relocate ! E_PROPNF => {}';
objects = this:_contents(package);
definition = ["Configuration" -> ["Version" -> "0.1"], "Objects" -> []];
(missing = this:_check_required_provides(requires)) && raise(E_INVARG, tostr("Package requires:  ", toliteral(missing)));
global = this:_generate_global_mapping_keyed_on_object_number(requires);
for key in (`mapkeys(options["global"]) ! E_RANGE => {}')
this:_suspend_if_necessary();
global[key] = options["global"][key];
endfor
local = [];
for object in (objects)
this:_suspend_if_necessary();
label = tostr("__", toint(object), "__");
if (object == package)
label = "__package__";
endif
for entry in (manifest)
if (entry[1] == object)
label = entry[2];
break;
endif
endfor
local[object] = label;
definition["Objects"][label] = $shapes:read_object(object);
if (object in strip)
values = [];
for name in ({"name", "owner", "location", "programmer", "wizard", "r", "w", "f"})
values[name] = definition["Objects"][label]["Values"][name];
endfor
for index in [1..length(definition["Objects"][label]["Properties"])]
name = definition["Objects"][label]["Properties"][index]["property"]["name"];
values[name] = definition["Objects"][label]["Values"][name];
endfor
definition["Objects"][label]["Values"] = values;
endif
endfor
top = definition["Configuration"]["top"] = local[package];
labels = {};
for entry in (manifest)
this:_suspend_if_necessary();
labels = {@labels, entry[2]};
endfor
for object in (objects)
this:_suspend_if_necessary();
label = local[object];
for _, v in (definition["Objects"][label]["Values"])
this:_suspend_if_necessary();
if (`"owner" in mapkeys(definition["Objects"][label]["Values"][v]["Value"]) ! E_RANGE')
definition["Objects"][label]["Values"][v]["Value"]["owner"] = this:_lookup_by_object_number(definition["Objects"][label]["Values"][v]["Value"]["owner"], global, local, package, label);
endif
endfor
for i in [1..length(definition["Objects"][label]["Properties"])]
this:_suspend_if_necessary();
definition["Objects"][label]["Properties"][i]["Property"]["owner"] = this:_lookup_by_object_number(definition["Objects"][label]["Properties"][i]["Property"]["owner"], global, local, package, label);
endfor
for i in [1..length(definition["Objects"][label]["Verbs"])]
this:_suspend_if_necessary();
definition["Objects"][label]["Verbs"][i]["Verb"]["owner"] = this:_lookup_by_object_number(definition["Objects"][label]["Verbs"][i]["Verb"]["owner"], global, local, package, label);
endfor
if ("owner" in mapkeys(definition["Objects"][label]["Values"]))
definition["Objects"][label]["Values"]["owner"]["Value"]["value"] = this:_lookup_by_object_number(definition["Objects"][label]["Values"]["owner"]["Value"]["value"], global, local, package, label);
endif
definition["Objects"][label]["Attributes"]["parents"]["Value"]["value"] = this:_lookup_by_object_number(definition["Objects"][label]["Attributes"]["parents"]["Value"]["value"], global, local, package, label);
definition["Objects"][label]["Values"]["location"]["Value"]["value"] = this:_lookup_by_object_number(definition["Objects"][label]["Values"]["location"]["Value"]["value"], global, local, package, label);
endfor
for reference in (relocate)
this:_suspend_if_necessary();
if (r = match(reference, "^%([a-z_][a-z0-9_]*%)%.%([a-z_][a-z0-9_]*%)$"))
r1 = reference[r[3][1][1]..r[3][1][2]];
r2 = reference[r[3][2][1]..r[3][2][2]];
if (r1 in labels)
if (((r2 != "parents") && (r2 != "location")) && (r2 != "owner"))
try
definition["Objects"][r1]["Values"][r2]["Value"]["value"];
except (E_RANGE)
raise(E_INVARG, tostr("Invalid reference in `relocate':  \"", r2, "\" in \"", reference, "\""));
endtry
definition["Objects"][r1]["Values"][r2]["Value"]["value"] = this:_lookup_by_object_number(definition["Objects"][r1]["Values"][r2]["Value"]["value"], global, local, package, r1);
for property in [1..length(definition["Objects"][r1]["Properties"])]
this:_suspend_if_necessary();
if (definition["Objects"][r1]["Properties"][property]["Property"]["name"] == r2)
definition["Objects"][r1]["Properties"][property]["Property"]["value"] = definition["Objects"][r1]["Values"][r2]["Value"]["value"];
break property;
endif
endfor
endif
else
raise(E_INVARG, tostr("Invalid reference in `relocate':  \"", r1, "\" in \"", reference, "\""));
endif
else
raise(E_INVARG, tostr("Invalid reference in `relocate':  ", reference));
endif
endfor
for object in (truncate)
this:_suspend_if_necessary();
if (object in objects)
label = local[object];
values = [];
for _, value in (definition["Objects"][label]["Values"])
this:_suspend_if_necessary();
if (value in {"name", "owner", "location", "programmer", "wizard", "r", "w", "f"})
values[value] = definition["Objects"][label]["Values"][value];
endif
endfor
definition["Objects"][label]["Values"] = values;
endif
endfor
if ("manifest" in mapkeys(definition["Objects"][top]["Values"]))
for entry in [1..length(definition["Objects"][top]["Values"]["manifest"]["Value"]["value"])]
this:_suspend_if_necessary();
definition["Objects"][top]["Values"]["manifest"]["Value"]["value"][entry] = definition["Objects"][top]["Values"]["manifest"]["Value"]["value"][entry][2];
endfor
endif
for property in [1..length(definition["Objects"][top]["Properties"])]
this:_suspend_if_necessary();
if (definition["Objects"][top]["Properties"][property]["Property"]["name"] == "manifest")
for entry in [1..length(definition["Objects"][top]["Properties"][property]["Property"]["value"])]
this:_suspend_if_necessary();
definition["Objects"][top]["Properties"][property]["Property"]["value"][entry] = definition["Objects"][top]["Properties"][property]["Property"]["value"][entry][2];
endfor
break;
endif
endfor
return definition;
.
#9:31
$private();
{host, port, uri} = args;
cnct = 0;
try
try
cnct = open_network_connection(host, port);
except (E_INVARG)
raise(E_INVARG, "Open network connection failed");
endtry
set_connection_option(cnct, "hold-input", 1);
set_connection_option(cnct, "binary", 1);
notify(cnct, tostr("GET ", strsub(uri, "~", "~7E"), " HTTP/1.1~0D~0A"));
notify(cnct, (port != 80) ? tostr("Host: ", host, ":", port, "~0D~0A") | tostr("Host: ", host, "~0D~0A"));
notify(cnct, "~0D~0A");
response = read_http("response", cnct);
if (`reason = response["error"] ! E_RANGE')
raise(E_INVARG, tostr("Fetch failed:  ", reason[2]));
endif
json = strsub(response["body"], "~7E", "~");
try
return parse_json(json, "embedded-types");
except (E_INVARG)
raise(E_INVARG, "Parse JSON failed");
endtry
finally
`boot_player(cnct) ! E_TYPE';
endtry
.
#9:32
args && raise(E_ARGS);
$permit("wizard");
index = this:_fetch_from_archive(this.archive_host, this.archive_port, this.archive_base_uri + "/packages.json");
packages = [];
for package in (index["Packages"])
mk = mapkeys(package);
if ((("identifier" in mk) && ("version" in mk)) && ("link" in mk))
mk = mapkeys(package["link"]);
if ((("uri" in mk) && ("rel" in mk)) && (package["link"]["rel"] == "package"))
identifier = package["identifier"];
version = package["version"];
uri = package["link"]["uri"];
`packages[identifier] ! E_RANGE' || (packages[identifier] = []);
packages[identifier][version] = uri;
endif
endif
endfor
this.archived = packages;
this.last_fetch_index = time();
return packages;
.
#9:33
{identifier, version} = args;
$permit("wizard");
package = this:_fetch_from_archive(this.archive_host, this.archive_port, (this.archive_base_uri + "/") + this.archived[identifier][version]);
packages = this.cached;
`packages[identifier] ! E_RANGE' || (packages[identifier] = []);
packages[identifier][version] = package;
this.cached = packages;
return package;
.
#9:34
`{identifier, version, ?upgrade = 0} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  identifier, version, ?upgrade = 0")';
$permit("wizard");
package = this:_fetch_from_archive(this.archive_host, this.archive_port, (this.archive_base_uri + "/") + this.archived[identifier][version]);
try
package = this:import(package);
except ex ("E_PACKAGE")
package = ex[3];
endtry
return package;
.
#9:35
`{identifier, version, ?upgrade = 0} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  identifier, version, ?upgrade = 0")';
$permit("wizard");
package = this.cached[identifier][version];
try
package = this:import(package);
except ex ("E_PACKAGE")
package = ex[3];
endtry
return package;
.
#9:36
`{identifier, version, ?force = 1} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  identifier, version, ?force = 1")';
$permit("wizard");
package = this:_match(identifier, version)[1];
package = this:export(package);
packages = this.cached;
`packages[identifier] ! E_RANGE' || (packages[identifier] = []);
packages[identifier][version] = package;
this.cached = packages;
return package;
.
#9:37
$permit("wizard");
`{pathname, ?options = []} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  pathname, ?options")';
fh = -1;
try
fh = file_open(pathname, "r-tn");
package = parse_json(file_readline(fh), "embedded-types");
finally
(fh > -1) && file_close(fh);
endtry
try
package = this:import(package);
except ex ("E_PACKAGE")
package = ex[3];
endtry
return package;
return;
"$permit(\"wizard\");";
"";
"`{pathname, ?options = []} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  pathname, ?options\")';";
"";
"fh = -1;";
"try";
"  fh = file_open(pathname, \"r-tn\");";
"  package = parse_json(file_readline(fh), \"embedded-types\");";
"finally";
"  (fh > -1) && file_close(fh);";
"endtry";
"";
"try";
"  package = this:import(package);";
"except ex (\"E_PACKAGE\")";
"  package = ex[3];";
"endtry";
"";
"return package;";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:A25F06C67428605F0AEC8DC2B5B84ADC6631BC35";
"state:clean";
"updated_at:Wed Jun  6 08:10:40 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"$permit(\"wizard\");";
"";
"`{pathname, ?options = []} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  pathname, ?options\")';";
"";
"fh = 0;";
"try";
"  fh = file_open(pathname, \"r-tn\");";
"  package = parse_json(file_readline(fh), \"embedded-types\");";
"finally";
"  fh && file_close(fh);";
"endtry";
"";
"try";
"  package = this:import(package);";
"except ex (\"E_PACKAGE\")";
"  package = ex[3];";
"endtry";
"";
"return package;";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:8ACFF788841A5B066AD9D7DF77D960B27065D729";
"state:clean";
"updated_at:Mon May 28 08:30:13 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:38
$permit("wizard");
`{identifier, version, pathname, ?options = []} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  identifier, version, pathname, ?options")';
package = this:_match(identifier, version)[1];
package = this:export(package, options);
fh = -1;
try
fh = file_open(pathname, "w-tn");
file_writeline(fh, generate_json(package, "embedded-types"));
finally
(fh > -1) && file_close(fh);
endtry
return package;
return;
"$permit(\"wizard\");";
"";
"`{identifier, version, pathname, ?options = []} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  identifier, version, pathname, ?options\")';";
"";
"package = this:_match(identifier, version)[1];";
"";
"package = this:export(package, options);";
"";
"fh = -1;";
"try";
"  fh = file_open(pathname, \"w-tn\");";
"  file_writeline(fh, generate_json(package, \"embedded-types\"));";
"finally";
"  (fh > -1) && file_close(fh);";
"endtry";
"";
"return package;";
"";
"chunk_length:17";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:5FF1F9D03E4E435B1FF4ACD865F3FE8BA9895ADF";
"state:clean";
"updated_at:Wed Jun  6 08:10:40 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"$permit(\"wizard\");";
"";
"`{identifier, version, pathname, ?options = []} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  identifier, version, pathname, ?options\")';";
"";
"package = this:_match(identifier, version)[1];";
"";
"package = this:export(package, options);";
"";
"fh = 0;";
"try";
"  fh = file_open(pathname, \"w-tn\");";
"  file_writeline(fh, generate_json(package, \"embedded-types\"));";
"finally";
"  fh && file_close(fh);";
"endtry";
"";
"return package;";
"";
"chunk_length:17";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:5C79C8F91B13195E19ED5FA48BF128669E3B31EC";
"state:clean";
"updated_at:Mon May 28 08:30:13 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:39
`{identifier, version} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  identifier, version")';
$permit("wizard");
package = this.cached[identifier][version];
json = generate_json(package, "embedded-types");
suspend(0);
while (len = length(json))
suspend(0);
len = (len > 60000) ? 60000 | len;
line = json[1..len];
json[1..len] = "";
while (buffered_output_length(player))
suspend(0);
endwhile
notify(player, line);
endwhile
.
#9:40
if (callers() && (caller_perms() != player))
raise(E_PERM);
endif
if (!player.wizard)
notify(player, "Only wizards can do that!");
return;
endif
if (r = match(dobjstr, "^ *%([_a-z0-9]+%) *%([0-9]+%.[0-9]+%.[0-9]+%)? *$"))
seconds_and_ticks = 0;
try
seconds_and_ticks = this:_set_seconds_and_ticks();
try
notify(player, "Updating index...");
this:fetch_index();
except ex (E_INVARG)
notify(player, tostr("Update failed:  ", ex[2]));
endtry
identifier = dobjstr[r[3][1][1]..r[3][1][2]];
version = dobjstr[r[3][2][1]..r[3][2][2]];
if (`this.provides_cache[identifier] ! E_RANGE' != E_RANGE)
notify(player, tostr("Package \"", identifier, "\" is already installed."));
return;
elseif ((`this.archived[identifier] ! E_RANGE' == E_RANGE) && (`this.cached[identifier] ! E_RANGE' == E_RANGE))
notify(player, tostr("Package \"", identifier, "\" doesn't exist in either the remote archive or local cache."));
return;
else
if (version)
if ((`this.archived[identifier][version] ! E_RANGE' == E_RANGE) && (`this.cached[identifier][version] ! E_RANGE' == E_RANGE))
notify(player, tostr("Version \"", version, "\" of package \"", identifier, "\" doesn't exist in either the remote archive or local cache."));
return;
endif
else
cached = `mapkeys(this.cached[identifier]) ! E_RANGE => {}';
archived = `mapkeys(this.archived[identifier]) ! E_RANGE => {}';
versions = {@cached, @archived};
versions = this:_map("_parse_version", versions);
versions = this:_sort_versions(versions);
version = versions[1];
version = tostr(version[1], ".", version[2], ".", version[3]);
endif
endif
if (`this.cached[identifier][version] ! E_RANGE' != E_RANGE)
notify(player, tostr("Installing version \"", version, "\" of package \"", identifier, "\" from the local cache..."));
package = this:import_package_from_cache(identifier, version);
else
notify(player, tostr("Installing version \"", version, "\" of package \"", identifier, "\" from the remote archive..."));
package = this:import_package_from_archive(identifier, version);
endif
if (typeof(package) == OBJ)
this:install(package, ["follow-instructions" -> 1]);
else
notify(player, tostr("Version \"", version, "\" of package \"", identifier, "\" couldn't be installed (raw package below)."));
notify(player, toliteral(package));
return;
endif
notify(player, tostr("Version \"", version, "\" of package \"", identifier, "\" (", package.name, ") was successfully installed as ", package, "."));
finally
this:_reset_seconds_and_ticks(seconds_and_ticks);
endtry
else
notify(player, tostr("Correct usage is:  @install <package identifier> <package version> with $composed"));
notify(player, tostr("     for example:  @install foobar 1.2.3 with $composed"));
endif
.
#9:41
if (callers() && (caller_perms() != player))
raise(E_PERM);
endif
if (!player.wizard)
notify(player, "Only wizards can do that!");
return;
endif
if (r = match(dobjstr, "^ *%([_a-z0-9]+%) *%([0-9]+%.[0-9]+%.[0-9]+%) *$"))
identifier = dobjstr[r[3][1][1]..r[3][1][2]];
version = dobjstr[r[3][2][1]..r[3][2][2]];
if (`this.provides_cache[identifier][version] ! E_RANGE' == E_RANGE)
notify(player, tostr("Version \"", version, "\" of package \"", identifier, "\" is not installed."));
return;
endif
package = this.provides_cache[identifier][version][1];
this:delete(package, ["follow-instructions" -> 1]);
notify(player, tostr("Version \"", version, "\" of package \"", identifier, "\" was successfully uninstalled."));
else
notify(player, tostr("Correct usage is:  @uninstall <package identifier> <package version> with $composed"));
notify(player, tostr("     for example:  @uninstall foobar 1.2.3 with $composed"));
endif
.
#9:42
if (callers() && (caller_perms() != player))
raise(E_PERM);
endif
if (!player.wizard)
notify(player, "Only wizards can do that!");
return;
endif
if (dobjstr != "packages")
notify(player, tostr("Correct usage is:  @list packages with $composed"));
return;
endif
try
notify(player, "Updating index...");
this:fetch_index();
except ex (E_INVARG)
notify(player, tostr("Update failed:  ", ex[2]));
endtry
cached = this.cached;
archived = this.archived;
notify(player, "Installed packages");
for identifier in (mapkeys(this.provides_cache))
for version in (mapkeys(this.provides_cache[identifier]))
if ((version in `mapkeys(cached[identifier]) ! E_RANGE => []') || (version in `mapkeys(archived[identifier]) ! E_RANGE => {}'))
flags = "   ";
else
flags = " ! ";
endif
notify(player, tostr(flags, identifier, ", ", version, " (", objnum = this.provides_cache[identifier][version][1], ") ", objnum.name));
endfor
endfor
notify(player, "Cached packages [local]");
for identifier in (mapkeys(this.cached))
versions = "";
for version in (mapkeys(this.cached[identifier]))
versions = (versions + ", ") + version;
endfor
notify(player, tostr("   ", identifier, versions));
endfor
notify(player, msg = tostr("Archived packages [", this.archive_host, "]"));
for identifier in (mapkeys(this.archived))
versions = "";
for version in (mapkeys(this.archived[identifier]))
versions = (versions + ", ") + version;
endfor
notify(player, tostr("   ", identifier, versions));
endfor
notify(player, "(done)");
.
#9:43
$private();
{identifier, version, package} = args;
manifest = `package.manifest ! E_PROPNF => {}';
instructions = `package.instructions ! E_PROPNF => {}';
if ("install-dictionary" in instructions)
for item in (manifest)
{object, label} = item;
if ("dictionary" == label)
notify(player, tostr("Adding package dictionary (", object.name, ") to parents of $system..."));
parents = {@parents($system), object};
chparents($system, parents);
break;
endif
endfor
endif
if ("install-namespace" in instructions)
for item in (manifest)
{object, label} = item;
if ("dictionary" == label)
notify(player, tostr("Adding namespace (", identifier, ") as a property on $system..."));
add_property($system, identifier, object, {package, "r"});
break;
endif
endfor
endif
for instruction in (instructions)
if ((typeof(`$sysobj ! ANY') == OBJ) && (r = match(instruction, "^install-%([_a-z0-9]+%)-on-legacy-core$")))
property = instruction[r[3][1][1]..r[3][1][2]];
for item in (manifest)
{object, label} = item;
if (property == label)
notify(player, tostr("Adding property (", label, ") to $sysobj..."));
add_property($sysobj, label, object, {package, "r"});
endif
endfor
endif
endfor
return;
"$private();";
"";
"{identifier, version, package} = args;";
"";
"manifest = `package.manifest ! E_PROPNF => {}';";
"instructions = `package.instructions ! E_PROPNF => {}';";
"if (\"install-dictionary\" in instructions)";
"  for item in (manifest)";
"    {object, label} = item;";
"    if (\"dictionary\" == label)";
"      notify(player, tostr(\"Adding package dictionary (\", object.name, \") to parents of $system...\"));";
"      parents = {@parents($system), object};";
"      chparents($system, parents);";
"      break;";
"    endif";
"  endfor";
"endif";
"if (\"install-namespace\" in instructions)";
"  for item in (manifest)";
"    {object, label} = item;";
"    if (\"dictionary\" == label)";
"      notify(player, tostr(\"Adding namespace (\", identifier, \") as a property on $system...\"));";
"      add_property($system, identifier, object, {package, \"r\"});";
"      break;";
"    endif";
"  endfor";
"endif";
"for instruction in (instructions)";
"  if (typeof(`$sysobj ! ANY') == OBJ && (r = match(instruction, \"^install-%([_a-z0-9]+%)-on-legacy-core$\")))";
"    property = instruction[r[3][1][1]..r[3][1][2]];";
"    for item in (manifest)";
"      {object, label} = item;";
"      if (property == label)";
"        notify(player, tostr(\"Adding property (\", label, \") to $sysobj...\"));";
"        add_property($sysobj, label, object, {package, \"r\"});";
"      endif";
"    endfor";
"  endif";
"endfor";
"";
"chunk_length:39";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:2CB1F7A334A9700390CBAC2EE32FCE6189E284DC";
"state:clean";
"updated_at:Thu May 31 20:37:09 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:44
$private();
{identifier, version, package} = args;
manifest = `package.manifest ! E_PROPNF => {}';
instructions = `package.instructions ! E_PROPNF => {}';
if ("install-dictionary" in instructions)
for item in (manifest)
{object, label} = item;
if (("dictionary" == label) && (object in parents($system)))
notify(player, tostr("Removing package dictionary (", object.name, ") from parents of $system..."));
parents = setremove(parents($system), object);
chparents($system, parents);
break;
endif
endfor
endif
if ("install-namespace" in instructions)
for item in (manifest)
{object, label} = item;
if (("dictionary" == label) && (identifier in properties($system)))
notify(player, tostr("Removing namespace (", identifier, ") as a property on $system..."));
delete_property($system, identifier);
break;
endif
endfor
endif
for instruction in (instructions)
if ((typeof(`$sysobj ! ANY') == OBJ) && (r = match(instruction, "^install-%([_a-z0-9]+%)-on-legacy-core$")))
property = instruction[r[3][1][1]..r[3][1][2]];
for item in (manifest)
{object, label} = item;
if ((property == label) && (property in properties($sysobj)))
notify(player, tostr("Removing property (", label, ") from $sysobj..."));
delete_property($sysobj, label);
endif
endfor
endif
endfor
return;
"$private();";
"";
"{identifier, version, package} = args;";
"";
"manifest = `package.manifest ! E_PROPNF => {}';";
"instructions = `package.instructions ! E_PROPNF => {}';";
"if (\"install-dictionary\" in instructions)";
"  for item in (manifest)";
"    {object, label} = item;";
"    if (\"dictionary\" == label && object in parents($system))";
"      notify(player, tostr(\"Removing package dictionary (\", object.name, \") from parents of $system...\"));";
"      parents = setremove(parents($system), object);";
"      chparents($system, parents);";
"      break;";
"    endif";
"  endfor";
"endif";
"if (\"install-namespace\" in instructions)";
"  for item in (manifest)";
"    {object, label} = item;";
"    if (\"dictionary\" == label && identifier in properties($system))";
"      notify(player, tostr(\"Removing namespace (\", identifier, \") as a property on $system...\"));";
"      delete_property($system, identifier);";
"      break;";
"    endif";
"  endfor";
"endif";
"for instruction in (instructions)";
"  if (typeof(`$sysobj ! ANY') == OBJ && (r = match(instruction, \"^install-%([_a-z0-9]+%)-on-legacy-core$\")))";
"    property = instruction[r[3][1][1]..r[3][1][2]];";
"    for item in (manifest)";
"      {object, label} = item;";
"      if (property == label && property in properties($sysobj))";
"        notify(player, tostr(\"Removing property (\", label, \") from $sysobj...\"));";
"        delete_property($sysobj, label);";
"      endif";
"    endfor";
"  endif";
"endfor";
"";
"chunk_length:39";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:8DF7C5499DB29B394C664EC5978F5EE705A8E030";
"state:clean";
"updated_at:Thu May 31 20:26:10 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#10:0
{message} = args;
$permit("owner", "wizard");
add_property(this, tostr(time()), message, {this.owner, "r"});
return;
"{message} = args;";
"";
"$permit(\"owner\", \"wizard\");";
"";
"add_property(this, tostr(time()), message, {this.owner, \"r\"});";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"updated_at:Tue Oct 25 06:17:39 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#12:0
if (`args[$][1] ! E_TYPE, E_RANGE' == ";")
args[$] = tostr("return ", args[$][2..$], ";");
endif
return {$lambda_proto, @args};
return;
"if (`args[$][1] ! E_TYPE, E_RANGE' == \";\")";
"  args[$] = tostr(\"return \", args[$][2..$], \";\");";
"endif";
"return {$lambda_proto, @args};";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0B180E96359BE26F6C6657852781421033A84241";
"-=-=-mxyzptlk-=-=-";
.
#13:0
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
return;
"(ticks_left() < 10000 || seconds_left() < 2) && suspend(0);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C7B9AA9D4FFB81B732A30FE8DFCCB25794BD2172";
"-=-=-mxyzptlk-=-=-";
.
#13:1
{?old_school = 0} = args;
return (!old_school) ? ([0 -> $int_proto, 2 -> $str_proto, 3 -> $err_proto, 4 -> $list_proto, 10 -> $map_proto, 9 -> $float_proto])[typeof(this)] | typeof(this);
return;
"{?old_school = 0} = args;";
"return !old_school ? [0 -> $int_proto, 2 -> $str_proto, 3 -> $err_proto, 4 -> $list_proto, 10 -> $map_proto, 9 -> $float_proto][typeof(this)] | typeof(this);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:067CFEF398A09967430E7285E89A27E09EE31E99";
"-=-=-mxyzptlk-=-=-";
.
#13:2
return generate_json(this, @args);
return;
"return generate_json(this, @args);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D9BCBC16608002F4DBDD530226BA55CD075E90A0";
"-=-=-mxyzptlk-=-=-";
.
#14:0
return abs(this);
return;
"return abs(this);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:BA3950CF359CA8E59B1D31D1847CCB147F031551";
"-=-=-mxyzptlk-=-=-";
.
#15:0
set_task_perms(caller_perms());
{limit, @args} = args;
if (limit < this)
return this;
endif
lambda = args:_lambdafy();
while (limit >= this)
this:_suspend_if_necessary();
args && lambda:call(this);
this = this + 1;
endwhile
return this - 1;
return;
"set_task_perms(caller_perms());";
"";
"{limit, @args} = args;";
"";
"if (limit < this)";
"  return this;";
"endif";
"";
"lambda = args:_lambdafy();";
"";
"while (limit >= this)";
"  this:_suspend_if_necessary();";
"  args && lambda:call(this);";
"  this = this + 1;";
"endwhile";
"";
"return this - 1;";
"";
"chunk_length:17";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3B57112B9C4DC27E648D2A04836553A174760726";
"-=-=-mxyzptlk-=-=-";
.
#15:1
set_task_perms(caller_perms());
{limit, @args} = args;
if (limit > this)
return this;
endif
lambda = args:_lambdafy();
while (limit <= this)
this:_suspend_if_necessary();
args && lambda:call(this);
this = this - 1;
endwhile
return this + 1;
return;
"set_task_perms(caller_perms());";
"";
"{limit, @args} = args;";
"";
"if (limit > this)";
"  return this;";
"endif";
"";
"lambda = args:_lambdafy();";
"";
"while (limit <= this)";
"  this:_suspend_if_necessary();";
"  args && lambda:call(this);";
"  this = this - 1;";
"endwhile";
"";
"return this + 1;";
"";
"chunk_length:17";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9597CAE84B6371AAC5AE3D90B93B801DE451B99D";
"-=-=-mxyzptlk-=-=-";
.
#17:0
args && raise(E_ARGS);
if (`this[1][1] ! E_TYPE, E_RANGE' == $lambda_proto)
return this[1];
elseif ((t = typeof(this)) == LIST)
return ((length(this) == 1) && (typeof(this[1]) == LIST)) ? $lambda(@this[1]) | $lambda(@this);
elseif (t == STR)
return $lambda(this);
else
raise(E_INVIND);
endif
return;
"args && raise(E_ARGS);";
"";
"if (`this[1][1] ! E_TYPE, E_RANGE' == $lambda_proto)";
"  return this[1];";
"";
"elseif ((t = typeof(this)) == LIST)";
"  return length(this) == 1 && typeof(this[1]) == LIST ? $lambda(@this[1]) | $lambda(@this);";
"";
"elseif (t == STR)";
"  return $lambda(this);";
"";
"else";
"  raise(E_INVIND);";
"";
"endif";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:208CE21BC32D54C1950EF2D15004A5CF22046682";
"-=-=-mxyzptlk-=-=-";
.
#17:1
set_task_perms(caller_perms());
lambda = args:_lambdafy();
if ((((t = typeof(this)) == MAP) || (t == LIST)) || (t == STR))
for v, k in (this)
this:_suspend_if_necessary();
lambda:call(v, k, this);
endfor
else
raise(E_INVIND);
endif
return this;
return;
"set_task_perms(caller_perms());";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP || t == LIST || t == STR)";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    lambda:call(v, k, this);";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return this;";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D5C5A1294FA2C25DF4035A85EE57294E5625BB3D";
"-=-=-mxyzptlk-=-=-";
.
#17:2
set_task_perms(caller_perms());
lambda = args:_lambdafy();
if ((t = typeof(this)) == MAP)
result = [];
for v, k in (this)
this:_suspend_if_necessary();
result[k] = lambda:call(v, k, this);
endfor
elseif (t == LIST)
result = {};
for v, i in (this)
this:_suspend_if_necessary();
result = {@result, lambda:call(v, i, this)};
endfor
elseif (t == STR)
result = "";
for v, i in (this)
this:_suspend_if_necessary();
result = tostr(result, lambda:call(v, i, this));
endfor
else
raise(E_INVIND);
endif
return result;
return;
"set_task_perms(caller_perms());";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP)";
"  result = [];";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    result[k] = lambda:call(v, k, this);";
"  endfor";
"elseif (t == LIST)";
"  result = {};";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    result = {@result, lambda:call(v, i, this)};";
"  endfor";
"elseif (t == STR)";
"  result = \"\";";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    result = tostr(result, lambda:call(v, i, this));";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return result;";
"";
"chunk_length:27";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6A182A88549B599A020E61B8D363453F653125F0";
"-=-=-mxyzptlk-=-=-";
.
#17:3
set_task_perms(caller_perms());
{initial, @args} = args;
lambda = args:_lambdafy();
if ((((t = typeof(this)) == MAP) || (t == LIST)) || (t == STR))
for v, k in (this)
this:_suspend_if_necessary();
initial = lambda:call(initial, v, k, this);
endfor
else
raise(E_INVIND);
endif
return initial;
return;
"set_task_perms(caller_perms());";
"";
"{initial, @args} = args;";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP || t == LIST || t == STR)";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    initial = lambda:call(initial, v, k, this);";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return initial;";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:00B451193757129619DE758EB6865222F1113856";
"-=-=-mxyzptlk-=-=-";
.
#17:4
set_task_perms(caller_perms());
lambda = args:_lambdafy();
if ((t = typeof(this)) == MAP)
for v, k in (this)
this:_suspend_if_necessary();
if (lambda:call(v, k, this))
return [k -> v];
endif
endfor
elseif (t == LIST)
for v, i in (this)
this:_suspend_if_necessary();
if (lambda:call(v, i, this))
return v;
endif
endfor
elseif (t == STR)
for v, i in (this)
this:_suspend_if_necessary();
if (lambda:call(v, i, this))
return v;
endif
endfor
else
raise(E_INVIND);
endif
return E_RANGE;
return;
"set_task_perms(caller_perms());";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP)";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    if (lambda:call(v, k, this))";
"      return [k -> v];";
"    endif";
"  endfor";
"elseif (t == LIST)";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    if (lambda:call(v, i, this))";
"      return v;";
"    endif";
"  endfor";
"elseif (t == STR)";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    if (lambda:call(v, i, this))";
"      return v;";
"    endif";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return E_RANGE;";
"";
"chunk_length:30";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9B54C30F1C5AECD5AAE7E504FE961F3E1AA5C8B6";
"-=-=-mxyzptlk-=-=-";
.
#17:5
set_task_perms(caller_perms());
lambda = args:_lambdafy();
if ((t = typeof(this)) == MAP)
result = [];
for v, k in (this)
this:_suspend_if_necessary();
if (lambda:call(v, k, this))
result[k] = v;
endif
endfor
elseif (t == LIST)
result = {};
for v, i in (this)
this:_suspend_if_necessary();
if (lambda:call(v, i, this))
result = {@result, v};
endif
endfor
elseif (t == STR)
result = "";
for v, i in (this)
this:_suspend_if_necessary();
if (lambda:call(v, i, this))
result = tostr(result, v);
endif
endfor
else
raise(E_INVIND);
endif
return result;
return;
"set_task_perms(caller_perms());";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP)";
"  result = [];";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    if (lambda:call(v, k, this))";
"      result[k] = v;";
"    endif";
"  endfor";
"elseif (t == LIST)";
"  result = {};";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    if (lambda:call(v, i, this))";
"      result = {@result, v};";
"    endif";
"  endfor";
"elseif (t == STR)";
"  result = \"\";";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    if (lambda:call(v, i, this))";
"      result = tostr(result, v);";
"    endif";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return result;";
"";
"chunk_length:33";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2C699D18C9ECC48F84D6F35A40FC4BFBE19E76C6";
"-=-=-mxyzptlk-=-=-";
.
#17:6
set_task_perms(caller_perms());
lambda = args:_lambdafy();
if ((t = typeof(this)) == MAP)
result = [];
for v, k in (this)
this:_suspend_if_necessary();
if (!lambda:call(v, k, this))
result[k] = v;
endif
endfor
elseif (t == LIST)
result = {};
for v, i in (this)
this:_suspend_if_necessary();
if (!lambda:call(v, i, this))
result = {@result, v};
endif
endfor
elseif (t == STR)
result = "";
for v, i in (this)
this:_suspend_if_necessary();
if (!lambda:call(v, i, this))
result = tostr(result, v);
endif
endfor
else
raise(E_INVIND);
endif
return result;
return;
"set_task_perms(caller_perms());";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP)";
"  result = [];";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    if (!lambda:call(v, k, this))";
"      result[k] = v;";
"    endif";
"  endfor";
"elseif (t == LIST)";
"  result = {};";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    if (!lambda:call(v, i, this))";
"      result = {@result, v};";
"    endif";
"  endfor";
"elseif (t == STR)";
"  result = \"\";";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    if (!lambda:call(v, i, this))";
"      result = tostr(result, v);";
"    endif";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return result;";
"";
"chunk_length:33";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4CBB74CF7ADB7925F095CDB7017AD2D763FCBBBF";
"-=-=-mxyzptlk-=-=-";
.
#17:7
set_task_perms(caller_perms());
lambda = args:_lambdafy();
if ((((t = typeof(this)) == MAP) || (t == LIST)) || (t == STR))
for v, k in (this)
this:_suspend_if_necessary();
if (!lambda:call(v, k, this))
return 0;
endif
endfor
else
raise(E_INVIND);
endif
return 1;
return;
"set_task_perms(caller_perms());";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP || t == LIST || t == STR)";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    if (!lambda:call(v, k, this))";
"      return 0;";
"    endif";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return 1;";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E50637F2A7A735C039AAEC67663C8D5A8D6A6D5E";
"-=-=-mxyzptlk-=-=-";
.
#17:8
set_task_perms(caller_perms());
lambda = args:_lambdafy();
if ((((t = typeof(this)) == MAP) || (t == LIST)) || (t == STR))
for v, k in (this)
this:_suspend_if_necessary();
if (lambda:call(v, k, this))
return 1;
endif
endfor
else
raise(E_INVIND);
endif
return 0;
return;
"set_task_perms(caller_perms());";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP || t == LIST || t == STR)";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    if (lambda:call(v, k, this))";
"      return 1;";
"    endif";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return 0;";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B3B0A17C2B7F9E452F81810DD8379F97C9E44324";
"-=-=-mxyzptlk-=-=-";
.
#17:9
return length(this);
return;
"return length(this);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3BB4313C64CA72A108761536D323394348A38A34";
"-=-=-mxyzptlk-=-=-";
.
#18:0
return this:_lambdafy();
return;
"return this:_lambdafy();";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:959EB05A85FBF2BC337FC649BA3AC422156EFF93";
"-=-=-mxyzptlk-=-=-";
.
#18:1
set_task_perms(caller_perms());
return this:_lambdafy():call(@args);
return;
"set_task_perms(caller_perms());";
"";
"return this:_lambdafy():call(@args);";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3723F4F2B0BD8DA95790F583FDBFBBFC4E7A778E";
"-=-=-mxyzptlk-=-=-";
.
#18:2
return call_function(verb, this, @args);
return;
"return call_function(verb, this, @args);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:1847674C287E387BE51DA2F0E670E76BF5069349";
"-=-=-mxyzptlk-=-=-";
.
#18:3
{?sep = " "} = args;
l = length(sep);
this = this + sep;
parts = {};
while (this)
this:_suspend_if_necessary();
if ((i = index(this, sep)) > 1)
parts = {@parts, this[1..i - 1]};
endif
this = this[i + l..$];
endwhile
return parts;
return;
"{?sep = \" \"} = args;";
"l = length(sep);";
"this = this + sep;";
"parts = {};";
"while (this)";
"  this:_suspend_if_necessary();";
"  if ((i = index(this, sep)) > 1)";
"    parts = {@parts, this[1..i - 1]};";
"  endif";
"  this = this[i + l..$];";
"endwhile";
"return parts;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4153272A0E0CC766B9D31A34FBF8A505FC844D9E";
"-=-=-mxyzptlk-=-=-";
.
#18:4
{?pattern = " "} = args;
if ((verb == "trim") || (verb == "triml"))
if ((this && pattern) && (r = match(this, tostr("^%(", pattern, "%)*"))))
this = this[r[2] + 1..$];
endif
endif
if ((verb == "trim") || (verb == "trimr"))
if ((this && pattern) && (r = match(this, tostr("%(", pattern, "%)*$"))))
this = this[1..r[1] - 1];
endif
endif
return this;
return;
"{?pattern = \" \"} = args;";
"if (verb == \"trim\" || verb == \"triml\")";
"  if (this && pattern && (r = match(this, tostr(\"^%(\", pattern, \"%)*\"))))";
"    this = this[r[2] + 1..$];";
"  endif";
"endif";
"if (verb == \"trim\" || verb == \"trimr\")";
"  if (this && pattern && (r = match(this, tostr(\"%(\", pattern, \"%)*$\"))))";
"    this = this[1..r[1] - 1];";
"  endif";
"endif";
"return this;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:1A865BF364DA2D6028E2FF30599A9715958D5EAB";
"-=-=-mxyzptlk-=-=-";
.
#18:5
if (args && (typeof(args[1]) == MAP))
{subs, ?case = 0} = args;
for value, key in (subs)
this:_suspend_if_necessary();
this = strsub(this, key, value, case);
endfor
elseif (args && (typeof(args[1]) == LIST))
{subs, ?case = 0} = args;
for item in (subs)
this:_suspend_if_necessary();
this = strsub(this, item[1], item[2], case);
endfor
elseif (args && (typeof(args[1]) == STR))
{from, to, ?case = 0} = args;
this = strsub(this, from, to, case);
else
raise(E_INVARG);
endif
return this;
return;
"if (args && typeof(args[1]) == MAP)";
"  {subs, ?case = 0} = args;";
"  for value, key in (subs)";
"    this:_suspend_if_necessary();";
"    this = strsub(this, key, value, case);";
"  endfor";
"elseif (args && typeof(args[1]) == LIST)";
"  {subs, ?case = 0} = args;";
"  for item in (subs)";
"    this:_suspend_if_necessary();";
"    this = strsub(this, item[1], item[2], case);";
"  endfor";
"elseif (args && typeof(args[1]) == STR)";
"  {from, to, ?case = 0} = args;";
"  this = strsub(this, from, to, case);";
"else";
"  raise(E_INVARG);";
"endif";
"return this;";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E1FB0C1CEF67E67A435D3C5411D98621BF820D47";
"-=-=-mxyzptlk-=-=-";
.
#18:6
{from, to, ?case = 0} = args;
((len = length(from)) == length(to)) || raise(E_INVARG);
for i in [1..len]
this:_suspend_if_necessary();
this = strsub(this, from[i], to[i], case);
endfor
return this;
return;
"{from, to, ?case = 0} = args;";
"(len = length(from)) == length(to) || raise(E_INVARG);";
"for i in [1..len]";
"  this:_suspend_if_necessary();";
"  this = strsub(this, from[i], to[i], case);";
"endfor";
"return this;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2DCB3342FC86401C64D103A6576BDF7B0B6633EA";
"-=-=-mxyzptlk-=-=-";
.
#20:0
return this:_lambdafy();
return;
"return this:_lambdafy();";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:959EB05A85FBF2BC337FC649BA3AC422156EFF93";
"-=-=-mxyzptlk-=-=-";
.
#20:1
set_task_perms(caller_perms());
return this:_lambdafy():call(@args);
return;
"set_task_perms(caller_perms());";
"";
"return this:_lambdafy():call(@args);";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3723F4F2B0BD8DA95790F583FDBFBBFC4E7A778E";
"-=-=-mxyzptlk-=-=-";
.
#20:2
return setadd(this, @args);
return;
"return setadd(this, @args);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:CE7621ACACF94FCC88B65B17F7158B58DE71DA91";
"-=-=-mxyzptlk-=-=-";
.
#20:3
return setremove(this, @args);
return;
"return setremove(this, @args);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D11EF59399D367FDF9581B5F3F840CD0525D6740";
"-=-=-mxyzptlk-=-=-";
.
#20:4
{LIST} = args;
for i in (LIST)
this:_suspend_if_necessary();
this = setadd(this, i);
endfor
return this;
return;
"{list} = args;";
"";
"for i in (list)";
"  this:_suspend_if_necessary();";
"  this = setadd(this, i);";
"endfor";
"";
"return this;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:8093E1F1B5AE3659A8640604A77593E00B6B0B0B";
"-=-=-mxyzptlk-=-=-";
.
#20:5
{LIST} = args;
result = {};
for i in (LIST)
this:_suspend_if_necessary();
if (i in this)
result = setadd(result, i);
endif
endfor
return result;
return;
"{list} = args;";
"";
"result = {};";
"";
"for i in (list)";
"  this:_suspend_if_necessary();";
"  if (i in this)";
"    result = setadd(result, i);";
"  endif";
"endfor";
"";
"return result;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:03B3C8BB2D0698F44CF4653FB5EFA39DAE32B648";
"-=-=-mxyzptlk-=-=-";
.
#20:6
{LIST} = args;
for i in (LIST)
this:_suspend_if_necessary();
this = setremove(this, i);
endfor
return this;
return;
"{list} = args;";
"";
"for i in (list)";
"  this:_suspend_if_necessary();";
"  this = setremove(this, i);";
"endfor";
"";
"return this;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:488B8E756A8AFEB64308138FC3C8DE99BF9540D1";
"-=-=-mxyzptlk-=-=-";
.
#20:7
{?sep = " "} = args;
res = "";
for i in (this)
this:_suspend_if_necessary();
i = tostr(i);
res = res + (res ? sep + i | i);
endfor
return res;
return;
"{?sep = \" \"} = args;";
"";
"res = \"\";";
"";
"for i in (this)";
"  this:_suspend_if_necessary();";
"  i = tostr(i);";
"  res = res + (res ? sep + i | i);";
"endfor";
"";
"return res;";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D4406C542915510EDFBD3BFEEAFDD7C1B9079ED4";
"-=-=-mxyzptlk-=-=-";
.
#20:8
args && raise(E_ARGS);
l = length(this);
i = 1;
while (i <= l)
v = this[i];
j = i - 1;
while (j > 0)
this:_suspend_if_necessary();
if (this[j] <= v)
break;
endif
this[j + 1] = this[j];
j = j - 1;
endwhile
this[j + 1] = v;
i = i + 1;
endwhile
return this;
return;
"args && raise(E_ARGS);";
"";
"l = length(this);";
"i = 1;";
"while (i <= l)";
"  v = this[i];";
"  j = i - 1;";
"  while (j > 0)";
"    this:_suspend_if_necessary();";
"    if (this[j] <= v)";
"      break;";
"    endif";
"    this[j + 1] = this[j];";
"    j = j - 1;";
"  endwhile";
"  this[j + 1] = v;";
"  i = i + 1;";
"endwhile";
"";
"return this;";
"";
"chunk_length:20";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B81C52D295D77B5B6F3277DADF44FEFFAFBFFA0D";
"-=-=-mxyzptlk-=-=-";
.
#20:9
args && raise(E_ARGS);
l = length(this);
i = 1;
while (i <= (l / 2))
this:_suspend_if_necessary();
t = this[i];
this[i] = this[($ - i) + 1];
this[($ - i) + 1] = t;
i = i + 1;
endwhile
return this;
return;
"args && raise(E_ARGS);";
"";
"l = length(this);";
"i = 1;";
"while (i <= l / 2)";
"  this:_suspend_if_necessary();";
"  t = this[i];";
"  this[i] = this[$ - i + 1];";
"  this[$ - i + 1] = t;";
"  i = i + 1;";
"endwhile";
"";
"return this;";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:138A432FDF55E23108C799F02D3A15516F48B2B1";
"-=-=-mxyzptlk-=-=-";
.
#20:10
nth = args ? (length(args) > 1) ? args | args[1] | 1;
res = {};
if (typeof(nth) == LIST)
for i in (this)
out = {};
for n in (nth)
this:_suspend_if_necessary();
out = {@out, i[n]};
endfor
res = {@res, out};
endfor
else
for i in (this)
this:_suspend_if_necessary();
res = {@res, i[nth]};
endfor
endif
return res;
return;
"nth = args ? length(args) > 1 ? args | args[1] | 1;";
"";
"res = {};";
"";
"if (typeof(nth) == LIST)";
"  for i in (this)";
"    out = {};";
"    for n in (nth)";
"      this:_suspend_if_necessary();";
"      out = {@out, i[n]};";
"    endfor";
"    res = {@res, out};";
"  endfor";
"else";
"  for i in (this)";
"    this:_suspend_if_necessary();";
"    res = {@res, i[nth]};";
"  endfor";
"endif";
"";
"return res;";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C332694FE2E63092AEAC24BD016B449B87054AAA";
"-=-=-mxyzptlk-=-=-";
.
#20:11
{?depth = 2147483647} = args;
new = {};
for item in (this)
this:_suspend_if_necessary();
if ((typeof(item) == LIST) && depth)
new = {@new, @item:flatten(depth - 1)};
else
new = {@new, item};
endif
endfor
return new;
.
#21:0
return mapkeys(this);
return;
"return mapkeys(this);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9354D8C0778D6BDE7497E321636C58BEDF4AEFD2";
"-=-=-mxyzptlk-=-=-";
.
#21:1
return mapvalues(this);
return;
"return mapvalues(this);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:86EC57648206C350FB011EA997EB935E8FB8875C";
"-=-=-mxyzptlk-=-=-";
.
#21:2
for arg in (args)
this:_suspend_if_necessary();
this = mapdelete(this, arg);
endfor
return this;
return;
"for arg in (args)";
"  this:_suspend_if_necessary();";
"  this = mapdelete(this, arg);";
"endfor";
"";
"return this;";
"";
"chunk_length:6";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:369BE6E36CD5566ACD55F3FF34AED7DF99FA8052";
"-=-=-mxyzptlk-=-=-";
.
#21:3
{p, ?d = E_RANGE} = args;
{f, @r} = p;
v = `r ? (typeof(this[f]) == MAP) ? this[f]:value_by_path(r) | E_RANGE | this[f] ! E_RANGE => d';
return v;
return;
"{p, ?d = E_RANGE} = args;";
"";
"{f, @r} = p;";
"";
"v = `r ? typeof(this[f]) == MAP ? this[f]:value_by_path(r) | E_RANGE | this[f] ! E_RANGE => d';";
"";
"return v;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A2DABC4108AE2E5D73D8C3E7A55F42778DBEF074";
"-=-=-mxyzptlk-=-=-";
.
#21:4
{p, v} = args;
{f, @r} = p;
this[f] = r ? `(typeof(this[f]) == MAP) ? this[f] | ([]) ! E_RANGE => []':set_value_by_path(r, v) | v;
return this;
return;
"{p, v} = args;";
"";
"{f, @r} = p;";
"";
"this[f] = r ? `typeof(this[f]) == MAP ? this[f] | [] ! E_RANGE => []':set_value_by_path(r, v) | v;";
"";
"return this;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5381C2F8F679EE2FEA399FE9FC24331EA02468A7";
"-=-=-mxyzptlk-=-=-";
.
#21:5
{MAP} = args;
for value, key in (MAP)
this:_suspend_if_necessary();
this[key] = value;
endfor
return this;
return;
"{map} = args;";
"for value, key in (map)";
"  this:_suspend_if_necessary();";
"  this[key] = value;";
"endfor";
"return this;";
"";
"chunk_length:6";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:7AE99586C027B648096509215D1DBDB6D3009054";
"-=-=-mxyzptlk-=-=-";
.
#22:0
(this == $lambda_proto) || raise(E_VERBNF);
return $lambda(@args);
return;
"this == $lambda_proto || raise(E_VERBNF);";
"return $lambda(@args);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:77F339663AA8C1DF0EBDBBC1BC629559F6FC15BA";
"-=-=-mxyzptlk-=-=-";
.
#22:1
return this;
return;
"return this;";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:58CFE4977A49A7695FEE4D2F29BB87606D70E92F";
"-=-=-mxyzptlk-=-=-";
.
#22:2
return caller;
return;
"return caller;";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:ABE6F07484C492170E9B7C2F68E0552B0D80DCCE";
"-=-=-mxyzptlk-=-=-";
.
#22:3
{args} = args;
if ((l = length(args)) > 1)
return {args[2..l - 1], args[$]};
else
return {{}, ""};
endif
return;
"{args} = args;";
"";
"if ((l = length(args)) > 1)";
"  return {args[2..l - 1], args[$]};";
"else";
"  return {{}, \"\"};";
"endif";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:995FD2218B9314F5C19EFC6D82D8018EF9AF398D";
"-=-=-mxyzptlk-=-=-";
.
#22:4
{MAP, params, body} = args;
for value, key in (MAP)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (key in params)
params = setremove(params, key);
else
raise(E_INVARG, tostr("Not a formal parameter:  ", key));
endif
body = tostr(key, " = ", toliteral(value), "; ", body);
endfor
return {params, body};
return;
"{map, params, body} = args;";
"";
"for value, key in (map)";
"  (ticks_left() < 10000 || seconds_left() < 2) && suspend(0);";
"  if (key in params)";
"    params = setremove(params, key);";
"  else";
"    raise(E_INVARG, tostr(\"Not a formal parameter:  \", key));";
"  endif";
"  body = tostr(key, \" = \", toliteral(value), \"; \", body);";
"endfor";
"";
"return {params, body};";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:71D73EBA75C8973EC7663FC1EF7AC1A7BF2ED075";
"-=-=-mxyzptlk-=-=-";
.
#22:5
{?MAP = []} = args;
{params, body} = this:_params_and_body(caller);
{params, body} = this:_prepend_assignments(MAP, params, body);
return $lambda(@params, body);
return;
"{?map = []} = args;";
"";
"{params, body} = this:_params_and_body(caller);";
"";
"{params, body} = this:_prepend_assignments(map, params, body);";
"";
"return $lambda(@params, body);";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B261DE92E9B55AFED2085388539CAF1B038EF98F";
"-=-=-mxyzptlk-=-=-";
.
#22:6
{object, ?MAP = []} = args;
{params, body} = this:_params_and_body(caller);
{params, body} = this:_prepend_assignments(MAP, params, body);
body = tostr("this = ", toliteral(object), "; ", body);
return $lambda(@params, body);
return;
"{object, ?map = []} = args;";
"";
"{params, body} = this:_params_and_body(caller);";
"";
"{params, body} = this:_prepend_assignments(map, params, body);";
"";
"body = tostr(\"this = \", toliteral(object), \"; \", body);";
"";
"return $lambda(@params, body);";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:EA2B3A9B04DF3AD881675E728160DFD504406DEB";
"-=-=-mxyzptlk-=-=-";
.
#22:7
set_task_perms(caller_perms());
{params, body} = this:_params_and_body(caller);
if (length(args) < (l = length(params)))
raise(E_ARGS, tostr("Too few arguments:  ", params:join(", "), " required"));
endif
for i in [1..l]
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
body = tostr(params[i], " = ", toliteral(args[i]), "; ", body);
endfor
result = eval(body);
result[1] || raise("E_SYNTAX", "Syntax error", result[2]);
return result[2];
return;
"set_task_perms(caller_perms());";
"";
"{params, body} = this:_params_and_body(caller);";
"";
"if (length(args) < (l = length(params)))";
"  raise(E_ARGS, tostr(\"Too few arguments:  \", params:join(\", \"), \" required\"));";
"endif";
"";
"for i in [1..l]";
"  (ticks_left() < 10000 || seconds_left() < 2) && suspend(0);";
"  body = tostr(params[i], \" = \", toliteral(args[i]), \"; \", body);";
"endfor";
"";
"result = eval(body);";
"";
"result[1] || raise(\"E_SYNTAX\", \"Syntax error\", result[2]);";
"";
"return result[2];";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:36A490B9D5E231CB51F4D5EE750D79D80FB39E0D";
"-=-=-mxyzptlk-=-=-";
.
#23:0
set_task_perms(caller_perms());
(typeof(this) == LIST) || raise(E_INVIND, "Only type list");
{_, name, programmer, location, _} = callers()[1];
if ((name && (programmer == $nothing)) && (location == $nothing))
return;
endif
if (this && ((prototype = this[1]) in $frobs))
return prototype:(verb)(@args);
endif
return pass(@args);
return;
"set_task_perms(caller_perms());";
"";
"/* only lists */";
"typeof(this) == LIST || raise(E_INVIND, \"Only type list\");";
"";
"/* don't respond to calls from built-ins */";
"{_, name, programmer, location, _} = callers()[1];";
"if (name && programmer == $nothing && location == $nothing)";
"  return;";
"endif";
"";
"if (this && (prototype = this[1]) in $frobs)";
"  return prototype:(verb)(@args);";
"endif";
"";
"return pass(@args);";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0E68D8B527E7823629D3B988205F34F46FF127B4";
"-=-=-mxyzptlk-=-=-";
.
#24:0
set_task_perms(caller_perms());
(typeof(this) == MAP) || raise(E_INVIND, "Only type map");
{_, name, programmer, location, _} = callers()[1];
if ((name && (programmer == $nothing)) && (location == $nothing))
return;
endif
if (this && (`prototype = this["prototype"] ! E_RANGE' in $frobs))
return prototype:(verb)(@args);
endif
return pass(@args);
return;
"set_task_perms(caller_perms());";
"";
"/* only maps */";
"typeof(this) == MAP || raise(E_INVIND, \"Only type map\");";
"";
"/* don't respond to calls from built-ins */";
"{_, name, programmer, location, _} = callers()[1];";
"if (name && programmer == $nothing && location == $nothing)";
"  return;";
"endif";
"";
"if (this && `prototype = this[\"prototype\"] ! E_RANGE' in $frobs)";
"  return prototype:(verb)(@args);";
"endif";
"";
"return pass(@args);";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:8487D577477B3464C8E36F9AA0C8926B0A61EDB4";
"-=-=-mxyzptlk-=-=-";
.
#29:0
{parser, separator, infix, terminator, ?symbols = {}} = args;
ids = {};
for symbol in (symbols)
ids = {@ids, parser:push(@symbol)};
endfor
if (terminator && (parser:token().id == terminator))
return {};
endif
key = parser:expression(0);
parser:advance(infix);
value = parser:expression(0);
MAP = {{key, value}};
while (parser:token().id == separator)
MAP && parser:advance(separator);
key = parser:expression(0);
parser:advance(infix);
value = parser:expression(0);
MAP = {@MAP, {key, value}};
endwhile
for id in (ids)
parser:pop(id);
endfor
return MAP;
return;
"{parser, separator, infix, terminator, ?symbols = {}} = args;";
"";
"ids = {};";
"for symbol in (symbols)";
"  ids = {@ids, parser:push(@symbol)};";
"endfor";
"";
"if (terminator && parser:token().id == terminator)";
"  return {};";
"endif";
"";
"key = parser:expression(0);";
"parser:advance(infix);";
"value = parser:expression(0);";
"map = {{key, value}};";
"";
"while (parser:token().id == separator)";
"  map && parser:advance(separator);";
"  key = parser:expression(0);";
"  parser:advance(infix);";
"  value = parser:expression(0);";
"  map = {@map, {key, value}};";
"endwhile";
"";
"for id in (ids)";
"  parser:pop(id);";
"endfor";
"";
"return map;";
"";
"chunk_length:29";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2D673EA421682598DCBFFE12CA9EC6ED818AE60D";
"-=-=-mxyzptlk-=-=-";
.
#29:1
{parser, separator, terminator, ?symbols = "defaults"} = args;
if (symbols && (symbols == "defaults"))
symbols = {{"@", 0, this.plastic.prefix_operator_proto}};
endif
ids = {};
for symbol in (symbols)
ids = {@ids, parser:push(@symbol)};
endfor
if (terminator && (parser:token().id == terminator))
return {};
endif
expression = parser:expression(0);
LIST = {expression};
while (parser:token().id == separator)
parser:advance(separator);
expression = parser:expression(0);
LIST = {@LIST, expression};
endwhile
for id in (ids)
parser:pop(id);
endfor
return LIST;
return;
"{parser, separator, terminator, ?symbols = \"defaults\"} = args;";
"";
"/* enable defaults */";
"if (symbols && symbols == \"defaults\")";
"  symbols = {{\"@\", 0, this.plastic.prefix_operator_proto}};";
"endif";
"";
"ids = {};";
"for symbol in (symbols)";
"  ids = {@ids, parser:push(@symbol)};";
"endfor";
"";
"if (terminator && parser:token().id == terminator)";
"  return {};";
"endif";
"";
"expression = parser:expression(0);";
"list = {expression};";
"";
"while (parser:token().id == separator)";
"  parser:advance(separator);";
"  expression = parser:expression(0);";
"  list = {@list, expression};";
"endwhile";
"";
"for id in (ids)";
"  parser:pop(id);";
"endfor";
"";
"return list;";
"";
"chunk_length:30";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F81CBA9934A78648882412ADF140C5938CF5ABEF";
"-=-=-mxyzptlk-=-=-";
.
#29:2
{parser, pattern} = args;
state = 1;
for element in (pattern)
if ((state == 1) && (element.type == "variable"))
continue;
elseif ((((state == 1) || (state == 2)) && (element.type == "binary")) && (element.id == "="))
if (element.first.type == "variable")
state = 2;
continue;
endif
elseif ((((state == 1) || (state == 2)) && (element.type == "unary")) && (element.id == "@"))
if (element.first.type == "variable")
state = 3;
continue;
endif
endif
raise("Syntax error", "Illegal scattering pattern", parser);
endfor
return;
"{parser, pattern} = args;";
"";
"state = 1;";
"";
"for element in (pattern)";
"  if (state == 1 && element.type == \"variable\")";
"    continue;";
"  elseif ((state == 1 || state == 2) && element.type == \"binary\" && element.id == \"=\")";
"    if (element.first.type == \"variable\")";
"      state = 2;";
"      continue;";
"    endif";
"  elseif ((state == 1 || state == 2) && element.type == \"unary\" && element.id == \"@\")";
"    if (element.first.type == \"variable\")";
"      state = 3;";
"      continue;";
"    endif";
"  endif";
"";
"  raise(\"Syntax error\", \"Illegal scattering pattern\", parser);";
"endfor";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6DC3B53967446EAB01EE576267459D8598505807";
"-=-=-mxyzptlk-=-=-";
.
#29:3
{node} = args;
if (typeof(node) == LIST)
return node;
elseif (`typeof(value = node.value) == LIST ! ANY')
return value;
else
children = {};
for prop in ({"first", "second", "third"})
if (`value = node.(prop) ! E_PROPNF => 0' != 0)
children = {@children, value};
endif
endfor
return children;
endif
return;
"{node} = args;";
"";
"/* Intelligently gather children from various places.";
" */";
"";
"if (typeof(node) == LIST)";
"  return node;";
"elseif (`typeof(value = node.value) == LIST ! ANY')";
"  return value;";
"else";
"  children = {};";
"  for prop in ({\"first\", \"second\", \"third\"})";
"    if (`value = node.(prop) ! E_PROPNF => 0' != 0)";
"      children = {@children, value};";
"    endif";
"  endfor";
"  return children;";
"endif";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F9D17E1580E0ABE09BCBB3C38E32B585B4A9FC58";
"-=-=-mxyzptlk-=-=-";
.
#29:4
{root, pattern} = args;
matches = {};
stack = {root};
while (stack)
{top, @stack} = stack;
stack = {@stack, @this:children(top)};
if (((typeof(top) == ANON) && isa(top, this.plastic.symbol_proto)) && (top.id == pattern))
matches = {@matches, top};
endif
endwhile
return matches;
return;
"{root, pattern} = args;";
"";
"/* depth first search for pattern */";
"";
"matches = {};";
"stack = {root};";
"";
"while (stack)";
"  {top, @stack} = stack;";
"  stack = {@stack, @this:children(top)};";
"  if (typeof(top) == ANON && isa(top, this.plastic.symbol_proto) && top.id == pattern)";
"    matches = {@matches, top};";
"  endif";
"endwhile";
"";
"return matches;";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:1C1961865CB075B1E8207A8301802A559E629EFE";
"-=-=-mxyzptlk-=-=-";
.
#30:0
{source, ?options = []} = args;
tokenizer = this.plastic.tokenizer_proto:create(source);
parser = this.plastic.parser_proto:create(tokenizer);
try
statements = parser:statements();
except ex (ANY)
return {0, {tostr("Line ", ex[3].tokenizer.row, ":  ", ex[2])}};
endtry
source = {};
for statement in (statements)
if (statement.type != "statement")
source = {@source, tostr(statement:p(), ";")};
else
source = {@source, @statement:p()};
endif
endfor
return {1, source};
return;
"{source, ?options = []} = args;";
"";
"tokenizer = this.plastic.tokenizer_proto:create(source);";
"parser = this.plastic.parser_proto:create(tokenizer);";
"";
"try";
"  statements = parser:statements();";
"except ex (ANY)";
"  return {0, {tostr(\"Line \", ex[3].tokenizer.row, \":  \", ex[2])}};";
"endtry";
"";
"source = {};";
"";
"for statement in (statements)";
"  if (statement.type != \"statement\")";
"    source = {@source, tostr(statement:p(), \";\")};";
"  else";
"    source = {@source, @statement:p()};";
"  endif";
"endfor";
"";
"return {1, source};";
"";
"chunk_length:22";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0270A24482DAA0150711EDF034EF205C2E123D27";
"-=-=-mxyzptlk-=-=-";
.
#31:0
{statement, ?indent = ""} = args;
if (typeof(statement) == LIST)
result = {tostr(indent, "-")};
for item in (statement)
result = {@result, @this:_print(item, indent + "  ")};
endfor
return result;
endif
if (`typeof(statement.value) == LIST ! ANY')
result = {tostr(indent, statement.id, " : ", statement.type)};
for value in (statement.value)
result = {@result, @this:_print(value, indent + "  ")};
endfor
else
result = {tostr(indent, (typeof(statement.value) == ERR) ? toliteral(statement.value) | statement.value, " : ", statement.type)};
for prop in ({"first", "second", "third"})
if ((`value = statement.(prop) ! E_PROPNF' != E_PROPNF) && (value != 0))
result = {@result, @this:_print(value, indent + "  ")};
endif
endfor
endif
return result;
return;
"{statement, ?indent = \"\"} = args;";
"";
"if (typeof(statement) == LIST)";
"  result = {tostr(indent, \"-\")};";
"";
"  for item in (statement)";
"    result = {@result, @this:_print(item, indent + \"  \")};";
"  endfor";
"";
"  return result;";
"endif";
"";
"if (`typeof(statement.value) == LIST ! ANY')";
"  result = {tostr(indent, statement.id, \" : \", statement.type)};";
"";
"  for value in (statement.value)";
"    result = {@result, @this:_print(value, indent + \"  \")};";
"  endfor";
"else";
"  result = {tostr(indent, typeof(statement.value) == ERR ? toliteral(statement.value) | statement.value, \" : \", statement.type)};";
"";
"  for prop in ({\"first\", \"second\", \"third\"})";
"    if (`value = statement.(prop) ! E_PROPNF' != E_PROPNF && value != 0)";
"      result = {@result, @this:_print(value, indent + \"  \")};";
"    endif";
"  endfor";
"endif";
"";
"return result;";
"";
"chunk_length:29";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:67068C3DEAFED07576F5AE9A4A94AE664A9EF238";
"-=-=-mxyzptlk-=-=-";
.
#31:1
{source, ?options = []} = args;
tokenizer = this.plastic.tokenizer_proto:create(source);
parser = this.plastic.parser_proto:create(tokenizer);
statements = parser:statements();
source = {};
for statement in (statements)
source = {@source, @this:_print(statement)};
endfor
return source;
return;
"{source, ?options = []} = args;";
"";
"tokenizer = this.plastic.tokenizer_proto:create(source);";
"parser = this.plastic.parser_proto:create(tokenizer);";
"";
"statements = parser:statements();";
"";
"source = {};";
"";
"for statement in (statements)";
"  source = {@source, @this:_print(statement)};";
"endfor";
"";
"return source;";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2A38FC7355668CD5D2C874FC93127BF0A0B9F786";
"-=-=-mxyzptlk-=-=-";
.
#32:0
(typeof(this) == ANON) || raise(E_INVARG, "Instances only");
return;
"(typeof(this) == ANON) || raise(E_INVARG, \"Instances only\");";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:14196681E0237855506783C838C9D8D194F00774";
"-=-=-mxyzptlk-=-=-";
.
#32:1
(this == $plastic.tokenizer_proto) || raise(E_PERM, "Call not allowed on instance");
instance = create(this, 1);
instance.row = 1;
instance.column = 1;
instance.source = ((length(args) == 1) && (typeof(args[1]) == LIST)) ? args[1] | args;
return instance;
return;
"(this == $plastic.tokenizer_proto) || raise(E_PERM, \"Call not allowed on instance\");";
"instance = create(this, 1);";
"instance.row = 1;";
"instance.column = 1;";
"instance.source = (length(args) == 1 && typeof(args[1]) == LIST) ? args[1] | args;";
"return instance;";
"";
"chunk_length:6";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:1D01BCCA56B3F461D5DE70912000A57FC725F515";
"-=-=-mxyzptlk-=-=-";
.
#32:2
this:_ensure_instance();
this.token = 0;
if (!this.source)
return this;
endif
row = this.row;
column = this.column;
source = this.source;
comment = 0;
eol = 0;
while loop (length(source) >= row)
if (column > (len = length(source[row])))
row = row + 1;
column = 1;
eol = 1;
continue loop;
endif
if (((len > column) && comment) && (source[row][column..column + 1] == "*/"))
comment = 0;
column = column + 2;
continue loop;
elseif ((len > column) && (source[row][column..column + 1] == "/*"))
comment = 1;
column = column + 2;
continue loop;
endif
if (comment)
column = column + 1;
continue loop;
endif
if ((len >= column) && (((c = source[row][column]) == "      ") || (c == " ")))
column = column + 1;
continue loop;
endif
if (this.token)
this.token["eol"] = eol;
eol = 0;
break loop;
endif
if (`c = source[row][column] ! E_RANGE')
if ((((c >= "a") && (c <= "z")) || (c == "_")) || (c == "$"))
col1 = column;
column = column + 1;
while (`c = source[row][column] ! E_RANGE')
if ((((c >= "a") && (c <= "z")) || ((c >= "0") && (c <= "9"))) || (c == "_"))
column = column + 1;
else
break;
endif
endwhile
col2 = column - 1;
chars = source[row][col1..col2];
if (index(chars, "E_") == 1)
try
this.token = ["type" -> "error", "value" -> this.errors[chars]];
except ex (E_RANGE)
this.token = ["type" -> "error", "value" -> chars, "error" -> tostr("Invalid error: ", chars)];
endtry
else
this.token = ["type" -> "name", "value" -> chars];
endif
continue loop;
elseif (c == "#")
col1 = column;
column = column + 1;
if (`c = source[row][column] ! E_RANGE')
if ((c == "+") || (c == "-"))
column = column + 1;
endif
endif
while (`c = source[row][column] ! E_RANGE')
if ((c >= "0") && (c <= "9"))
column = column + 1;
else
break;
endif
endwhile
col2 = column - 1;
chars = source[row][col1..col2];
if ((chars[$] < "0") || (chars[$] > "9"))
this.token = ["type" -> "object", "value" -> chars, "error" -> "Bad object number"];
elseif ((c >= "a") && (c <= "z"))
this.token = ["type" -> "object", "value" -> chars + c, "error" -> "Bad object number"];
else
this.token = ["type" -> "object", "value" -> toobj(chars)];
endif
continue loop;
elseif ((c >= "0") && (c <= "9"))
FLOAT = 0;
col1 = column;
column = column + 1;
while (`c = source[row][column] ! E_RANGE')
if ((c >= "0") && (c <= "9"))
column = column + 1;
else
break;
endif
endwhile
if ((c == ".") && ((cc = `source[row][column + 1] ! E_RANGE') != "."))
FLOAT = 1;
column = column + 1;
while (`c = source[row][column] ! E_RANGE')
if ((c >= "0") && (c <= "9"))
column = column + 1;
else
break;
endif
endwhile
endif
if (c == "e")
FLOAT = 1;
column = column + 1;
if (`c = source[row][column] ! E_RANGE' && (c in {"-", "+"}))
column = column + 1;
endif
while (`c = source[row][column] ! E_RANGE')
if ((c >= "0") && (c <= "9"))
column = column + 1;
else
break;
endif
endwhile
endif
col2 = column - 1;
chars = source[row][col1..col2];
if (((chars[$] < "0") || (chars[$] > "9")) && (chars[$] != "."))
this.token = ["type" -> "number", "value" -> chars, "error" -> "Bad number"];
elseif ((c >= "a") && (c <= "z"))
this.token = ["type" -> "number", "value" -> chars + c, "error" -> "Bad number"];
else
this.token = ["type" -> "number", "value" -> FLOAT ? tofloat(chars) | toint(chars)];
endif
continue loop;
elseif ((c == "\"") || (c == "'"))
esc = 0;
chars = "";
q = c;
col1 = column;
column = column + 1;
while (`c = source[row][column] ! E_RANGE' && ((c != q) || esc))
column = column + 1;
if ((c != "\\") || esc)
chars = tostr(chars, c);
esc = 0;
else
esc = 1;
endif
endwhile
column = column + 1;
col2 = column - 1;
if (c != q)
this.token = ["type" -> "string", "value" -> source[row][col1..col2 - 1], "error" -> "Unterminated string"];
continue loop;
else
this.token = ["type" -> "string", "value" -> chars];
continue loop;
endif
elseif (index("-<>=*!|&.", c))
col1 = column;
column = column + 1;
if (`c = source[row][column] ! E_RANGE' && index(">=*!|&.", c))
column = column + 1;
this.token = ["type" -> "operator", "value" -> source[row][col1..column - 1]];
continue loop;
else
this.token = ["type" -> "operator", "value" -> source[row][col1]];
continue loop;
endif
else
column = column + 1;
this.token = ["type" -> "operator", "value" -> c];
continue loop;
endif
column = column + 1;
endif
endwhile
this.row = row;
this.column = column;
this.source = source;
if (comment)
this.token = ["type" -> "comment", "value" -> "", "error" -> "Unterminated comment"];
endif
if ((this.token && (this.token["type"] == "name")) && (this.token["value"] == "$"))
this.token["type"] = "operator";
endif
if ((row > length(source)) && this.token)
this.token["eol"] = 1;
endif
return this;
return;
"this:_ensure_instance();";
"";
"this.token = 0;";
"";
"if (!this.source)";
"  return this;";
"endif";
"";
"row = this.row;";
"column = this.column;";
"source = this.source;";
"";
"comment = 0;";
"eol = 0;";
"";
"while loop (length(source) >= row)";
"";
"  if (column > (len = length(source[row])))";
"    row = row + 1;";
"    column = 1;";
"    eol = 1;";
"    continue loop;";
"  endif";
"";
"  if (len > column && comment && source[row][column..column + 1] == \"*/\")";
"    comment = 0;";
"    column = column + 2;";
"    continue loop;";
"  elseif (len > column && source[row][column..column + 1] == \"/*\")";
"    comment = 1;";
"    column = column + 2;";
"    continue loop;";
"  endif";
"";
"  if (comment)";
"    column = column + 1;";
"    continue loop;";
"  endif";
"";
"  if (len >= column && ((c = source[row][column]) == \"      \" || c == \" \"))";
"    column = column + 1;";
"    continue loop;";
"  endif";
"";
"  if (this.token)";
"    this.token[\"eol\"] = eol;";
"    eol = 0;";
"    break loop;";
"  endif";
"";
"  if (`c = source[row][column] ! E_RANGE')";
"";
"    /* name and error */";
"    /* MOO error literals look like names but they're not.  Worse, a";
"     * valid error like E_PERM is treated like a literal, while an";
"     * invalid error like E_FOO is treated like a variable.  Any name";
"     * that starts with the characters \"E_\" is *now* an error literal,";
"     * but invalid errors are errors.";
"     */";
"    if ((c >= \"a\" && c <= \"z\") || c == \"_\" || c == \"$\")";
"      col1 = column; /* mark the start */";
"      column = column + 1;";
"      while (`c = source[row][column] ! E_RANGE')";
"        if ((c >= \"a\" && c <= \"z\") || (c >= \"0\" && c <= \"9\") || c == \"_\")";
"          column = column + 1;";
"        else";
"          break;";
"        endif";
"      endwhile";
"      col2 = column - 1;";
"      chars = source[row][col1..col2];";
"      if (index(chars, \"E_\") == 1)";
"        try";
"          this.token = [\"type\" -> \"error\", \"value\" -> this.errors[chars]];";
"        except ex (E_RANGE)";
"          this.token = [\"type\" -> \"error\", \"value\" -> chars, \"error\" -> tostr(\"Invalid error: \", chars)];";
"        endtry";
"      else";
"        this.token = [\"type\" -> \"name\", \"value\" -> chars];";
"      endif";
"      continue loop;";
"";
"    /* object number */";
"    elseif (c == \"#\")";
"      col1 = column; /* mark the start */";
"      column = column + 1;";
"      if (`c = source[row][column] ! E_RANGE')";
"        if (c == \"+\" || c == \"-\")";
"          column = column + 1;";
"        endif";
"      endif";
"      while (`c = source[row][column] ! E_RANGE')";
"        if (c >= \"0\" && c <= \"9\")";
"          column = column + 1;";
"        else";
"          break;";
"        endif";
"      endwhile";
"      col2 = column - 1;";
"      chars = source[row][col1..col2];";
"      if (chars[$] < \"0\" || chars[$] > \"9\")";
"        this.token = [\"type\" -> \"object\", \"value\" -> chars, \"error\" -> \"Bad object number\"];";
"      elseif (c >= \"a\" && c <= \"z\")";
"        this.token = [\"type\" -> \"object\", \"value\" -> chars + c, \"error\" -> \"Bad object number\"];";
"      else";
"        this.token = [\"type\" -> \"object\", \"value\" -> toobj(chars)];";
"      endif";
"      continue loop;";
"";
"    /* number */";
"    elseif (c >= \"0\" && c <= \"9\")";
"      float = 0;";
"      col1 = column; /* mark the start */";
"      column = column + 1;";
"      while (`c = source[row][column] ! E_RANGE')";
"        if (c >= \"0\" && c <= \"9\")";
"          column = column + 1;";
"        else";
"          break;";
"        endif";
"      endwhile";
"      if (c == \".\" && ((cc = `source[row][column + 1] ! E_RANGE') != \".\")) /* not `..' */";
"        float = 1;";
"        column = column + 1;";
"        while (`c = source[row][column] ! E_RANGE')";
"          if (c >= \"0\" && c <= \"9\")";
"            column = column + 1;";
"          else";
"            break;";
"          endif";
"        endwhile";
"      endif";
"      if (c == \"e\")";
"        float = 1;";
"        column = column + 1;";
"        if (`c = source[row][column] ! E_RANGE' && c in {\"-\", \"+\"})";
"          column = column + 1;";
"        endif";
"        while (`c = source[row][column] ! E_RANGE')";
"          if (c >= \"0\" && c <= \"9\")";
"            column = column + 1;";
"          else";
"            break;";
"          endif";
"        endwhile";
"      endif";
"      col2 = column - 1;";
"      chars = source[row][col1..col2];";
"      if ((chars[$] < \"0\" || chars[$] > \"9\") && chars[$] != \".\")";
"        this.token = [\"type\" -> \"number\", \"value\" -> chars, \"error\" -> \"Bad number\"];";
"      elseif (c >= \"a\" && c <= \"z\")";
"        this.token = [\"type\" -> \"number\", \"value\" -> chars + c, \"error\" -> \"Bad number\"];";
"      else";
"        this.token = [\"type\" -> \"number\", \"value\" -> float ? tofloat(chars) | toint(chars)];";
"      endif";
"      continue loop;";
"";
"    /* string */";
"    elseif (c == \"\\\"\" || c == \"'\")";
"      esc = 0;";
"      chars = \"\";";
"      q = c;";
"      col1 = column; /* mark the start */";
"      column = column + 1;";
"      while (`c = source[row][column] ! E_RANGE' && (c != q || esc))";
"        column = column + 1;";
"        if (c != \"\\\\\" || esc)";
"          chars = tostr(chars, c);";
"          esc = 0;";
"        else";
"          esc = 1;";
"        endif";
"      endwhile";
"      column = column + 1;";
"      col2 = column - 1;";
"      if (c != q)";
"        this.token = [\"type\" -> \"string\", \"value\" -> source[row][col1..col2 - 1], \"error\" -> \"Unterminated string\"];";
"        continue loop;";
"      else";
"        this.token = [\"type\" -> \"string\", \"value\" -> chars];";
"        continue loop;";
"      endif";
"";
"    /* possible multi-character operator */";
"    elseif (index(\"-<>=*!|&.\", c))";
"      col1 = column; /* mark the start */";
"      column = column + 1;";
"      if (`c = source[row][column] ! E_RANGE' && index(\">=*!|&.\", c))";
"        column = column + 1;";
"        this.token = [\"type\" -> \"operator\", \"value\" -> source[row][col1..column - 1]];";
"        continue loop;";
"      else";
"        this.token = [\"type\" -> \"operator\", \"value\" -> source[row][col1]];";
"        continue loop;";
"      endif";
"";
"    /* operator */";
"    else";
"      column = column + 1;";
"      this.token = [\"type\" -> \"operator\", \"value\" -> c];";
"      continue loop;";
"";
"    endif";
"";
"    column = column + 1;";
"  endif";
"endwhile";
"";
"this.row = row;";
"this.column = column;";
"this.source = source;";
"";
"/* check for unterminated comment */";
"if (comment)";
"  this.token = [\"type\" -> \"comment\", \"value\" -> \"\", \"error\" -> \"Unterminated comment\"];";
"endif";
"";
"/* dollar sign by itself is not a name */";
"if (this.token && this.token[\"type\"] == \"name\" && this.token[\"value\"] == \"$\")";
"  this.token[\"type\"] = \"operator\";";
"endif";
"";
"/* catch the last token */";
"if (row > length(source) && this.token)";
"  this.token[\"eol\"] = 1;";
"endif";
"";
"return this;";
"";
"chunk_length:228";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C5FF8B6B188A762B219FF8DC0FEB30911A9397D4";
"-=-=-mxyzptlk-=-=-";
.
#32:3
this:_ensure_instance();
return this.token;
return;
"this:_ensure_instance();";
"";
"return this.token;";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:88791DF01E1D0711F700234B78C3BA4184A82F47";
"-=-=-mxyzptlk-=-=-";
.
#33:0
(typeof(this) == ANON) || raise(E_INVARG, "Instances only");
return;
"(typeof(this) == ANON) || raise(E_INVARG, \"Instances only\");";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:14196681E0237855506783C838C9D8D194F00774";
"-=-=-mxyzptlk-=-=-";
.
#33:1
{tokenizer, @options} = args;
(this == $plastic.parser_proto) || raise(E_PERM, "Call not allowed on instance");
instance = create(this, 1);
instance.tokenizer = tokenizer;
instance.symbols = [];
plastic = this.plastic;
instance:symbol("(end)");
instance:symbol("(name)", 0, plastic.name_proto);
instance:symbol("(literal)", 0, plastic.literal_proto);
instance:symbol(";", 0, plastic.operator_proto);
instance:symbol(",", 0, plastic.operator_proto);
instance:symbol("]", 0, plastic.operator_proto);
instance:symbol("}", 0, plastic.operator_proto);
instance:symbol("->", 0, plastic.operator_proto);
instance:symbol("=>", 0, plastic.operator_proto);
instance:symbol("..", 0, plastic.operator_proto);
instance:symbol("|", 0, plastic.operator_proto);
instance:symbol("`", 0, plastic.operator_proto);
instance:symbol("!", 0, plastic.prefix_operator_proto);
instance:symbol("=", 100, plastic.assignment_operator_proto);
instance:symbol("!!", 200, plastic.error_catching_operator_proto);
instance:symbol("?", 200, plastic.traditional_ternary_operator_proto);
instance:symbol("&&", 300, plastic.infix_operator_proto);
instance:symbol("||", 300, plastic.infix_operator_proto);
instance:symbol("!=", 400, plastic.infix_operator_proto);
instance:symbol("==", 400, plastic.infix_operator_proto);
instance:symbol("<", 400, plastic.infix_operator_proto);
instance:symbol("<=", 400, plastic.infix_operator_proto);
instance:symbol(">", 400, plastic.infix_operator_proto);
instance:symbol(">=", 400, plastic.infix_operator_proto);
instance:symbol("in", 400, plastic.infix_operator_proto);
instance:symbol("+", 500, plastic.sign_operator_proto);
instance:symbol("-", 500, plastic.sign_operator_proto);
instance:symbol("*", 600, plastic.infix_operator_proto);
instance:symbol("/", 600, plastic.infix_operator_proto);
instance:symbol("%", 600, plastic.infix_operator_proto);
instance:symbol("**", 650, plastic.infix_operator_proto);
instance:symbol("[", 800, plastic.bracket_operator_proto);
instance:symbol("{", 0, plastic.brace_operator_proto);
instance:symbol("return", 0, plastic.control_flow_statement_proto);
instance:symbol("break", 0, plastic.control_flow_statement_proto);
instance:symbol("continue", 0, plastic.control_flow_statement_proto);
instance:symbol("if", 0, plastic.if_statement_proto);
instance:symbol("for", 0, plastic.for_statement_proto);
instance:symbol("while", 0, plastic.loop_statement_proto);
instance:symbol("until", 0, plastic.loop_statement_proto);
instance:symbol("fork", 0, plastic.fork_statement_proto);
instance:symbol("try", 0, plastic.try_statement_proto);
instance:symbol(":", 800, plastic.verb_selector_operator_proto);
instance:symbol(".", 800, plastic.property_selector_operator_proto);
instance:symbol("(", 800, plastic.invocation_operator_proto);
instance:symbol(")", 0, plastic.operator_proto);
return instance;
return;
"{tokenizer, @options} = args;";
"(this == $plastic.parser_proto) || raise(E_PERM, \"Call not allowed on instance\");";
"instance = create(this, 1);";
"instance.tokenizer = tokenizer;";
"instance.symbols = [];";
"";
"plastic = this.plastic;";
"";
"/* `(end)' is required */";
"instance:symbol(\"(end)\");";
"instance:symbol(\"(name)\", 0, plastic.name_proto);";
"instance:symbol(\"(literal)\", 0, plastic.literal_proto);";
"instance:symbol(\";\", 0, plastic.operator_proto);";
"instance:symbol(\",\", 0, plastic.operator_proto);";
"instance:symbol(\"]\", 0, plastic.operator_proto);";
"instance:symbol(\"}\", 0, plastic.operator_proto);";
"instance:symbol(\"->\", 0, plastic.operator_proto);";
"instance:symbol(\"=>\", 0, plastic.operator_proto);";
"instance:symbol(\"..\", 0, plastic.operator_proto);";
"instance:symbol(\"|\", 0, plastic.operator_proto);";
"instance:symbol(\"`\", 0, plastic.operator_proto);";
"instance:symbol(\"!\", 0, plastic.prefix_operator_proto);";
"instance:symbol(\"=\", 100, plastic.assignment_operator_proto);";
"instance:symbol(\"!!\", 200, plastic.error_catching_operator_proto);";
"instance:symbol(\"?\", 200, plastic.traditional_ternary_operator_proto);";
"instance:symbol(\"&&\", 300, plastic.infix_operator_proto);";
"instance:symbol(\"||\", 300, plastic.infix_operator_proto);";
"instance:symbol(\"!=\", 400, plastic.infix_operator_proto);";
"instance:symbol(\"==\", 400, plastic.infix_operator_proto);";
"instance:symbol(\"<\", 400, plastic.infix_operator_proto);";
"instance:symbol(\"<=\", 400, plastic.infix_operator_proto);";
"instance:symbol(\">\", 400, plastic.infix_operator_proto);";
"instance:symbol(\">=\", 400, plastic.infix_operator_proto);";
"instance:symbol(\"in\", 400, plastic.infix_operator_proto);";
"instance:symbol(\"+\", 500, plastic.sign_operator_proto);";
"instance:symbol(\"-\", 500, plastic.sign_operator_proto);";
"instance:symbol(\"*\", 600, plastic.infix_operator_proto);";
"instance:symbol(\"/\", 600, plastic.infix_operator_proto);";
"instance:symbol(\"%\", 600, plastic.infix_operator_proto);";
"instance:symbol(\"**\", 650, plastic.infix_operator_proto);";
"instance:symbol(\"[\", 800, plastic.bracket_operator_proto);";
"instance:symbol(\"{\", 0, plastic.brace_operator_proto); /* never bind left */";
"instance:symbol(\"return\", 0, plastic.control_flow_statement_proto);";
"instance:symbol(\"break\", 0, plastic.control_flow_statement_proto);";
"instance:symbol(\"continue\", 0, plastic.control_flow_statement_proto);";
"instance:symbol(\"if\", 0, plastic.if_statement_proto);";
"instance:symbol(\"for\", 0, plastic.for_statement_proto);";
"instance:symbol(\"while\", 0, plastic.loop_statement_proto);";
"instance:symbol(\"until\", 0, plastic.loop_statement_proto);";
"instance:symbol(\"fork\", 0, plastic.fork_statement_proto);";
"instance:symbol(\"try\", 0, plastic.try_statement_proto);";
"instance:symbol(\":\", 800, plastic.verb_selector_operator_proto);";
"instance:symbol(\".\", 800, plastic.property_selector_operator_proto);";
"/* the infix form is function/verb invocation */";
"instance:symbol(\"(\", 800, plastic.invocation_operator_proto);";
"instance:symbol(\")\", 0, plastic.operator_proto);";
"";
"return instance;";
"";
"chunk_length:58";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:8A51E1FDD3FB4F8F64660C79CDBBB3B022F337DB";
"-=-=-mxyzptlk-=-=-";
.
#33:2
this:_ensure_instance();
{id, ?bp = 0, ?proto = $nothing, ?options = []} = args;
proto = valid(proto) ? proto | this.plastic.symbol_proto;
if ((symbol = `this.symbols[id] ! E_RANGE') == E_RANGE)
symbol = proto:create(id, bp, options);
endif
this.symbols[id] = symbol;
return symbol;
return;
"this:_ensure_instance();";
"{id, ?bp = 0, ?proto = $nothing, ?options = []} = args;";
"proto = valid(proto) ? proto | this.plastic.symbol_proto;";
"if ((symbol = `this.symbols[id] ! E_RANGE') == E_RANGE)";
"  symbol = proto:create(id, bp, options);";
"endif";
"this.symbols[id] = symbol;";
"return symbol;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9E52D6826BB4B9E6C3D3A83D7D7412877D54A67E";
"-=-=-mxyzptlk-=-=-";
.
#33:3
this:_ensure_instance();
{symbol} = args;
id = symbol.id;
if ((((type = this.symbols[id].type) != "name") && (type != "statement")) && (type != "keyword"))
an_or_a = index("aeiou", type[1]) ? "an" | "a";
raise("Syntax error", tostr("`", id, "' is ", an_or_a, " ", type), this);
endif
symbol.reserved = 1;
symbol.type = verb[9..$];
this.symbols[id] = symbol;
return;
"this:_ensure_instance();";
"";
"{symbol} = args;";
"";
"id = symbol.id;";
"";
"/* raise error if this symbol is not a name, statement or keyword */";
"if ((type = this.symbols[id].type) != \"name\" && type != \"statement\" && type != \"keyword\")";
"  an_or_a = index(\"aeiou\", type[1]) ? \"an\" | \"a\";";
"  raise(\"Syntax error\", tostr(\"`\", id, \"' is \", an_or_a, \" \", type), this);";
"endif";
"";
"symbol.reserved = 1;";
"symbol.type = verb[9..$];";
"";
"this.symbols[id] = symbol;";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:30FF331C48ABA887B3E4EA3C3F504A11766557C7";
"-=-=-mxyzptlk-=-=-";
.
#33:4
this:_ensure_instance();
{symbol} = args;
id = symbol.id;
if (this.symbols[id].reserved)
raise("Syntax error", tostr("`", id, "' is reserved"), this);
endif
symbol.reserved = 0;
symbol.type = verb[6..$];
this.symbols[id] = symbol;
return;
"this:_ensure_instance();";
"";
"{symbol} = args;";
"";
"id = symbol.id;";
"";
"/* raise error if this symbol is reserved */";
"if (this.symbols[id].reserved)";
"  raise(\"Syntax error\", tostr(\"`\", id, \"' is reserved\"), this);";
"endif";
"";
"symbol.reserved = 0;";
"symbol.type = verb[6..$];";
"";
"this.symbols[id] = symbol;";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:042DC6E0D3EBAFDB0EF12619B3D637CF3713DDB9";
"-=-=-mxyzptlk-=-=-";
.
#33:5
this:_ensure_instance();
{?ttid = 0} = args;
if (this.token == 0)
this.tokenizer:advance();
token = this.tokenizer.token;
if (token)
type = token["type"];
value = token["value"];
eol = token["eol"];
if (`token["error"] ! E_RANGE')
raise("Syntax error", token["error"], this);
elseif ((((type == "number") || (type == "string")) || (type == "object")) || (type == "error"))
symbol = this:symbol("(literal)");
this.token = symbol:clone();
this.token.type = type;
this.token.value = value;
this.token.eol = eol;
elseif (type == "operator")
if ((symbol = `this.symbols[value] ! E_RANGE') == E_RANGE)
raise("Syntax error", tostr("Unknown operator:  `", value, "'"), this);
endif
this.token = symbol:clone();
this.token.type = "operator";
this.token.value = value;
this.token.eol = eol;
elseif (type == "name")
id = value;
if ((symbol = `this.symbols[id] ! E_RANGE') != E_RANGE)
this.token = symbol:clone();
this.symbols[id] = this.token;
this.token.type = symbol.type || "name";
this.token.id = id;
this.token.value = value;
this.token.eol = eol;
else
symbol = this:symbol("(name)");
this.token = symbol:clone();
this.symbols[id] = this.token;
this.token.type = "name";
this.token.id = id;
this.token.value = value;
this.token.eol = eol;
endif
else
raise("Syntax error", "Unexpected token", this);
endif
else
symbol = this:symbol("(end)");
this.token = symbol:clone();
endif
endif
if (ttid)
this:advance(ttid);
endif
return this.token;
return;
"this:_ensure_instance();";
"";
"{?ttid = 0} = args;";
"";
"if (this.token == 0)";
"  this.tokenizer:advance();";
"  token = this.tokenizer.token;";
"  if (token)";
"    type = token[\"type\"];";
"    value = token[\"value\"];";
"    eol = token[\"eol\"];";
"    if (`token[\"error\"] ! E_RANGE')";
"      raise(\"Syntax error\", token[\"error\"], this);";
"    elseif (type == \"number\" || type == \"string\" || type == \"object\" || type == \"error\")";
"      symbol = this:symbol(\"(literal)\");";
"      this.token = symbol:clone();";
"      this.token.type = type;";
"      this.token.value = value;";
"      this.token.eol = eol;";
"    elseif (type == \"operator\")";
"      /* Update the symbol table itself and give the operator the";
"       * initial type \"operator\" (the type will change to \"unary\",";
"       * \"binary\" or \"ternary\" when we learn how this symbol is used in";
"       * the program).";
"       */";
"      /* check the symbol table */";
"      if ((symbol = `this.symbols[value] ! E_RANGE') == E_RANGE)";
"        raise(\"Syntax error\", tostr(\"Unknown operator:  `\", value, \"'\"), this);";
"      endif";
"      this.token = symbol:clone();";
"      this.token.type = \"operator\";";
"      this.token.value = value;";
"      this.token.eol = eol;";
"    elseif (type == \"name\")";
"      /* Update the symbol table itself and give the name the initial";
"       * type \"name\" (the type will change to \"variable\", \"identifier\",";
"       * \"statement\" or \"keyword\" when we learn how this symbol is used";
"       * in the program).";
"       */";
"      id = value;";
"      /* peek into the symbol table */";
"      if ((symbol = `this.symbols[id] ! E_RANGE') != E_RANGE)";
"        this.token = symbol:clone();";
"        this.symbols[id] = this.token;";
"        this.token.type = symbol.type || \"name\";";
"        this.token.id = id;";
"        this.token.value = value;";
"        this.token.eol = eol;";
"      else";
"        symbol = this:symbol(\"(name)\");";
"        this.token = symbol:clone();";
"        this.symbols[id] = this.token;";
"        this.token.type = \"name\";";
"        this.token.id = id;";
"        this.token.value = value;";
"        this.token.eol = eol;";
"      endif";
"    else";
"      raise(\"Syntax error\", \"Unexpected token\", this);";
"    endif";
"  else";
"    symbol = this:symbol(\"(end)\");";
"    this.token = symbol:clone();";
"  endif";
"endif";
"";
"if (ttid)";
"  this:advance(ttid);";
"endif";
"";
"return this.token;";
"";
"chunk_length:71";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:8990F10DAF5DAA9809246B0C80A84CB33D4B8A9C";
"-=-=-mxyzptlk-=-=-";
.
#33:6
this:_ensure_instance();
{?id = 0} = args;
if ((id && (this.token != 0)) && (this.token.id != id))
raise("Syntax error", tostr("Expected `", id, "'"), this);
endif
this.token = 0;
return this;
return;
"this:_ensure_instance();";
"";
"{?id = 0} = args;";
"";
"/* raise error if token doesn't match expectation */";
"if (id && this.token != 0 && this.token.id != id)";
"  raise(\"Syntax error\", tostr(\"Expected `\", id, \"'\"), this);";
"endif";
"";
"this.token = 0;";
"";
"return this;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B578DF8B4CC8A8272EE8533436189DC247950745";
"-=-=-mxyzptlk-=-=-";
.
#33:7
this:_ensure_instance();
{?bp = 0} = args;
token = this:token();
this:advance();
if (token.id == "(end)")
return token;
endif
left = token:nud(this);
while (bp < this:token().bp)
token = this:token();
this:advance();
left = token:led(this, left);
endwhile
return left;
return;
"this:_ensure_instance();";
"";
"{?bp = 0} = args;";
"";
"token = this:token();";
"this:advance();";
"";
"/* don't call `nud()' and/or `led()' on `(end)' */";
"if (token.id == \"(end)\")";
"  return token;";
"endif";
"";
"left = token:nud(this);";
"";
"while (bp < this:token().bp)";
"  token = this:token();";
"  this:advance();";
"  left = token:led(this, left);";
"endwhile";
"";
"return left;";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4FCEE2BDC91003E3A441A305F2520E18330E0ECE";
"-=-=-mxyzptlk-=-=-";
.
#33:8
this:_ensure_instance();
token = this:token();
while (token.id == ";")
this:advance();
token = this:token();
endwhile
if (respond_to(token, "std"))
this:advance();
return token:std(this);
else
expression = this:expression();
if (this:token().id == ";")
this:advance();
endif
return expression;
endif
return;
"this:_ensure_instance();";
"";
"token = this:token();";
"";
"/* disregarded naked semicolons */";
"while (token.id == \";\")";
"  this:advance();";
"  token = this:token();";
"endwhile";
"";
"/* either the beginning of a statement */";
"/* or an expression with an optional semicolon */";
"if (respond_to(token, \"std\"))";
"  this:advance();";
"  return token:std(this);";
"else";
"  expression = this:expression();";
"  if (this:token().id == \";\")";
"    this:advance();";
"  endif";
"  return expression;";
"endif";
"";
"chunk_length:22";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A633F2B8764F84393F61203601572D48B1D56CCE";
"-=-=-mxyzptlk-=-=-";
.
#33:9
this:_ensure_instance();
terminals = args;
statements = {};
while (1)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
token = this:token();
if ((token.id == "(end)") || ((token.type in {"name", "statement", "keyword"}) && (token.value in terminals)))
break;
endif
statement = this:statement();
if (statement.id == "(end)")
break;
endif
statements = {@statements, statement};
endwhile
return statements;
return;
"this:_ensure_instance();";
"";
"terminals = args;";
"";
"statements = {};";
"";
"while (1)";
"  ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"";
"  token = this:token();";
"  if (token.id == \"(end)\" || ((token.type in {\"name\", \"statement\", \"keyword\"}) && token.value in terminals))";
"    break;";
"  endif";
"  statement = this:statement();";
"  if (statement.id == \"(end)\")";
"    break;";
"  endif";
"  statements = {@statements, statement};";
"endwhile";
"";
"return statements;";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D0E8B44C7B2EDD26C2871780017456A1F7B79DDE";
"-=-=-mxyzptlk-=-=-";
.
#33:10
this:_ensure_instance();
variables = {};
for symbol in (this.symbols)
if (symbol.type == "variable")
variables = {@variables, symbol};
endif
endfor
return variables;
return;
"this:_ensure_instance();";
"";
"variables = {};";
"";
"for symbol in (this.symbols)";
"  if (symbol.type == \"variable\")";
"    variables = {@variables, symbol};";
"  endif";
"endfor";
"";
"return variables;";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:1EED890E1663FED99638C19E4E9B0FB268626A1F";
"-=-=-mxyzptlk-=-=-";
.
#33:11
this:_ensure_instance();
definition = args;
{id, @rest} = definition;
new = 0;
if (`this.symbols[id] ! E_RANGE' == E_RANGE)
this:symbol(@definition);
new = 1;
endif
return {new, id};
return;
"this:_ensure_instance();";
"";
"definition = args;";
"{id, @rest} = definition;";
"";
"new = 0;";
"";
"if (`this.symbols[id] ! E_RANGE' == E_RANGE)";
"  this:symbol(@definition);";
"  new = 1;";
"endif";
"";
"return {new, id};";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4781098C110B4FFF668FD2A18CBD3BD8AFB62823";
"-=-=-mxyzptlk-=-=-";
.
#33:12
this:_ensure_instance();
{args} = args;
{new, id} = args;
if (new)
this.symbols = this.symbols:delete(id);
endif
return;
"this:_ensure_instance();";
"";
"{args} = args;";
"{new, id} = args;";
"";
"if (new)";
"  this.symbols = this.symbols:delete(id);";
"endif";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0694833C1581AAE25EFCBB39D68E09A5C5EECD56";
"-=-=-mxyzptlk-=-=-";
.
#34:0
{id, ?bp = 0, ?opts = []} = args;
(typeof(this) == OBJ) || raise(E_PERM, "Call not allowed on anonymous object");
instance = create(this, 1);
instance.id = id;
instance.value = id;
instance.bp = bp;
return instance;
return;
"{id, ?bp = 0, ?opts = []} = args;";
"(typeof(this) == OBJ) || raise(E_PERM, \"Call not allowed on anonymous object\");";
"instance = create(this, 1);";
"instance.id = id;";
"instance.value = id;";
"instance.bp = bp;";
"return instance;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:8E35C831EFCD97C46451641720077F8ED2054720";
"-=-=-mxyzptlk-=-=-";
.
#34:1
(typeof(this) == OBJ) && raise(E_PERM, "Call not allowed on permanent object");
parents = parents(this);
instance = create(parents, 1);
for ancestor in (ancestors(this))
for property in (`properties(ancestor) ! E_PERM => {}')
instance.(property) = this.(property);
endfor
endfor
return instance;
return;
"(typeof(this) == OBJ) && raise(E_PERM, \"Call not allowed on permanent object\");";
"parents = parents(this);";
"instance = create(parents, 1);";
"for ancestor in (ancestors(this))";
"  for property in (`properties(ancestor) ! E_PERM => {}')";
"    instance.(property) = this.(property);";
"  endfor";
"endfor";
"return instance;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4D2593BDDD8F59910175EAE7CB5A6545EF0EAFAD";
"-=-=-mxyzptlk-=-=-";
.
#34:2
{parser} = args;
raise("Syntax error", tostr("Undefined: ", this.id), parser);
return;
"{parser} = args;";
"raise(\"Syntax error\", tostr(\"Undefined: \", this.id), parser);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:68DC710F510F0E7CC805B4B86840E071693713E8";
"-=-=-mxyzptlk-=-=-";
.
#34:3
{parser, _} = args;
raise("Syntax error", tostr("Missing operator: ", this.id), parser);
return;
"{parser, _} = args;";
"raise(\"Syntax error\", tostr(\"Missing operator: \", this.id), parser);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:18A6698FEADF4FF80C0F7CAFE90F2DB32EC68A5F";
"-=-=-mxyzptlk-=-=-";
.
#34:4
raise("Unprintable");
return;
"raise(\"Unprintable\");";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:ADC54EDAAD2EFCC7897EAC67B6FC0AD7804CE016";
"-=-=-mxyzptlk-=-=-";
.
#35:0
return this;
return;
"return this;";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:58CFE4977A49A7695FEE4D2F29BB87606D70E92F";
"-=-=-mxyzptlk-=-=-";
.
#35:1
return toliteral(this.value);
return;
"return toliteral(this.value);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:DB76997F4A00C9639DAF3A48D191DCC559BC0CB9";
"-=-=-mxyzptlk-=-=-";
.
#36:0
{parser} = args;
parser:make_variable(this);
return this;
return;
"{parser} = args;";
"";
"/* Assume the name is a variable.  Subsequent usage may modify this";
" * assumption.";
" */";
"parser:make_variable(this);";
"";
"return this;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F8A8CBE63AC0F570B02EEC72ABA071DFFC348D70";
"-=-=-mxyzptlk-=-=-";
.
#36:1
return (((this.type == "variable") && (!(this.value in this.builtin_names))) && (this.value[1] != "$")) ? tostr("_", this.value) | this.value;
return;
"return (this.type == \"variable\" && !(this.value in this.builtin_names) && this.value[1] != \"$\") ? tostr(\"_\", this.value) | this.value;";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:98F690E0415AAC471478E3F65580A0F2264A4EE3";
"-=-=-mxyzptlk-=-=-";
.
#37:0
{parser} = args;
raise("Syntax error", "Undefined", parser);
return;
"{parser} = args;";
"raise(\"Syntax error\", \"Undefined\", parser);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F2A4DE7467B49F34B0185D83E9DB7CC26D24EBDE";
"-=-=-mxyzptlk-=-=-";
.
#39:0
{parser} = args;
if ((this.id != "return") && (parser.loop_depth < 1))
raise("Syntax error", tostr("No enclosing loop for ", this.id), parser);
endif
parser:reserve_statement(this);
if ((!this.eol) && (parser:token().id != ";"))
expression = parser:expression(0);
this.first = expression;
endif
if ((this.id != "return") && (this.first != 0))
if (this.first.type != "variable")
raise("Syntax error", "Loop name must be a name", parser);
endif
if (!(this.first.value in parser.loop_variables))
raise("Syntax error", tostr("Invalid loop name for ", this.id), parser);
endif
endif
if (parser:token().id == ";")
parser:advance(";");
endif
return this;
return;
"{parser} = args;";
"";
"if (this.id != \"return\" && parser.loop_depth < 1)";
"  raise(\"Syntax error\", tostr(\"No enclosing loop for \", this.id), parser);";
"endif";
"";
"/* update the symbol table */";
"parser:reserve_statement(this);";
"";
"if (!this.eol && parser:token().id != \";\")";
"  expression = parser:expression(0);";
"  this.first = expression;";
"endif";
"";
"if (this.id != \"return\" && this.first != 0)";
"  if (this.first.type != \"variable\")";
"    raise(\"Syntax error\", \"Loop name must be a name\", parser);";
"  endif";
"  if (!(this.first.value in parser.loop_variables))";
"    raise(\"Syntax error\", tostr(\"Invalid loop name for \", this.id), parser);";
"  endif";
"endif";
"";
"if (parser:token().id == \";\")";
"  parser:advance(\";\");";
"endif";
"";
"return this;";
"";
"chunk_length:28";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:418293156AC1D9BE243C39A3EC9F3B7FFBE4CDD5";
"-=-=-mxyzptlk-=-=-";
.
#39:1
if (this.type == "variable")
return tostr("_", this.id);
endif
if ((first = this.first) != 0)
return {tostr(this.id, " ", first:p(), ";")};
else
return {tostr(this.id, ";")};
endif
return;
"if (this.type == \"variable\")";
"  return tostr(\"_\", this.id);";
"endif";
"";
"if ((first = this.first) != 0)";
"  return {tostr(this.id, \" \" , first:p(), \";\")};";
"else";
"  return {tostr(this.id, \";\")};";
"endif";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0EFEDFDD5665B7BCE65D14F66A9B94F132DABBC6";
"-=-=-mxyzptlk-=-=-";
.
#40:0
{parser, first} = args;
right = this.right && 1;
second = parser:expression(this.bp - right);
if (second.id == "(end)")
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "binary";
this.first = first;
this.second = second;
return this;
return;
"{parser, first} = args;";
"";
"right = this.right && 1; /* does this operator associate to the right? */";
"";
"second = parser:expression(this.bp - right);";
"";
"if (second.id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an expression\", parser);";
"endif";
"";
"this.type = \"binary\";";
"this.first = first;";
"this.second = second;";
"";
"return this;";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5A90918D1650451B6F3F14F2AC74F67C25F382B2";
"-=-=-mxyzptlk-=-=-";
.
#40:1
value = this.value;
value = (value != "**") ? value | "^";
return tostr("(", this.first:p(), " ", value, " ", this.second:p(), ")");
return;
"value = this.value;";
"value = (value != \"**\") ? value | \"^\";";
"return tostr(\"(\", this.first:p(), \" \", value, \" \", this.second:p(), \")\");";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0D618688472E96C035B5CD501206B78B4AD56274";
"-=-=-mxyzptlk-=-=-";
.
#41:0
{parser, first} = args;
if ((first.type == "unary") && (first.id == "{"))
this.plastic.utilities:validate_scattering_pattern(parser, first.value);
first.type = "pattern";
endif
if ((((first.type != "variable") && (first.type != "pattern")) && (first.id != ".")) && (first.id != "["))
raise("Syntax error", "Illegal expression on left side of assignment", parser);
endif
second = parser:expression(this.bp - 1);
if (second.id == "(end)")
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "binary";
this.first = first;
this.second = second;
return this;
return;
"{parser, first} = args;";
"";
"if (first.type == \"unary\" && first.id == \"{\") /* scattering syntax */";
"  this.plastic.utilities:validate_scattering_pattern(parser, first.value);";
"  first.type = \"pattern\";";
"endif";
"";
"if (first.type != \"variable\" && first.type != \"pattern\" && first.id != \".\" && first.id != \"[\")";
"  raise(\"Syntax error\", \"Illegal expression on left side of assignment\", parser);";
"endif";
"";
"second = parser:expression(this.bp - 1);";
"";
"if (second.id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an expression\", parser);";
"endif";
"";
"this.type = \"binary\";";
"this.first = first;";
"this.second = second;";
"";
"return this;";
"";
"chunk_length:22";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F0969021843EDF73519565F7131A329F32CD2DF5";
"-=-=-mxyzptlk-=-=-";
.
#41:1
if (this.first.type == "pattern")
res = "{";
rest = 0;
for v in (this.first.value)
if (v.type == "unary")
v = tostr("@", v.first:p());
elseif (v.type == "binary")
v = tostr("?", v.first:p(), " = ", v.second:p());
else
v = v:p();
endif
res = tostr(res, rest ? ", " | "", v);
rest = 1;
endfor
res = tostr(res, "}");
return tostr("(", res, " ", this.value, " ", this.second:p(), ")");
else
return pass(@args);
endif
return;
"if (this.first.type == \"pattern\")";
"  res = \"{\";";
"  rest = 0;";
"  for v in (this.first.value)";
"    if (v.type == \"unary\")";
"      v = tostr(\"@\", v.first:p());";
"    elseif (v.type == \"binary\")";
"      v = tostr(\"?\", v.first:p(), \" = \", v.second:p());";
"    else";
"      v = v:p();";
"    endif";
"    res = tostr(res, (rest ? \", \" | \"\"), v);";
"    rest = 1;";
"  endfor";
"  res = tostr(res, \"}\");";
"  return tostr(\"(\", res, \" \", this.value, \" \", this.second:p(), \")\");";
"else";
"  return pass(@args);";
"endif";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:BF8EBD521A958A28B4A47EBD44F50DF9F7CD6EF9";
"-=-=-mxyzptlk-=-=-";
.
#42:0
{parser} = args;
first = parser:expression(700);
if (first.id == "(end)")
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "unary";
this.first = first;
return this;
return;
"{parser} = args;";
"";
"first = parser:expression(700);";
"";
"if (first.id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an expression\", parser);";
"endif";
"";
"this.type = \"unary\";";
"this.first = first;";
"";
"return this;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:71052EB9A64F517E3CBE29438E498136C830D190";
"-=-=-mxyzptlk-=-=-";
.
#42:1
return tostr(this.value, this.first:p());
return;
"return tostr(this.value, this.first:p());";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9B63BA5327D89CED40BDFF25665737BD53142E9D";
"-=-=-mxyzptlk-=-=-";
.
#43:0
{parser} = args;
sequence = this.plastic.utilities:parse_map_sequence(parser, ",", "->", "]");
parser:token("]");
this.type = "unary";
this.value = sequence;
this.first = this;
return this;
return;
"{parser} = args;";
"";
"sequence = this.plastic.utilities:parse_map_sequence(parser, \",\", \"->\", \"]\");";
"parser:token(\"]\");";
"";
"this.type = \"unary\";";
"this.value = sequence;";
"this.first = this;";
"";
"return this;";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C58ADA1565060D3143B279910446F0D8F39D58CA";
"-=-=-mxyzptlk-=-=-";
.
#43:1
{parser, first} = args;
caret = parser:push("^", 0, $plastic.positional_symbol_proto);
dollar = parser:push("$", 0, $plastic.positional_symbol_proto);
second = parser:expression(0);
if (parser:token().id == "..")
parser:advance("..");
third = parser:expression(0);
parser:advance("]");
this.type = "ternary";
this.first = first;
this.second = second;
this.third = third;
else
parser:advance("]");
this.type = "binary";
this.first = first;
this.second = second;
endif
parser:pop(caret);
parser:pop(dollar);
return this;
return;
"{parser, first} = args;";
"";
"caret = parser:push(\"^\", 0, $plastic.positional_symbol_proto);";
"dollar = parser:push(\"$\", 0, $plastic.positional_symbol_proto);";
"";
"second = parser:expression(0);";
"";
"if (parser:token().id == \"..\")";
"  parser:advance(\"..\");";
"  third = parser:expression(0);";
"  parser:advance(\"]\");";
"  this.type = \"ternary\";";
"  this.first = first;";
"  this.second = second;";
"  this.third = third;";
"else";
"  parser:advance(\"]\");";
"  this.type = \"binary\";";
"  this.first = first;";
"  this.second = second;";
"endif";
"";
"parser:pop(caret);";
"parser:pop(dollar);";
"";
"return this;";
"";
"chunk_length:26";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:FB7CC9F8AFA671BDE463547C02D92587AF6EC603";
"-=-=-mxyzptlk-=-=-";
.
#43:2
if (this.type == "ternary")
return tostr("(", this.first:p(), "[", this.second:p(), "..", this.third:p(), "])");
elseif (this.type == "binary")
return tostr("(", this.first:p(), "[", this.second:p(), "])");
else
res = "[";
first = 1;
for v in (this.value)
res = tostr(res, first ? "" | ", ", v[1]:p(), " -> ", v[2]:p());
first = 0;
endfor
res = tostr(res, "]");
return res;
return {res};
endif
return;
"if (this.type == \"ternary\")";
"  return tostr(\"(\", this.first:p(), \"[\", this.second:p(), \"..\", this.third:p(), \"])\");";
"elseif (this.type == \"binary\")";
"  return tostr(\"(\", this.first:p(), \"[\", this.second:p(), \"])\");";
"else";
"  res = \"[\";";
"  first = 1;";
"  for v in (this.value)";
"    res = tostr(res, (first ? \"\" | \", \"), v[1]:p(), \" -> \", v[2]:p());";
"    first = 0;";
"  endfor";
"  res = tostr(res, \"]\");";
"  return res;";
"  return {res};";
"endif";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:12B975B1409AE8C944A0D89C9058D62EF0DDC261";
"-=-=-mxyzptlk-=-=-";
.
#44:0
{parser} = args;
sequence = this.plastic.utilities:parse_list_sequence(parser, ",", "}");
parser:token("}");
this.type = "unary";
this.value = sequence;
this.first = this;
return this;
return;
"{parser} = args;";
"";
"sequence = this.plastic.utilities:parse_list_sequence(parser, \",\", \"}\");";
"parser:token(\"}\");";
"";
"this.type = \"unary\";";
"this.value = sequence;";
"this.first = this;";
"";
"return this;";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:687E36A53B89521FDC319DA7581CD449862A2BBF";
"-=-=-mxyzptlk-=-=-";
.
#44:1
res = "{";
first = 1;
for v in (this.value)
res = tostr(res, first ? "" | ", ", v:p());
first = 0;
endfor
res = tostr(res, "}");
return res;
return;
"res = \"{\";";
"first = 1;";
"for v in (this.value)";
"  res = tostr(res, (first ? \"\" | \", \"), v:p());";
"  first = 0;";
"endfor";
"res = tostr(res, \"}\");";
"return res;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A0BEB6AA28D239CD26F390A5ED75A31A05E4933A";
"-=-=-mxyzptlk-=-=-";
.
#45:0
{parser} = args;
parser:reserve_statement(this);
a = {};
parser:token("(");
expression = parser:expression(0);
a = {@a, expression};
parser:token(")");
statements = parser:statements("elseif", "else", "endif", "end");
a = {@a, statements};
while (parser:token().id == "elseif")
parser:advance("elseif");
parser:token("(");
expression = parser:expression(0);
a = {@a, expression};
parser:token(")");
statements = parser:statements("elseif", "else", "endif", "end");
a = {@a, statements};
symbol = parser.symbols["elseif"];
parser:reserve_keyword(symbol);
endwhile
if (parser:token().id == "else")
parser:advance("else");
statements = parser:statements("endif", "end");
a = {@a, statements};
symbol = parser.symbols["else"];
parser:reserve_keyword(symbol);
endif
if ((id = parser:token().id) == "endif")
parser:advance("endif");
else
parser:advance("end");
endif
symbol = parser.symbols[id];
parser:reserve_keyword(symbol);
this.value = a;
return this;
return;
"{parser} = args;";
"";
"/* update the symbol table */";
"parser:reserve_statement(this);";
"";
"a = {};";
"";
"/* the predicate */";
"parser:token(\"(\");";
"expression = parser:expression(0);";
"a = {@a, expression};";
"parser:token(\")\");";
"";
"/* the consequent */";
"statements = parser:statements(\"elseif\", \"else\", \"endif\", \"end\");";
"a = {@a, statements};";
"";
"/* the alternatives */";
"while (parser:token().id == \"elseif\")";
"  parser:advance(\"elseif\");";
"";
"  /* predicate */";
"  parser:token(\"(\");";
"  expression = parser:expression(0);";
"  a = {@a, expression};";
"  parser:token(\")\");";
"";
"  /* consequent */";
"  statements = parser:statements(\"elseif\", \"else\", \"endif\", \"end\");";
"  a = {@a, statements};";
"";
"  /* update the symbol table */";
"  symbol = parser.symbols[\"elseif\"];";
"  parser:reserve_keyword(symbol);";
"endwhile";
"";
"/* the final alternative */";
"if (parser:token().id == \"else\")";
"  parser:advance(\"else\");";
"";
"  statements = parser:statements(\"endif\", \"end\");";
"  a = {@a, statements};";
"";
"  /* update the symbol table */";
"  symbol = parser.symbols[\"else\"];";
"  parser:reserve_keyword(symbol);";
"endif";
"";
"/* the last token must be \"endif\" or \"end\" */";
"if ((id = parser:token().id) == \"endif\")";
"  parser:advance(\"endif\");";
"else";
"  parser:advance(\"end\");";
"endif";
"";
"/* update the symbol table */";
"symbol = parser.symbols[id];";
"parser:reserve_keyword(symbol);";
"";
"/* store the parts in this token's `value' */";
"this.value = a;";
"";
"return this;";
"";
"chunk_length:63";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:46F2D54F58E6B9C969243EEFCECA239D22FF4A45";
"-=-=-mxyzptlk-=-=-";
.
#45:1
if (this.type == "variable")
return tostr("_", this.id);
endif
value = this.value;
code = {tostr("if (", value[1]:p(), ")")};
for s in (value[2])
if (respond_to(s, "std"))
code = {@code, @s:p()};
else
code = {@code, s:p() + ";"};
endif
endfor
i = 3;
while ((length(value) >= i) && (typeof(value[i]) != LIST))
code = {@code, tostr("elseif (", value[i]:p(), ")")};
i = i + 1;
for s in (value[i])
if (respond_to(s, "std"))
code = {@code, @s:p()};
else
code = {@code, s:p() + ";"};
endif
endfor
i = i + 1;
endwhile
if (length(value) == i)
code = {@code, "else"};
for s in (value[i])
if (respond_to(s, "std"))
code = {@code, @s:p()};
else
code = {@code, s:p() + ";"};
endif
endfor
endif
code = {@code, "endif"};
return code;
return;
"if (this.type == \"variable\")";
"  return tostr(\"_\", this.id);";
"endif";
"";
"value =  this.value;";
"";
"code = {tostr(\"if (\", value[1]:p(), \")\")};";
"";
"for s in (value[2])";
"  if (respond_to(s, \"std\"))";
"    code = {@code, @s:p()};";
"  else";
"    code = {@code, s:p() + \";\"};";
"  endif";
"endfor";
"";
"i = 3;";
"while (length(value) >= i && typeof(value[i]) != LIST)";
"  code = {@code, tostr(\"elseif (\", value[i]:p(), \")\")};";
"";
"  i = i + 1;";
"";
"  for s in (value[i])";
"    if (respond_to(s, \"std\"))";
"      code = {@code, @s:p()};";
"    else";
"      code = {@code, s:p() + \";\"};";
"    endif";
"  endfor";
"";
"  i = i + 1;";
"endwhile";
"";
"if (length(value) == i)";
"  code = {@code, \"else\"};";
"";
"  for s in (value[i])";
"    if (respond_to(s, \"std\"))";
"      code = {@code, @s:p()};";
"    else";
"      code = {@code, s:p() + \";\"};";
"    endif";
"  endfor";
"endif";
"";
"code = {@code, \"endif\"};";
"";
"return code;";
"";
"chunk_length:48";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E9BB5B7F10C778B6BB4021BECD1F938ED636DF51";
"-=-=-mxyzptlk-=-=-";
.
#46:0
{parser} = args;
expression = parser:expression(0);
parser:token(")");
this.type = "unary";
this.first = expression;
return this;
return;
"{parser} = args;";
"";
"expression = parser:expression(0);";
"parser:token(\")\");";
"";
"this.type = \"unary\";";
"this.first = expression;";
"";
"return this;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:1DDA7B523803C381657DBFCD1FEFBFBAD9085984";
"-=-=-mxyzptlk-=-=-";
.
#46:1
{parser, left} = args;
sequence = this.plastic.utilities:parse_list_sequence(parser, ",", ")");
parser:token(")");
if (left.id == ".")
raise("Syntax error", "Invalid application of invocation", parser);
elseif (left.id == ":")
first = left.first;
second = left.second;
this.type = "ternary";
this.first = first;
this.second = second;
this.third = sequence;
else
if (left.type != "variable")
raise("Syntax error", "Expected an identifier", parser);
endif
parser:make_identifier(left);
this.type = "binary";
this.first = left;
this.second = sequence;
endif
return this;
return;
"{parser, left} = args;";
"";
"sequence =   this.plastic.utilities:parse_list_sequence(parser, \",\", \")\");";
"parser:token(\")\");";
"";
"/* The invocation operator handles function and verb invocation, and";
" * guards against use on properties.";
" */";
"if (left.id == \".\")";
"  raise(\"Syntax error\", \"Invalid application of invocation\", parser);";
"elseif (left.id == \":\")";
"  first = left.first;";
"  second = left.second;";
"";
"  /* the verb selector operator has our back */";
"";
"  this.type = \"ternary\";";
"  this.first = first;";
"  this.second = second;";
"  this.third = sequence;";
"else";
"  if (left.type != \"variable\")";
"    raise(\"Syntax error\", \"Expected an identifier\", parser);";
"  endif";
"";
"  parser:make_identifier(left);";
"";
"  this.type = \"binary\";";
"  this.first = left;";
"  this.second = sequence;";
"endif";
"";
"return this;";
"";
"chunk_length:33";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:1FADCE34D392572FBFB4DD2C02D498A9A0FA25FE";
"-=-=-mxyzptlk-=-=-";
.
#46:2
if (this.type == "ternary")
a = {};
for v in (this.third)
a = {@a, v:p()};
endfor
if (this.second.type == "identifier")
return tostr(this.first:p(), ":", this.second:p(), "(", a:join(", "), ")");
else
return tostr(this.first:p(), ":(", this.second:p(), ")(", a:join(", "), ")");
endif
elseif (this.type == "binary")
a = {};
for v in (this.second)
a = {@a, v:p()};
endfor
return tostr(this.first:p(), "(", a:join(", "), ")");
else
return tostr(this.first:p());
endif
return;
"if (this.type == \"ternary\")";
"  a = {};";
"  for v in (this.third)";
"    a = {@a, v:p()};";
"  endfor";
"  if (this.second.type == \"identifier\")";
"    return tostr(this.first:p(), \":\", this.second:p(), \"(\", a:join(\", \"), \")\");";
"  else";
"    return tostr(this.first:p(), \":(\", this.second:p(), \")(\", a:join(\", \"), \")\");";
"  endif";
"elseif (this.type == \"binary\")";
"  a = {};";
"  for v in (this.second)";
"    a = {@a, v:p()};";
"  endfor";
"  return tostr(this.first:p(), \"(\", a:join(\", \"), \")\");";
"else";
"  return tostr(this.first:p());";
"endif";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:24B9D90139FDEAFEA1D9B4F6A0D3DC8880EC3E6A";
"-=-=-mxyzptlk-=-=-";
.
#47:0
{parser, first} = args;
if (parser:token().id == "(")
parser:advance("(");
second = parser:expression(0);
parser:advance(")");
else
second = parser:expression(this.bp);
if (second.type != "variable")
raise("Syntax error", "Expected an identifier", parser);
endif
parser:make_identifier(second);
endif
if (parser:token().id != "(")
raise("Syntax error", "Expected `('", parser);
endif
this.type = "binary";
this.first = first;
this.second = second;
return this;
return;
"{parser, first} = args;";
"";
"if (parser:token().id == \"(\")";
"  parser:advance(\"(\");";
"  second = parser:expression(0);";
"  parser:advance(\")\");";
"else";
"  second = parser:expression(this.bp);";
"  if (second.type != \"variable\")";
"    raise(\"Syntax error\", \"Expected an identifier\", parser);";
"  endif";
"  parser:make_identifier(second);";
"endif";
"";
"if (parser:token().id != \"(\")";
"  raise(\"Syntax error\", \"Expected `('\", parser);";
"endif";
"";
"this.type = \"binary\";";
"this.first = first;";
"this.second = second;";
"";
"return this;";
"";
"chunk_length:23";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B9DFBD0CCD5EEDED7AC95EC7FAD47D65829DDBEE";
"-=-=-mxyzptlk-=-=-";
.
#48:0
{parser, first} = args;
if (parser:token().id == "(")
parser:advance("(");
second = parser:expression(0);
parser:advance(")");
else
second = parser:expression(this.bp);
if (second.type != "variable")
raise("Syntax error", "Expected an identifier", parser);
endif
parser:make_identifier(second);
endif
this.type = "binary";
this.first = first;
this.second = second;
return this;
return;
"{parser, first} = args;";
"";
"if (parser:token().id == \"(\")";
"  parser:advance(\"(\");";
"  second = parser:expression(0);";
"  parser:advance(\")\");";
"else";
"  second = parser:expression(this.bp);";
"  if (second.type != \"variable\")";
"    raise(\"Syntax error\", \"Expected an identifier\", parser);";
"  endif";
"  parser:make_identifier(second);";
"endif";
"";
"this.type = \"binary\";";
"this.first = first;";
"this.second = second;";
"";
"return this;";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C3E0624F254D64CFCB9D8CE99CBFEA6B40E2E6B1";
"-=-=-mxyzptlk-=-=-";
.
#48:1
if (this.second.type == "identifier")
return tostr(this.first:p(), ".", this.second:p());
else
return tostr(this.first:p(), ".(", this.second:p() + ")");
endif
return;
"if (this.second.type == \"identifier\")";
"  return tostr(this.first:p(), \".\", this.second:p());";
"else";
"  return tostr(this.first:p(), \".(\", this.second:p() + \")\");";
"endif";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:669AFC5702E3F357CCB3E91A9036DC5881549CE6";
"-=-=-mxyzptlk-=-=-";
.
#49:0
{parser} = args;
first = parser:expression(700);
if (first.id == "(end)")
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "unary";
this.first = first;
return this;
return;
"{parser} = args;";
"";
"first = parser:expression(700);";
"";
"if (first.id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an expression\", parser);";
"endif";
"";
"this.type = \"unary\";";
"this.first = first;";
"";
"return this;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:71052EB9A64F517E3CBE29438E498136C830D190";
"-=-=-mxyzptlk-=-=-";
.
#49:1
{parser, first} = args;
id = parser:push("@", 0, this.plastic.prefix_operator_proto);
if ((token = parser:token()).id == "ANY")
parser:advance("ANY");
symbol = parser.symbols["ANY"];
parser:reserve_keyword(symbol);
second = {token};
else
second = this.plastic.utilities:parse_list_sequence(parser, ",", "");
if (second[$].id == "(end)")
raise("Syntax error", "Expected `ANY' or a list of expressions", parser);
endif
endif
parser:pop(id);
if ((token = parser:token()).id == "=>")
parser:advance("=>");
third = parser:expression(0);
if (third.id == "(end)")
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "ternary";
this.first = first;
this.second = second;
this.third = third;
else
this.type = "binary";
this.first = first;
this.second = second;
endif
return this;
return;
"{parser, first} = args;";
"";
"/* Error codes are either the keyword `ANY' or a list of expressions";
" * (see 4.1.12 Catching Errors in Expressions).";
" */";
"id = parser:push(\"@\", 0, this.plastic.prefix_operator_proto);";
"";
"if ((token = parser:token()).id == \"ANY\")";
"  parser:advance(\"ANY\");";
"  symbol = parser.symbols[\"ANY\"];";
"  parser:reserve_keyword(symbol);";
"  second = {token};";
"else";
"  second = this.plastic.utilities:parse_list_sequence(parser, \",\", \"\");";
"";
"  if (second[$].id == \"(end)\")";
"    raise(\"Syntax error\", \"Expected `ANY' or a list of expressions\", parser);";
"  endif";
"endif";
"";
"parser:pop(id);";
"";
"if ((token = parser:token()).id == \"=>\")";
"  parser:advance(\"=>\");";
"  third = parser:expression(0);";
"";
"  if (third.id == \"(end)\")";
"    raise(\"Syntax error\", \"Expected an expression\", parser);";
"  endif";
"";
"  this.type = \"ternary\";";
"  this.first = first;";
"  this.second = second;";
"  this.third = third;";
"else";
"  this.type = \"binary\";";
"  this.first = first;";
"  this.second = second;";
"endif";
"";
"return this;";
"";
"chunk_length:41";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3F74393AE60842B8E06B0DEB07E005C4B0350E3B";
"-=-=-mxyzptlk-=-=-";
.
#49:2
if (this.type == "unary")
return tostr(this.value, this.first:p());
endif
x = {};
for s in (this.second)
x = {@x, s:p()};
endfor
second = x:join(", ");
if (this.type == "ternary")
return tostr("`", this.first:p(), " ! ", second, " => ", this.third:p(), "'");
else
return tostr("`", this.first:p(), " ! ", second, "'");
endif
return;
"if (this.type == \"unary\")";
"  return tostr(this.value, this.first:p());";
"endif";
"";
"x = {};";
"for s in (this.second)";
"  x = {@x, s:p()};";
"endfor";
"";
"second = x:join(\", \");";
"";
"if (this.type == \"ternary\")";
"  return tostr(\"`\", this.first:p(), \" ! \", second, \" => \", this.third:p(), \"'\");";
"else";
"  return tostr(\"`\", this.first:p(), \" ! \", second, \"'\");";
"endif";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B2C16A49934AB4057F886E1D6C74703F96DF6C01";
"-=-=-mxyzptlk-=-=-";
.
#50:0
{parser, first} = args;
second = parser:expression(0);
parser:token("|");
third = parser:expression(0);
if ((second.id == "(end)") || (third.id == "(end)"))
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "ternary";
this.first = first;
this.second = second;
this.third = third;
return this;
return;
"{parser, first} = args;";
"";
"second = parser:expression(0);";
"parser:token(\"|\");";
"third = parser:expression(0);";
"";
"if (second.id == \"(end)\" || third.id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an expression\", parser);";
"endif";
"";
"this.type = \"ternary\";";
"this.first = first;";
"this.second = second;";
"this.third = third;";
"";
"return this;";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5437C1BBEF59856CD0E8FF421B0C741D0AA42CE2";
"-=-=-mxyzptlk-=-=-";
.
#50:1
return tostr("(", this.first:p(), " ? ", this.second:p(), " | ", this.third:p(), ")");
return;
"return tostr(\"(\", this.first:p(), \" ? \", this.second:p(), \" | \", this.third:p(), \")\");";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:CA28B7EE1208C0A1C3A33C2E364ED030E2FBC869";
"-=-=-mxyzptlk-=-=-";
.
#51:0
{parser} = args;
parser:reserve_statement(this);
a = {};
variables = {};
variable = parser:token();
parser:make_variable(variable);
parser:advance();
variables = {@variables, variable.id};
a = {@a, variable};
while (parser:token().id == ",")
parser:advance(",");
variable = parser:token();
parser:make_variable(variable);
parser:advance();
variables = {@variables, variable.id};
a = {@a, variable};
endwhile
parser:token("in");
symbol = parser.symbols["in"];
parser:reserve_keyword(symbol);
if (parser:token().id == "[")
this.subtype = "range";
(length(a) < 2) || raise("Syntax error", "Too many loop variables", parser);
parser:token("[");
first = parser:expression(0);
a = {@a, first};
parser:token("..");
second = parser:expression(0);
a = {@a, second};
parser:token("]");
else
this.subtype = "collection";
(length(a) < 3) || raise("Syntax error", "Too many loop variables", parser);
parser:token("(");
expression = parser:expression(0);
a = {@a, expression};
parser:token(")");
endif
parser.loop_variables = {@parser.loop_variables, @variables};
parser.loop_depth = parser.loop_depth + 1;
statements = parser:statements("endfor", "end");
a = {@a, statements};
l = length(variables);
parser.loop_variables = parser.loop_variables[1..$ - l];
parser.loop_depth = parser.loop_depth - 1;
if ((id = parser:token().id) == "endfor")
parser:advance("endfor");
else
parser:advance("end");
endif
symbol = parser.symbols[id];
parser:reserve_keyword(symbol);
this.value = a;
return this;
return;
"{parser} = args;";
"";
"/* update the symbol table */";
"parser:reserve_statement(this);";
"";
"a = {};";
"";
"/* the index(s) */";
"variables = {};";
"";
"variable = parser:token();";
"parser:make_variable(variable);";
"parser:advance();";
"variables = {@variables, variable.id};";
"a = {@a, variable};";
"";
"while (parser:token().id == \",\")";
"  parser:advance(\",\");";
"  variable = parser:token();";
"  parser:make_variable(variable);";
"  parser:advance();";
"  variables = {@variables, variable.id};";
"  a = {@a, variable};";
"endwhile";
"";
"parser:token(\"in\");";
"";
"/* update the symbol table */";
"symbol = parser.symbols[\"in\"];";
"parser:reserve_keyword(symbol);";
"";
"/* could be a range or a collection */";
"if (parser:token().id == \"[\")";
"  /* range */";
"  this.subtype = \"range\";";
"  length(a) < 2 || raise(\"Syntax error\", \"Too many loop variables\", parser);";
"  parser:token(\"[\");";
"  first = parser:expression(0);";
"  a = {@a, first};";
"  parser:token(\"..\");";
"  second = parser:expression(0);";
"  a = {@a, second};";
"  parser:token(\"]\");";
"else";
"  /* collection */";
"  this.subtype = \"collection\";";
"  length(a) < 3 || raise(\"Syntax error\", \"Too many loop variables\", parser);";
"  parser:token(\"(\");";
"  expression = parser:expression(0);";
"  a = {@a, expression};";
"  parser:token(\")\");";
"endif";
"";
"/* the body */";
"parser.loop_variables = {@parser.loop_variables, @variables};";
"parser.loop_depth = parser.loop_depth + 1;";
"";
"statements = parser:statements(\"endfor\", \"end\");";
"a = {@a, statements};";
"";
"l = length(variables);";
"parser.loop_variables = parser.loop_variables[1..$ - l];";
"parser.loop_depth = parser.loop_depth - 1;";
"";
"/* the last token must be \"endfor\" or \"end\" */";
"if ((id = parser:token().id) == \"endfor\")";
"  parser:advance(\"endfor\");";
"else";
"  parser:advance(\"end\");";
"endif";
"";
"/* update the symbol table */";
"symbol = parser.symbols[id];";
"parser:reserve_keyword(symbol);";
"";
"/* store the parts in this token's `value' */";
"this.value = a;";
"";
"return this;";
"";
"chunk_length:79";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D763B63E02432BB0E44CAAE84BC22B8A142FD75C";
"-=-=-mxyzptlk-=-=-";
.
#51:1
if (this.type == "variable")
return tostr("_", this.id);
endif
value = this.value;
if (this.subtype == "range")
code = {tostr("for ", value[1]:p(), " in [", value[2]:p(), "..", value[3]:p(), "]")};
statements = value[4];
elseif (length(value) == 4)
code = {tostr("for ", value[1]:p(), ", ", value[2]:p(), " in (", value[3]:p(), ")")};
statements = value[4];
else
code = {tostr("for ", value[1]:p(), " in (", value[2]:p(), ")")};
statements = value[3];
endif
for s in (statements)
if (respond_to(s, "std"))
code = {@code, @s:p()};
else
code = {@code, s:p() + ";"};
endif
endfor
code = {@code, "endfor"};
return code;
return;
"if (this.type == \"variable\")";
"  return tostr(\"_\", this.id);";
"endif";
"";
"value =  this.value;";
"";
"if (this.subtype == \"range\")";
"  code = {tostr(\"for \", value[1]:p(), \" in [\", value[2]:p(), \"..\", value[3]:p(), \"]\")};";
"  statements = value[4];";
"elseif (length(value) == 4)";
"  code = {tostr(\"for \", value[1]:p(), \", \", value[2]:p(), \" in (\", value[3]:p(), \")\")};";
"  statements = value[4];";
"else";
"  code = {tostr(\"for \", value[1]:p(), \" in (\", value[2]:p(), \")\")};";
"  statements = value[3];";
"endif";
"";
"for s in (statements)";
"  if (respond_to(s, \"std\"))";
"    code = {@code, @s:p()};";
"  else";
"    code = {@code, s:p() + \";\"};";
"  endif";
"endfor";
"";
"code = {@code, \"endfor\"};";
"";
"return code;";
"";
"chunk_length:28";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:53E81479D53DF5E419594453C4715AD4D6B93AEC";
"-=-=-mxyzptlk-=-=-";
.
#52:0
{parser} = args;
parser:reserve_statement(this);
end = tostr("end", this.id);
a = {};
variables = {};
if (((type = parser:token().type) == "variable") || (type == "name"))
variable = parser:token();
parser:make_variable(variable);
parser:advance();
variables = {@variables, variable.id};
a = {@a, variable};
endif
parser:token("(");
expression = parser:expression(0);
a = {@a, expression};
parser:token(")");
parser.loop_variables = {@parser.loop_variables, @variables};
parser.loop_depth = parser.loop_depth + 1;
statements = parser:statements(end, "end");
a = {@a, statements};
l = length(variables);
parser.loop_variables = parser.loop_variables[1..$ - l];
parser.loop_depth = parser.loop_depth - 1;
if ((id = parser:token().id) == end)
parser:advance(end);
else
parser:advance("end");
endif
symbol = parser.symbols[id];
parser:reserve_keyword(symbol);
this.value = a;
return this;
return;
"{parser} = args;";
"";
"/* update the symbol table */";
"parser:reserve_statement(this);";
"";
"end = tostr(\"end\", this.id);";
"";
"a = {};";
"";
"/* possible, optional loop name */";
"variables = {};";
"if ((type = parser:token().type) == \"variable\" || type == \"name\")";
"  variable = parser:token();";
"  parser:make_variable(variable);";
"  parser:advance();";
"  variables = {@variables, variable.id};";
"  a = {@a, variable};";
"endif";
"";
"/* the condition */";
"parser:token(\"(\");";
"expression = parser:expression(0);";
"a = {@a, expression};";
"parser:token(\")\");";
"";
"/* the body */";
"parser.loop_variables = {@parser.loop_variables, @variables};";
"parser.loop_depth = parser.loop_depth + 1;";
"";
"statements = parser:statements(end, \"end\");";
"a = {@a, statements};";
"";
"l = length(variables);";
"parser.loop_variables = parser.loop_variables[1..$ - l];";
"parser.loop_depth = parser.loop_depth - 1;";
"";
"/* the last token must be \"endwhile/enduntil\" or \"end\" */";
"if ((id = parser:token().id) == end)";
"  parser:advance(end);";
"else";
"  parser:advance(\"end\");";
"endif";
"";
"/* update the symbol table */";
"symbol = parser.symbols[id];";
"parser:reserve_keyword(symbol);";
"";
"/* store the parts in this token's `value' */";
"this.value = a;";
"";
"return this;";
"";
"chunk_length:51";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:DC2BECAEBBED52539E7926D3C715C5F443673A8D";
"-=-=-mxyzptlk-=-=-";
.
#52:1
if (this.type == "variable")
return tostr("_", this.id);
endif
value = this.value;
i = 0;
if (length(value) > 2)
prefix = tostr("while ", value[i = i + 1]:p());
else
prefix = tostr("while");
endif
if (this.id == "while")
code = {tostr(prefix, " (", value[i = i + 1]:p(), ")")};
else
code = {tostr(prefix, " (!(", value[i = i + 1]:p(), "))")};
endif
for s in (value[i = i + 1])
if (respond_to(s, "std"))
code = {@code, @s:p()};
else
code = {@code, s:p() + ";"};
endif
endfor
code = {@code, "endwhile"};
return code;
return;
"if (this.type == \"variable\")";
"  return tostr(\"_\", this.id);";
"endif";
"";
"value =  this.value;";
"";
"i = 0;";
"";
"if (length(value) > 2)";
"  prefix = tostr(\"while \", value[i = i + 1]:p());";
"else";
"  prefix = tostr(\"while\");";
"endif";
"";
"if (this.id == \"while\")";
"  code = {tostr(prefix, \" (\", value[i = i + 1]:p(), \")\")};";
"else";
"  code = {tostr(prefix, \" (!(\", value[i = i + 1]:p(), \"))\")};";
"endif";
"";
"for s in (value[i = i + 1])";
"  if (respond_to(s, \"std\"))";
"    code = {@code, @s:p()};";
"  else";
"    code = {@code, s:p() + \";\"};";
"  endif";
"endfor";
"";
"code = {@code, \"endwhile\"};";
"";
"return code;";
"";
"chunk_length:31";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6C6CEEB81E8301156D7192E02A4FDC0D47D316D8";
"-=-=-mxyzptlk-=-=-";
.
#53:0
{parser} = args;
parser:reserve_statement(this);
a = {};
if (((type = parser:token().type) == "variable") || (type == "name"))
variable = parser:token();
parser:make_variable(variable);
parser:advance();
a = {@a, variable};
endif
parser:token("(");
expression = parser:expression(0);
a = {@a, expression};
parser:token(")");
statements = parser:statements("endfork", "end");
a = {@a, statements};
if ((id = parser:token().id) == "endfork")
parser:advance("endfork");
else
parser:advance("end");
endif
symbol = parser.symbols[id];
parser:reserve_keyword(symbol);
this.value = a;
return this;
return;
"{parser} = args;";
"";
"/* update the symbol table */";
"parser:reserve_statement(this);";
"";
"a = {};";
"";
"/* possible, optional task name */";
"if ((type = parser:token().type) == \"variable\" || type == \"name\")";
"  variable = parser:token();";
"  parser:make_variable(variable);";
"  parser:advance();";
"  a = {@a, variable};";
"endif";
"";
"/* the expression */";
"parser:token(\"(\");";
"expression = parser:expression(0);";
"a = {@a, expression};";
"parser:token(\")\");";
"";
"/* the body */";
"statements = parser:statements(\"endfork\", \"end\");";
"a = {@a, statements};";
"";
"/* the last token must be \"endfork\" or \"end\" */";
"if ((id = parser:token().id) == \"endfork\")";
"  parser:advance(\"endfork\");";
"else";
"  parser:advance(\"end\");";
"endif";
"";
"/* update the symbol table */";
"symbol = parser.symbols[id];";
"parser:reserve_keyword(symbol);";
"";
"/* store the parts in this token's `value' */";
"this.value = a;";
"";
"return this;";
"";
"chunk_length:40";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0ED7146966275E0722F7F9DF4BD7F76C03BB0DDD";
"-=-=-mxyzptlk-=-=-";
.
#53:1
if (this.type == "variable")
return tostr("_", this.id);
endif
value = this.value;
i = 0;
if (length(value) > 2)
code = {tostr("fork ", value[i = i + 1]:p(), " (", value[i = i + 1]:p(), ")")};
else
code = {tostr("fork", " (", value[i = i + 1]:p(), ")")};
endif
for s in (value[i = i + 1])
if (respond_to(s, "std"))
code = {@code, @s:p()};
else
code = {@code, s:p() + ";"};
endif
endfor
code = {@code, "endfork"};
return code;
return;
"if (this.type == \"variable\")";
"  return tostr(\"_\", this.id);";
"endif";
"";
"value =  this.value;";
"";
"i = 0;";
"";
"if (length(value) > 2)";
"  code = {tostr(\"fork \", value[i = i + 1]:p(), \" (\", value[i = i + 1]:p(), \")\")};";
"else";
"  code = {tostr(\"fork\", \" (\", value[i = i + 1]:p(), \")\")};";
"endif";
"";
"for s in (value[i = i + 1])";
"  if (respond_to(s, \"std\"))";
"    code = {@code, @s:p()};";
"  else";
"    code = {@code, s:p() + \";\"};";
"  endif";
"endfor";
"";
"code = {@code, \"endfork\"};";
"";
"return code;";
"";
"chunk_length:25";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:CD3464D051311AF18068FF1F8719E0005E87E555";
"-=-=-mxyzptlk-=-=-";
.
#54:0
{parser} = args;
parser:reserve_statement(this);
a = {};
body = parser:statements("except", "finally", "endtry", "end");
a = {@a, body};
if (parser:token().id == "finally")
parser:advance("finally");
b = parser:statements("endtry", "end");
symbol = parser.symbols["finally"];
parser:reserve_keyword(symbol);
this.subtype = "finally";
a = {@a, b};
else
b = {};
id = parser:push("@", 0, this.plastic.prefix_operator_proto);
while (parser:token().id == "except")
parser:advance("except");
if ((variable = parser:token()).id != "(")
parser:advance();
if ((variable.type != "name") && (variable.type != "variable"))
raise("Syntax error", "Variable must be an identifier", parser);
endif
parser:make_variable(variable);
parser:token("(");
if ((token = parser:token()).id == "ANY")
parser:advance("ANY");
symbol = parser.symbols["ANY"];
parser:reserve_keyword(symbol);
codes = {token};
else
codes = this.plastic.utilities:parse_list_sequence(parser, ",", ")");
endif
parser:token(")");
(!codes) && raise("Syntax error", "Codes may not be empty", parser);
b = {variable, codes};
else
parser:token("(");
if ((token = parser:token()).id == "ANY")
parser:advance("ANY");
symbol = parser.symbols["ANY"];
parser:reserve_keyword(symbol);
codes = {token};
else
codes = this.plastic.utilities:parse_list_sequence(parser, ",", ")");
endif
parser:token(")");
(!codes) && raise("Syntax error", "Codes may not be empty", parser);
b = {codes};
endif
handler = parser:statements("except", "finally", "endtry", "end");
b = {@b, handler};
symbol = parser.symbols["except"];
parser:reserve_keyword(symbol);
a = {@a, b};
endwhile
parser:pop(id);
if (!b)
raise("Syntax error", "Missing except", parser);
endif
this.subtype = "except";
endif
if ((id = parser:token().id) == "endtry")
parser:advance("endtry");
else
parser:advance("end");
endif
symbol = parser.symbols[id];
parser:reserve_keyword(symbol);
this.value = a;
return this;
return;
"{parser} = args;";
"";
"/* update the symbol table */";
"parser:reserve_statement(this);";
"";
"a = {};";
"";
"/* the body */";
"body = parser:statements(\"except\", \"finally\", \"endtry\", \"end\");";
"a = {@a, body};";
"";
"if (parser:token().id == \"finally\")";
"  parser:advance(\"finally\");";
"";
"  b = parser:statements(\"endtry\", \"end\");";
"";
"  /* update the symbol table */";
"  symbol = parser.symbols[\"finally\"];";
"  parser:reserve_keyword(symbol);";
"";
"  this.subtype = \"finally\";";
"";
"  a = {@a, b};";
"";
"else";
"  b = {};";
"";
"  id = parser:push(\"@\", 0, this.plastic.prefix_operator_proto);";
"";
"  /* the exceptions */";
"  while (parser:token().id == \"except\")";
"    parser:advance(\"except\");";
"";
"    /* variable and codes */";
"    if ((variable = parser:token()).id != \"(\")";
"      parser:advance();";
"";
"      if (variable.type != \"name\" && variable.type != \"variable\")";
"        raise(\"Syntax error\", \"Variable must be an identifier\", parser);";
"      endif";
"      parser:make_variable(variable);";
"";
"      parser:token(\"(\");";
"      if ((token = parser:token()).id == \"ANY\")";
"        parser:advance(\"ANY\");";
"        symbol = parser.symbols[\"ANY\"];";
"        parser:reserve_keyword(symbol);";
"        codes = {token};";
"      else";
"        codes = this.plastic.utilities:parse_list_sequence(parser, \",\", \")\");";
"      endif";
"      parser:token(\")\");";
"";
"      !codes && raise(\"Syntax error\", \"Codes may not be empty\", parser);";
"";
"      b = {variable, codes};";
"";
"    /* just codes */";
"    else";
"      parser:token(\"(\");";
"      if ((token = parser:token()).id == \"ANY\")";
"        parser:advance(\"ANY\");";
"        symbol = parser.symbols[\"ANY\"];";
"        parser:reserve_keyword(symbol);";
"        codes = {token};";
"      else";
"        codes = this.plastic.utilities:parse_list_sequence(parser, \",\", \")\");";
"      endif";
"      parser:token(\")\");";
"";
"      !codes && raise(\"Syntax error\", \"Codes may not be empty\", parser);";
"";
"      b = {codes};";
"";
"    endif";
"";
"    /* handler */";
"    handler = parser:statements(\"except\", \"finally\", \"endtry\", \"end\");";
"    b = {@b, handler};";
"";
"    /* update the symbol table */";
"    symbol = parser.symbols[\"except\"];";
"    parser:reserve_keyword(symbol);";
"";
"    a = {@a, b};";
"";
"  endwhile";
"";
"  parser:pop(id);";
"";
"  if (!b)";
"    raise(\"Syntax error\", \"Missing except\", parser);";
"  endif";
"";
"  this.subtype = \"except\";";
"";
"endif";
"";
"/* the last token must be \"endtry\" or \"end\" */";
"if ((id = parser:token().id) == \"endtry\")";
"  parser:advance(\"endtry\");";
"else";
"  parser:advance(\"end\");";
"endif";
"";
"/* update the symbol table */";
"symbol = parser.symbols[id];";
"parser:reserve_keyword(symbol);";
"";
"/* store the parts in this token's `value' */";
"this.value = a;";
"";
"return this;";
"";
"chunk_length:113";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E35D0E704DAB84B635FDF374A2AE5B68C2A8A8EC";
"-=-=-mxyzptlk-=-=-";
.
#54:1
if (this.type == "variable")
return tostr("_", this.id);
endif
value = this.value;
code = {"try"};
for s in (value[1])
if (respond_to(s, "std"))
code = {@code, @s:p()};
else
code = {@code, s:p() + ";"};
endif
endfor
if (this.subtype == "finally")
code = {@code, "finally"};
for s in (value[2])
if (respond_to(s, "std"))
code = {@code, @s:p()};
else
code = {@code, s:p() + ";"};
endif
endfor
else
for value in (value[2..$])
if (length(value) == 3)
x = {};
for s in (value[2])
x = {@x, s:p()};
endfor
code = {@code, tostr("except ", value[1]:p(), " (", x:join(", "), ")")};
statements = value[3];
else
x = {};
for s in (value[1])
x = {@x, s:p()};
endfor
code = {@code, tostr("except (", x:join(", "), ")")};
statements = value[2];
endif
for s in (statements)
if (respond_to(s, "std"))
code = {@code, @s:p()};
else
code = {@code, s:p() + ";"};
endif
endfor
endfor
endif
code = {@code, "endtry"};
return code;
return;
"if (this.type == \"variable\")";
"  return tostr(\"_\", this.id);";
"endif";
"";
"value =  this.value;";
"";
"code = {\"try\"};";
"";
"for s in (value[1])";
"  if (respond_to(s, \"std\"))";
"    code = {@code, @s:p()};";
"  else";
"    code = {@code, s:p() + \";\"};";
"  endif";
"endfor";
"";
"if (this.subtype == \"finally\")";
"  code = {@code, \"finally\"};";
"";
"  for s in (value[2])";
"    if (respond_to(s, \"std\"))";
"      code = {@code, @s:p()};";
"    else";
"      code = {@code, s:p() + \";\"};";
"    endif";
"  endfor";
"";
"else";
"  for value in (value[2..$])";
"    if (length(value) == 3)";
"      x = {};";
"      for s in (value[2])";
"        x = {@x, s:p()};";
"      endfor";
"";
"      code = {@code, tostr(\"except \", value[1]:p(), \" (\", x:join(\", \"), \")\")};";
"      statements = value[3];";
"";
"    else";
"      x = {};";
"      for s in (value[1])";
"        x = {@x, s:p()};";
"      endfor";
"";
"      code = {@code, tostr(\"except (\", x:join(\", \"), \")\")};";
"      statements = value[2];";
"";
"    endif";
"";
"    for s in (statements)";
"      if (respond_to(s, \"std\"))";
"        code = {@code, @s:p()};";
"      else";
"        code = {@code, s:p() + \";\"};";
"      endif";
"    endfor";
"";
"  endfor";
"endif";
"";
"code = {@code, \"endtry\"};";
"";
"return code;";
"";
"chunk_length:63";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:DB053078427B4F741DC90CD05AD9EAD8F1B06D31";
"-=-=-mxyzptlk-=-=-";
.
#55:0
return this;
return;
"return this;";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:58CFE4977A49A7695FEE4D2F29BB87606D70E92F";
"-=-=-mxyzptlk-=-=-";
.
#55:1
return this.value;
return;
"return this.value;";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9CCA8704C93A791DA685CAE74B5398C5A6A25CB1";
"-=-=-mxyzptlk-=-=-";
.
#56:0
{parser} = args;
first = parser:expression(700);
if (first.id == "(end)")
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "unary";
this.first = first;
return this;
return;
"{parser} = args;";
"";
"first = parser:expression(700);";
"";
"if (first.id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an expression\", parser);";
"endif";
"";
"this.type = \"unary\";";
"this.first = first;";
"";
"return this;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:71052EB9A64F517E3CBE29438E498136C830D190";
"-=-=-mxyzptlk-=-=-";
.
#56:1
{parser, first} = args;
second = parser:expression(this.bp);
if (second.id == "(end)")
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "binary";
this.first = first;
this.second = second;
return this;
return;
"{parser, first} = args;";
"";
"second = parser:expression(this.bp);";
"";
"if (second.id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an expression\", parser);";
"endif";
"";
"this.type = \"binary\";";
"this.first = first;";
"this.second = second;";
"";
"return this;";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A9AE696659B56975F48F68AF477F92EB2084698F";
"-=-=-mxyzptlk-=-=-";
.
#56:2
if (this.type == "unary")
return tostr((this.value == "-") ? "-" | "", this.first:p());
else
return tostr("(", this.first:p(), " ", this.value, " ", this.second:p(), ")");
endif
return;
"if (this.type == \"unary\")";
"  return tostr(this.value == \"-\" ? \"-\" | \"\", this.first:p());";
"else";
"  return tostr(\"(\", this.first:p(), \" \", this.value, \" \", this.second:p(), \")\");";
"endif";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E7AD82C153CD93BD8B0745854F542F62CFE8F2BE";
"-=-=-mxyzptlk-=-=-";
.
#59:0
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
return;
"ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C3608BDA1ACF59B6AE2D36C8E3B873466464014B";
"-=-=-mxyzptlk-=-=-";
.
#59:1
{lines, ?intern = []} = args;
algo = this.default_hash_algo;
result = {};
for line in (lines)
this:_suspend_if_necessary();
hash = string_hash(line, algo);
hash = `intern[hash] ! E_RANGE => intern[hash] = hash';
result = {@result, {line, hash}};
endfor
return {result, intern};
return;
"{lines, ?intern = []} = args;";
"";
"/* By interning strings we ensure that string storage is re-used,";
" * which reduces string compare down to a pointer equality check in";
" * the server.";
" */";
"";
"algo = this.default_hash_algo;";
"";
"result = {};";
"for line in (lines)";
"  this:_suspend_if_necessary();";
"  hash = string_hash(line, algo);";
"  hash = `intern[hash] ! E_RANGE => intern[hash] = hash';";
"  result = {@result, {line, hash}};";
"endfor";
"";
"return {result, intern};";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3B840B91F733C547C6F63B2420E85AD186EF1B0E";
"-=-=-mxyzptlk-=-=-";
.
#59:2
{lines1, lines2, intern} = args;
for v, k in (intern)
this:_suspend_if_necessary();
intern[k] = {{0, 0}, {0, 0}};
endfor
for line, i in (lines1)
this:_suspend_if_necessary();
intern[line[2]][1] = {intern[line[2]][1][1] + 1, i};
endfor
for line, i in (lines2)
this:_suspend_if_necessary();
intern[line[2]][2] = {intern[line[2]][2][1] + 1, i};
endfor
items = {};
for line in (lines1)
this:_suspend_if_necessary();
item = intern[line[2]];
if ((item[1][1] == 1) && (item[2][1] == 1))
items = {@items, {item[1][2], item[2][2]}};
endif
endfor
return items;
return;
"{lines1, lines2, intern} = args;";
"";
"for v, k in (intern)";
"  this:_suspend_if_necessary();";
"  intern[k] = {{0, 0}, {0, 0}};";
"endfor";
"";
"for line, i in (lines1)";
"  this:_suspend_if_necessary();";
"  intern[line[2]][1] = {intern[line[2]][1][1] + 1, i};";
"endfor";
"";
"for line, i in (lines2)";
"  this:_suspend_if_necessary();";
"  intern[line[2]][2] = {intern[line[2]][2][1] + 1, i};";
"endfor";
"";
"items = {};";
"for line in (lines1)";
"  this:_suspend_if_necessary();";
"  item = intern[line[2]];";
"  if (item[1][1] == 1 && item[2][1] == 1)";
"    items = {@items, {item[1][2], item[2][2]}};";
"  endif";
"endfor";
"";
"return items;";
"";
"chunk_length:27";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:BCF4FA5C1C969563D67684352B747F95260A8CAD";
"-=-=-mxyzptlk-=-=-";
.
#59:3
{items} = args;
stacks = {};
for item in (items)
last = 0;
for i in [1..length(stacks)]
this:_suspend_if_necessary();
if (item[2] < stacks[i][$][1][2])
stacks[i] = {@stacks[i], {item, last}};
item = 0;
break;
endif
last = length(stacks[i]);
endfor
if (item)
stacks = {@stacks, {{item, last}}};
endif
endfor
stacks = stacks:reverse();
i = stacks && length(stacks[1]);
results = {};
for stack in (stacks)
this:_suspend_if_necessary();
item = stack[i];
results = {item[1], @results};
i = item[2];
endfor
return results;
return;
"{items} = args;";
"";
"/* patience sort */";
"stacks = {};";
"for item in (items)";
"  last = 0;";
"  for i in [1..length(stacks)]";
"    this:_suspend_if_necessary();";
"    if (item[2] < stacks[i][$][1][2])";
"      stacks[i] = {@stacks[i], {item, last}};";
"      item = 0;";
"      break;";
"    endif";
"    last = length(stacks[i]);";
"  endfor";
"  if (item)";
"    stacks = {@stacks, {{item, last}}};";
"  endif";
"endfor";
"";
"stacks = stacks:reverse();";
"i = stacks && length(stacks[1]);";
"results = {};";
"for stack in (stacks)";
"  this:_suspend_if_necessary();";
"  item = stack[i];";
"  results = {item[1], @results};";
"  i = item[2];";
"endfor";
"";
"return results;";
"";
"chunk_length:31";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F2F39DE79F64CBBB7E604B1600CB04F108F937D1";
"-=-=-mxyzptlk-=-=-";
.
#59:4
{lines1, lines2, lcs} = args;
last = {0, 0};
lcs = {@lcs, {length(lines1) + 1, length(lines2) + 1}};
results = {};
for pos in (lcs)
this:_suspend_if_necessary();
i1 = last[1] + 1;
j1 = pos[1] - 1;
i2 = last[2] + 1;
j2 = pos[2] - 1;
while (i1 < j1)
this:_suspend_if_necessary();
if (lines1[i1][2] == `lines2[i2][2] ! E_RANGE')
i1 = i1 + 1;
i2 = i2 + 1;
continue;
endif
break;
endwhile
while (j1 >= i1)
this:_suspend_if_necessary();
if (lines1[j1][2] == `lines2[j2][2] ! E_RANGE')
j1 = j1 - 1;
j2 = j2 - 1;
continue;
endif
break;
endwhile
res1 = lines1[i1..j1]:slice(1);
res2 = lines2[i2..j2]:slice(1);
if (res1 && res2)
results = {@results, {"r", i1, i2, res1, res2}};
elseif (res1)
results = {@results, {"-", i1, i2, res1}};
elseif (res2)
results = {@results, {"+", i1, i2, res2}};
endif
last = pos;
endfor
return results;
return;
"{lines1, lines2, lcs} = args;";
"";
"last = {0, 0};";
"lcs = {@lcs, {length(lines1) + 1, length(lines2) + 1}};";
"";
"results = {};";
"for pos in (lcs)";
"  this:_suspend_if_necessary();";
"";
"  i1 = last[1] + 1;";
"  j1 = pos[1] - 1;";
"  i2 = last[2] + 1;";
"  j2 = pos[2] - 1;";
"  while (i1 < j1)";
"    this:_suspend_if_necessary();";
"    if (lines1[i1][2] == `lines2[i2][2] ! E_RANGE')";
"      i1 = i1 + 1;";
"      i2 = i2 + 1;";
"      continue;";
"    endif";
"    break;";
"  endwhile";
"  while (j1 >= i1)";
"    this:_suspend_if_necessary();";
"    if (lines1[j1][2] == `lines2[j2][2] ! E_RANGE')";
"      j1 = j1 - 1;";
"      j2 = j2 - 1;";
"      continue;";
"    endif";
"    break;";
"  endwhile";
"  res1 = lines1[i1..j1]:slice(1);";
"  res2 = lines2[i2..j2]:slice(1);";
"  if (res1 && res2)";
"    results = {@results, {\"r\", i1, i2, res1, res2}};";
"  elseif (res1)";
"    results = {@results, {\"-\", i1, i2, res1}};";
"  elseif (res2)";
"    results = {@results, {\"+\", i1, i2, res2}};";
"  endif";
"";
"  last = pos;";
"endfor";
"";
"return results;";
"";
"chunk_length:45";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:878B1D1E76A186DC5F3F522323593AEC88D154FF";
"-=-=-mxyzptlk-=-=-";
.
#59:5
{lines1, lines2} = args;
intern = [];
{lines1, intern} = this:_hash_lines(lines1, intern);
{lines2, intern} = this:_hash_lines(lines2, intern);
lcs = this:_find_lcs(this:_find_common_unique_lines(lines1, lines2, intern));
return this:_generate_diff(lines1, lines2, lcs);
return;
"{lines1, lines2} = args;";
"";
"intern = [];";
"{lines1, intern} = this:_hash_lines(lines1, intern);";
"{lines2, intern} = this:_hash_lines(lines2, intern);";
"";
"lcs = this:_find_lcs(this:_find_common_unique_lines(lines1, lines2, intern));";
"";
"return this:_generate_diff(lines1, lines2, lcs);";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:80A42BCA22606876E26013750C479B574B5A3CC5";
"-=-=-mxyzptlk-=-=-";
.
#60:0
$restrict_to_caller($composed);
$lookup("dictionary").ask = ["prototype" -> $ask_proto];
$frobs = setadd($frobs, $ask_proto);
return;
"$restrict_to_caller($composed);";
"";
"$lookup(\"dictionary\").ask = [\"prototype\" -> $ask_proto];";
"$frobs = setadd($frobs, $ask_proto);";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C5FB5F7668849783CA596B2F8DB229D467FFCF58";
"-=-=-mxyzptlk-=-=-";
.
#60:1
$restrict_to_caller($composed);
$frobs = setremove($frobs, $ask_proto);
return;
"$restrict_to_caller($composed);";
"";
"$frobs = setremove($frobs, $ask_proto);";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A86B217C56A09E274DF767D4E0E109E1C3470BA1";
"-=-=-mxyzptlk-=-=-";
.
#63:0
$private();
set_task_perms(caller_perms());
{type, target, attr} = args;
try
if (attr == this.id)
return target;
elseif ((type == MAP) || (type == LIST))
return target[attr];
else
return respond_to(target, attr) ? target:(attr)() | target.(attr);
endif
except (E_TYPE)
raise("type mismatch");
except (E_RANGE, E_PROPNF)
raise("not found");
except (E_PERM)
raise("permission denied");
endtry
return;
"$private();";
"";
"set_task_perms(caller_perms());";
"";
"{type, target, attr} = args;";
"";
"try";
"  if (attr == this.id)";
"    return target;";
"  elseif (type == MAP || type == LIST)";
"    return target[attr];";
"  else";
"    return respond_to(target, attr) ? target:(attr)() | target.(attr);";
"  endif";
"except (E_TYPE)";
"  raise(\"type mismatch\");";
"except (E_RANGE, E_PROPNF)";
"  raise(\"not found\");";
"except (E_PERM)";
"  raise(\"permission denied\");";
"endtry";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F0ED60C4383CE5E640826F01858F14F1E4DF5A6B";
"-=-=-mxyzptlk-=-=-";
.
#63:1
$private();
set_task_perms(callers()[2][3]);
{query, limit} = args;
from = `query["from"] ! E_RANGE => raise(E_INVARG, "Missing from")';
select = where = {};
for operation in (`query["operations"] ! E_RANGE => {}')
`select = operation["select"] ! E_RANGE';
`where = {@where, operation["where"]} ! E_RANGE';
endfor
if (((type = typeof(from)) == OBJ) && valid(from))
from = descendants(from);
elseif ((type == LIST) && (length(from) < 1))
type = -1;
elseif ((type == LIST) && ((type = typeof(from[1])) in {OBJ, MAP, LIST}))
else
raise(E_INVARG, tostr("Invalid from:  ", toliteral(from)));
endif
res = {};
for o in (from)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
for w in (where)
{o1, op, o2} = w;
if (o1[1] < 0)
try
o1 = this:_lookup(type, o, o1[2]);
except ex ("type mismatch", "not found", "permission denied")
o = [this.errors -> [o1[2] -> ex[1]]];
break w;
endtry
else
o1 = o1[2];
endif
if (o2[1] < 0)
try
o2 = this:_lookup(type, o, o2[2]);
except ex ("type mismatch", "not found", "permission denied")
o = [this.errors -> [o2[2] -> ex[1]]];
break w;
endtry
else
o2 = o2[2];
endif
try
if ((op == "=") || (op == "=="))
if (o1 != o2)
continue o;
endif
elseif (op == "!=")
if (o1 == o2)
continue o;
endif
elseif (op == ">")
if (o1 <= o2)
continue o;
endif
elseif (op == ">=")
if (o1 < o2)
continue o;
endif
elseif (op == "<")
if (o1 >= o2)
continue o;
endif
elseif (op == "<=")
if (o1 > o2)
continue o;
endif
elseif (op == "includes")
if (!(o2 in o1))
continue o;
endif
elseif (op == "in")
if (!(o1 in o2))
continue o;
endif
elseif (op == "is")
if ((o1 && (!o2)) || ((!o1) && o2))
continue o;
endif
elseif (op == "=~")
if (!match(o1, o2))
continue o;
endif
else
raise(E_INVARG, tostr("Invalid operation:  ", op));
endif
except (E_TYPE)
o = [this.errors -> tostr("type mismatch:  ", toliteral(o1), " ", op, " ", toliteral(o2))];
break w;
endtry
endfor
if (`o[this.errors] ! E_TYPE, E_RANGE')
res = {@res, o};
elseif (select)
r = [];
for s in (select)
try
r[s] = this:_lookup(type, o, s);
except ex ("type mismatch", "not found", "permission denied")
r = r:set_value_by_path({this.errors, s}, ex[1]);
endtry
endfor
res = {@res, r};
else
res = {@res, o};
endif
if ((limit > 0) && res)
break;
endif
endfor
return (limit > 0) ? res ? res[1] | $failed_match | res;
return;
"$private();";
"";
"/* perms of the verb that called `all()', `one()'... */";
"set_task_perms(callers()[2][3]);";
"";
"{query, limit} = args;";
"";
"from = `query[\"from\"] ! E_RANGE => raise(E_INVARG, \"Missing from\")';";
"select = where = {};";
"for operation in (`query[\"operations\"] ! E_RANGE => {}')";
"  `select = operation[\"select\"] ! E_RANGE';";
"  `where = {@where, operation[\"where\"]} ! E_RANGE';";
"endfor";
"";
"/* `type' indicates the type of field to query over */";
"";
"if ((type = typeof(from)) == OBJ && valid(from))";
"  from = descendants(from);";
"elseif (type == LIST && length(from) < 1)";
"  type = -1;";
"elseif (type == LIST && (type = typeof(from[1])) in {OBJ, MAP, LIST})";
"  /* do nothing, but don't fail */";
"else";
"  raise(E_INVARG, tostr(\"Invalid from:  \", toliteral(from)));";
"endif";
"";
"res = {};";
"";
"for o in (from)";
"  ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"  /* WHERE */";
"  for w in (where)";
"    {o1, op, o2} = w;";
"    /* get value from operand */";
"    if (o1[1] < 0)";
"      try";
"        o1 = this:_lookup(type, o, o1[2]);";
"      except ex (\"type mismatch\", \"not found\", \"permission denied\")";
"        o = [this.errors -> [o1[2] -> ex[1]]];";
"        break w;";
"      endtry";
"    else";
"      o1 = o1[2];";
"    endif";
"    if (o2[1] < 0)";
"      try";
"        o2 = this:_lookup(type, o, o2[2]);";
"      except ex (\"type mismatch\", \"not found\", \"permission denied\")";
"        o = [this.errors -> [o2[2] -> ex[1]]];";
"        break w;";
"      endtry";
"    else";
"      o2 = o2[2];";
"    endif";
"    /* operate! */";
"    try";
"      if (op == \"=\" || op == \"==\")";
"        if (o1 != o2)";
"          continue o; /* back to the top of the big loop */";
"        endif";
"      elseif (op == \"!=\")";
"        if (o1 == o2)";
"          continue o;";
"        endif";
"      elseif (op == \">\")";
"        if (o1 <= o2)";
"          continue o;";
"        endif";
"      elseif (op == \">=\")";
"        if (o1 < o2)";
"          continue o;";
"        endif";
"      elseif (op == \"<\")";
"        if (o1 >= o2)";
"          continue o;";
"        endif";
"      elseif (op == \"<=\")";
"        if (o1 > o2)";
"          continue o;";
"        endif";
"      elseif (op == \"includes\")";
"        if (!(o2 in o1))";
"          continue o;";
"        endif";
"      elseif (op == \"in\")";
"        if (!(o1 in o2))";
"          continue o;";
"        endif";
"      elseif (op == \"is\")";
"        if ((o1 && !o2) || (!o1 && o2))";
"          continue o;";
"        endif";
"      elseif (op == \"=~\")";
"        if (!match(o1, o2))";
"          continue o;";
"        endif";
"      else";
"        raise(E_INVARG, tostr(\"Invalid operation:  \", op));";
"      endif";
"    except (E_TYPE)";
"      o = [this.errors -> tostr(\"type mismatch:  \", toliteral(o1), \" \", op, \" \", toliteral(o2))];";
"      break w;";
"    endtry";
"  endfor";
"  /* SELECT */";
"  if (`o[this.errors] ! E_TYPE, E_RANGE')";
"    /* test for errors from the WHERE stage */";
"    res = {@res, o};";
"  elseif (select)";
"    r = [];";
"    for s in (select)";
"      try";
"        r[s] = this:_lookup(type, o, s);";
"      except ex (\"type mismatch\", \"not found\", \"permission denied\")";
"        r = r:set_value_by_path({this.errors, s}, ex[1]);";
"      endtry";
"    endfor";
"    res = {@res, r};";
"  else";
"    res = {@res, o};";
"  endif";
"";
"  if (limit > 0 && res)";
"    break;";
"  endif";
"endfor";
"";
"return limit > 0 ? (res ? res[1] | $failed_match) | res;";
"";
"chunk_length:128";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0A4FFF89C2D4A37C8A4A1D176D72146297E1DD56";
"-=-=-mxyzptlk-=-=-";
.
#63:2
{predicate} = args;
if (!predicate)
elseif (index("\"'", c = predicate[1]))
(n = match(predicate, ("[^\\]" + c) + " *")) || raise(E_INVARG, "Missing end-quote");
return {{STR, predicate[2..n[1]]:strsub({{"\\\\", "\\"}, {"\\\"", "\""}})}, predicate[n[2] + 1..$]};
elseif (((c == "#") && (r = match(predicate, "^%(#-?[0-9]+%) *"))) && ((length(predicate) == r[2]) || (predicate[r[2]] == " ")))
return {{OBJ, toobj(predicate[r[3][1][1]..r[3][1][2]])}, predicate[r[2] + 1..$]};
elseif (index("-+0123456789", c))
if ((r = match(predicate, "^%([-+]?[0-9]+%) *")) && ((length(predicate) == r[2]) || (predicate[r[2]] == " ")))
return {{INT, toint(predicate[r[3][1][1]..r[3][1][2]])}, predicate[r[2] + 1..$]};
elseif ((r = match(predicate, "^%([-+]?[0-9]+%.[0-9]+%) *")) && ((length(predicate) == r[2]) || (predicate[r[2]] == " ")))
return {{FLOAT, tofloat(predicate[r[3][1][1]..r[3][1][2]])}, predicate[r[2] + 1..$]};
endif
elseif ((r = match(predicate, "^%(%?%|%#%|[a-z][a-z0-9]*%) *")) && ((length(predicate) == r[2]) || (predicate[r[2]] == " ")))
return {{-1, predicate[r[3][1][1]..r[3][1][2]]}, predicate[r[2] + 1..$]};
endif
raise(E_INVARG, tostr("Unmatched literal or identifier:  ", predicate));
return;
"{predicate} = args;";
"";
"/* the predicate string must _not_ start with whitespace */";
"if (!predicate)";
"  ;";
"elseif (index(\"\\\"'\", (c = predicate[1])))";
"  (n = match(predicate, \"[^\\\\]\" + c + \" *\")) || raise(E_INVARG, \"Missing end-quote\");";
"  return {{STR, predicate[2..n[1]]:strsub({{\"\\\\\\\\\", \"\\\\\"}, {\"\\\\\\\"\", \"\\\"\"}})}, predicate[n[2] + 1..$]};";
"elseif (c == \"#\" && (r = match(predicate, \"^%(#-?[0-9]+%) *\")) && (length(predicate) == r[2] || predicate[r[2]] == \" \"))";
"  return {{OBJ, toobj(predicate[r[3][1][1]..r[3][1][2]])}, predicate[r[2] + 1..$]};";
"elseif (index(\"-+0123456789\", c))";
"  if ((r = match(predicate, \"^%([-+]?[0-9]+%) *\")) && (length(predicate) == r[2] || predicate[r[2]] == \" \"))";
"    return {{INT, toint(predicate[r[3][1][1]..r[3][1][2]])}, predicate[r[2] + 1..$]};";
"  elseif ((r = match(predicate, \"^%([-+]?[0-9]+%.[0-9]+%) *\")) && (length(predicate) == r[2] || predicate[r[2]] == \" \"))";
"    return {{FLOAT, tofloat(predicate[r[3][1][1]..r[3][1][2]])}, predicate[r[2] + 1..$]};";
"  endif";
"elseif ((r = match(predicate, \"^%(%?%|%#%|[a-z][a-z0-9]*%) *\")) && (length(predicate) == r[2] || predicate[r[2]] == \" \"))";
"  return {{-1, predicate[r[3][1][1]..r[3][1][2]]}, predicate[r[2] + 1..$]};";
"endif";
"";
"raise(E_INVARG, tostr(\"Unmatched literal or identifier:  \", predicate));";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D18CB68F0395F6706E1BE2B18C7023C08EFBFFD9";
"-=-=-mxyzptlk-=-=-";
.
#63:3
{predicate} = args;
if (!predicate)
elseif ((r = match(predicate, "^%(>=?%|<=?%|=[=~]?%|!=%|includes%|in%|is%) *")) && ((length(predicate) == r[2]) || (predicate[r[2]] == " ")))
return {predicate[r[3][1][1]..r[3][1][2]], predicate[r[2] + 1..$]};
endif
raise(E_INVARG, tostr("Unmatched operator:  ", predicate));
return;
"{predicate} = args;";
"";
"/* the predicate string must _not_ start with whitespace */";
"if (!predicate)";
"  ;";
"elseif ((r = match(predicate, \"^%(>=?%|<=?%|=[=~]?%|!=%|includes%|in%|is%) *\")) && (length(predicate) == r[2] || predicate[r[2]] == \" \"))";
"  return {predicate[r[3][1][1]..r[3][1][2]], predicate[r[2] + 1..$]};";
"endif";
"";
"raise(E_INVARG, tostr(\"Unmatched operator:  \", predicate));";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:AC122D01FE3F4E7A7AFDC9FC85D8A569EDEE82A9";
"-=-=-mxyzptlk-=-=-";
.
#63:4
{predicate, @args} = args;
predicate = predicate:trim();
predicate || raise(E_INVARG, "Empty predicate");
{operand1, predicate} = this:_match_literal_or_identifier(predicate);
{operator, predicate} = this:_match_operator(predicate);
{operand2, predicate} = this:_match_literal_or_identifier(predicate);
predicate && raise(E_INVARG, "Trailing predicate");
if (operator == "is")
if ((operand2[1] < 0) && (operand2[2] == "true"))
operand2 = {INT, 1};
elseif ((operand2[1] < 0) && (operand2[2] == "false"))
operand2 = {INT, 0};
else
raise(E_INVARG, tostr("Invalid operand for `is': ", operand2[2]));
endif
endif
if (operand1[1] < 0)
if (operand1[2] == "?")
{arg, @args} = args;
operand1 = {typeof(arg), arg};
elseif (operand1[2] == "#")
operand1[2] = this.id;
endif
endif
if (operand2[1] < 0)
if (operand2[2] == "?")
{arg, @args} = args;
operand2 = {typeof(arg), arg};
elseif (operand2[2] == "#")
operand2[2] = this.id;
endif
endif
return {operand1, operator, operand2};
return;
"{predicate, @args} = args;";
"";
"predicate = predicate:trim();";
"";
"predicate || raise(E_INVARG, \"Empty predicate\");";
"";
"{operand1, predicate} = this:_match_literal_or_identifier(predicate);";
"{operator, predicate} = this:_match_operator(predicate);";
"{operand2, predicate} = this:_match_literal_or_identifier(predicate);";
"";
"predicate && raise(E_INVARG, \"Trailing predicate\");";
"";
"/* handle the special case \"is true\"/\"is false\" */";
"";
"if (operator == \"is\")";
"  if (operand2[1] < 0 && operand2[2] == \"true\")";
"    operand2 = {INT, 1};";
"  elseif (operand2[1] < 0 && operand2[2] == \"false\")";
"    operand2 = {INT, 0};";
"  else";
"    raise(E_INVARG, tostr(\"Invalid operand for `is': \", operand2[2]));";
"  endif";
"endif";
"";
"/* The first item in the operand list is either -1 or a type value";
" * (INT, FLOAT, STR, etc.).  If the first item is -1, the second item";
" * is either an identifier, \"?\" or \"#\".  \"?\" is replaced by the";
" * appropriate positional argument, just as if it were a literal.  \"#\"";
" * is replaced by the special object number identifier `$ask:id()'.";
" */";
"if (operand1[1] < 0)";
"  if (operand1[2] == \"?\")";
"    {arg, @args} = args;";
"    operand1 = {typeof(arg), arg};";
"  elseif (operand1[2] == \"#\")";
"    operand1[2] = this.id;";
"  endif";
"endif";
"";
"if (operand2[1] < 0)";
"  if (operand2[2] == \"?\")";
"    {arg, @args} = args;";
"    operand2 = {typeof(arg), arg};";
"  elseif (operand2[2] == \"#\")";
"    operand2[2] = this.id;";
"  endif";
"endif";
"";
"return {operand1, operator, operand2};";
"";
"chunk_length:49";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:00E271FD5D4F40A399B0533C5F6804B487C21E6D";
"-=-=-mxyzptlk-=-=-";
.
#63:5
{from} = args;
try
caller["from"];
raise(E_INVARG, "Duplicate from");
except (E_RANGE)
caller["from"] = from;
endtry
return caller;
return;
"{from} = args;";
"try";
"  caller[\"from\"];";
"  raise(E_INVARG, \"Duplicate from\");";
"except (E_RANGE)";
"  caller[\"from\"] = from;";
"endtry";
"return caller;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:86E5DD07CCE792C6192600C8AF06C0E8AF5E44A9";
"-=-=-mxyzptlk-=-=-";
.
#63:6
attributes = args;
select = ["select" -> attributes];
caller["operations"] = `{@caller["operations"], select} ! E_RANGE => {select}';
return caller;
return;
"attributes = args;";
"select = [\"select\" -> attributes];";
"caller[\"operations\"] = `{@caller[\"operations\"], select} ! E_RANGE => {select}';";
"return caller;";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F0EC594CB3C7D7668B5353A8D123413A8CDB6455";
"-=-=-mxyzptlk-=-=-";
.
#63:7
{predicate, @args} = args;
where = ["where" -> $ask_proto:_parse_predicate(predicate, @args)];
caller["operations"] = `{@caller["operations"], where} ! E_RANGE => {where}';
return caller;
return;
"{predicate, @args} = args;";
"where = [\"where\" -> $ask_proto:_parse_predicate(predicate, @args)];";
"caller[\"operations\"] = `{@caller[\"operations\"], where} ! E_RANGE => {where}';";
"return caller;";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:8B2D947D7C3B4F67BDC1E2470D16EC2C5AF8B006";
"-=-=-mxyzptlk-=-=-";
.
#63:8
res = this:_query(caller, -1);
return length(res);
return;
"res = this:_query(caller, -1);";
"return length(res);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B56535CB5F5BC95101F0535B3743CDF4F204237D";
"-=-=-mxyzptlk-=-=-";
.
#63:9
res = this:_query(caller, -1);
return res;
return;
"res = this:_query(caller, -1);";
"return res;";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0CE8D254009C1FED0A6BDD9EA3788FF8DD02F26E";
"-=-=-mxyzptlk-=-=-";
.
#63:10
res = this:_query(caller, 1);
return res;
return;
"res = this:_query(caller, 1);";
"return res;";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0C70EEF9D363A4513D41661F0561FC0AC924A4C0";
"-=-=-mxyzptlk-=-=-";
.
#63:11
return this.id;
return;
"/* conveniently, the same value as `$model.id' */";
"return this.id;";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D46C57E31A682E5D0D6E54B1C72C46F6056D2E31";
"-=-=-mxyzptlk-=-=-";
.
#63:12
return this.errors;
return;
"/* conveniently, the same value as `$model.errors' */";
"return this.errors;";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:18698E421D2654AB626BCC5FC3477F92700476F5";
"-=-=-mxyzptlk-=-=-";
.
#65:0
set_task_perms(caller_perms());
{prototype, instance, properties, ?loud = 0} = args;
properties = this:_before_validate(prototype, instance, properties);
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
for constraints, property in (`prototype.constraints ! E_PROPNF => []')
for constraint in (constraints)
if (LIST == typeof(constraint))
{constraint, ?options = []} = constraint;
else
options = [];
endif
if ("" == constraint)
elseif ("present" == constraint)
properties = $model.validates_presence_of:validate(prototype, instance, properties, property, options);
elseif ("unique" == constraint)
properties = $model.validates_uniqueness_of:validate(prototype, instance, properties, property, options);
elseif ("immutable" == constraint)
properties = $model.validates_immutability_of:validate(prototype, instance, properties, property, options);
elseif ("format" == constraint)
properties = $model.validates_format_of:validate(prototype, instance, properties, property, options);
endif
endfor
endfor
(loud && `properties[$model.errors] ! E_RANGE') && raise("-*-invalid-*-", "Validation failed", properties);
properties = this:_after_validate(prototype, instance, properties);
return properties;
return;
"set_task_perms(caller_perms());";
"";
"{prototype, instance, properties, ?loud = 0} = args;";
"";
"properties = this:_before_validate(prototype, instance, properties);";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"for constraints, property in (`prototype.constraints ! E_PROPNF => []')";
"  for constraint in (constraints)";
"    if (LIST == typeof(constraint))";
"      {constraint, ?options = []} = constraint;";
"    else";
"      options = [];";
"    endif";
"    if (\"\" == constraint)";
"      ;";
"    elseif (\"present\" == constraint)";
"      properties = $model.validates_presence_of:validate(prototype, instance, properties, property, options);";
"    elseif (\"unique\" == constraint)";
"      properties = $model.validates_uniqueness_of:validate(prototype, instance, properties, property, options);";
"    elseif (\"immutable\" == constraint)";
"      properties = $model.validates_immutability_of:validate(prototype, instance, properties, property, options);";
"    elseif (\"format\" == constraint)";
"      properties = $model.validates_format_of:validate(prototype, instance, properties, property, options);";
"    endif";
"  endfor";
"endfor";
"";
"loud && `properties[$model.errors] ! E_RANGE' && raise(\"-*-invalid-*-\", \"Validation failed\", properties);";
"";
"properties = this:_after_validate(prototype, instance, properties);";
"";
"return properties;";
"";
"chunk_length:35";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:996C4D4E8FE6299445840AC49953FAB4F54BE917";
"-=-=-mxyzptlk-=-=-";
.
#65:1
set_task_perms(caller_perms());
{prototype, properties, ?loud = 0} = args;
(typeof(properties) == MAP) || raise(E_INVARG, "properties must be a map");
if ((typeof(prototype) != OBJ) || (!valid(prototype)))
properties[$model.errors] = "invalid prototype";
return properties;
endif
instance = $nothing;
properties = this:validate(prototype, instance, properties, loud);
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
properties = this:_before_create(prototype, instance, properties);
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
try
instance = create(prototype);
properties[$model.id] = instance;
except (E_PERM)
properties[$model.errors] = "permission denied";
return properties;
except (E_QUOTA)
properties[$model.errors] = "quota exceeded";
return properties;
endtry
for value, property in (properties)
if (`property in prototype.accessible ! E_PROPNF')
temp = $shapes:write_value(instance, property, ["Value" -> ["value" -> value]]);
if (`error = temp["Error"]["diagnostic"] ! E_RANGE')
properties = properties:set_value_by_path({$model.errors, property}, error);
endif
properties[property] = temp["Value"]["value"];
endif
endfor
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
properties = this:_after_create(prototype, instance, properties);
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
return this:read(prototype, instance);
return;
"set_task_perms(caller_perms());";
"";
"{prototype, properties, ?loud = 0} = args;";
"";
"(typeof(properties) == MAP) || raise(E_INVARG, \"properties must be a map\");";
"";
"if (typeof(prototype) != OBJ || !valid(prototype))";
"  properties[$model.errors] = \"invalid prototype\";";
"  return properties;";
"endif";
"";
"instance = $nothing;";
"";
"properties = this:validate(prototype, instance, properties, loud);";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"properties = this:_before_create(prototype, instance, properties);";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"try";
"  instance = create(prototype);";
"  properties[$model.id] = instance;";
"except (E_PERM)";
"  properties[$model.errors] = \"permission denied\";";
"  return properties;";
"except (E_QUOTA)";
"  properties[$model.errors] = \"quota exceeded\";";
"  return properties;";
"endtry";
"";
"for value, property in (properties)";
"  if (`property in prototype.accessible ! E_PROPNF')";
"    temp = $shapes:write_value(instance, property, [\"Value\" -> [\"value\" -> value]]);";
"    if (`error = temp[\"Error\"][\"diagnostic\"] ! E_RANGE')";
"      properties = properties:set_value_by_path({$model.errors, property}, error);";
"    endif";
"    properties[property] = temp[\"Value\"][\"value\"];";
"  endif";
"endfor";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"properties = this:_after_create(prototype, instance, properties);";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"return this:read(prototype, instance);";
"";
"chunk_length:53";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9094A3498D54EE7FBAD3193E9D686292F3FDA546";
"-=-=-mxyzptlk-=-=-";
.
#65:2
set_task_perms(caller_perms());
{prototype, instance, properties, ?loud = 0} = args;
(typeof(properties) == MAP) || raise(E_INVARG, "properties must be a map");
if (((typeof(prototype) != OBJ) || (!valid(prototype))) || (!isa(instance, prototype)))
properties[$model.errors] = "invalid prototype";
return properties;
endif
properties = this:validate(prototype, instance, properties, loud);
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
properties = this:_before_update(prototype, instance, properties);
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
properties[$model.id] = instance;
for value, property in (properties)
if (`property in prototype.accessible ! E_PROPNF')
temp = $shapes:write_value(instance, property, ["Value" -> ["value" -> value]]);
if (`error = temp["Error"]["diagnostic"] ! E_RANGE')
properties = properties:set_value_by_path({$model.errors, property}, error);
endif
properties[property] = temp["Value"]["value"];
endif
endfor
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
properties = this:_after_update(prototype, instance, properties);
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
return this:read(prototype, instance);
return;
"set_task_perms(caller_perms());";
"";
"{prototype, instance, properties, ?loud = 0} = args;";
"";
"(typeof(properties) == MAP) || raise(E_INVARG, \"properties must be a map\");";
"";
"if (typeof(prototype) != OBJ || !valid(prototype) || !isa(instance, prototype))";
"  properties[$model.errors] = \"invalid prototype\";";
"  return properties;";
"endif";
"";
"properties = this:validate(prototype, instance, properties, loud);";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"properties = this:_before_update(prototype, instance, properties);";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"properties[$model.id] = instance;";
"";
"for value, property in (properties)";
"  if (`property in prototype.accessible ! E_PROPNF')";
"    temp = $shapes:write_value(instance, property, [\"Value\" -> [\"value\" -> value]]);";
"    if (`error = temp[\"Error\"][\"diagnostic\"] ! E_RANGE')";
"      properties = properties:set_value_by_path({$model.errors, property}, error);";
"    endif";
"    properties[property] = temp[\"Value\"][\"value\"];";
"  endif";
"endfor";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"properties = this:_after_update(prototype, instance, properties);";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"return this:read(prototype, instance);";
"";
"chunk_length:42";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C8EF776DD7FC71F04B9E9471BEF542BE23ECB42E";
"-=-=-mxyzptlk-=-=-";
.
#65:3
set_task_perms(caller_perms());
{prototype, instance} = args;
if (((typeof(prototype) != OBJ) || (!valid(prototype))) || (!isa(instance, prototype)))
return [$model.errors -> "invalid prototype"];
endif
properties = [];
properties[$model.id] = instance;
for property in (`prototype.accessible ! E_PROPNF => {}')
try
properties[property] = instance.(property);
except (E_PERM)
properties = properties:set_value_by_path({$model.errors, property}, "permission denied");
endtry
endfor
return properties;
return;
"set_task_perms(caller_perms());";
"";
"{prototype, instance} = args;";
"";
"if (typeof(prototype) != OBJ || !valid(prototype) || !isa(instance, prototype))";
"  return [$model.errors -> \"invalid prototype\"];";
"endif";
"";
"properties = [];";
"";
"properties[$model.id] = instance;";
"";
"for property in (`prototype.accessible ! E_PROPNF => {}')";
"  try";
"    properties[property] = instance.(property);";
"  except (E_PERM)";
"    properties = properties:set_value_by_path({$model.errors, property}, \"permission denied\");";
"  endtry";
"endfor";
"";
"return properties;";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3DEBDE00FB50329462550C19FC51CD38CC9B1634";
"-=-=-mxyzptlk-=-=-";
.
#65:4
$private();
set_task_perms(caller_perms());
{prototype, instance, properties} = args;
if (r = match(verb, "^_%(before%|after%)_%(%validate%|create%|update%)$"))
callback = tostr(verb[r[3][1][1]..r[3][1][2]], "_", verb[r[3][2][1]..r[3][2][2]]);
if (respond_to(prototype, callback))
properties = prototype:(callback)(prototype, instance, properties);
(typeof(properties) == MAP) || raise(E_TYPE, "Invalid returned value", properties);
endif
endif
return properties;
return;
"$private();";
"";
"set_task_perms(caller_perms());";
"";
"{prototype, instance, properties} = args;";
"";
"if (r = match(verb, \"^_%(before%|after%)_%(%validate%|create%|update%)$\"))";
"  callback = tostr(verb[r[3][1][1]..r[3][1][2]], \"_\", verb[r[3][2][1]..r[3][2][2]]);";
"  if (respond_to(prototype, callback))";
"    properties = prototype:(callback)(prototype, instance, properties);";
"    typeof(properties) == MAP || raise(E_TYPE, \"Invalid returned value\", properties);";
"  endif";
"endif";
"";
"return properties;";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2E339CD45EAA1B9296CA5424A2EBB4F7F5B16833";
"-=-=-mxyzptlk-=-=-";
.
#65:5
{prototype, @values} = args;
accessible = setadd(`prototype.accessible ! E_PROPNF => {}', $model.id);
if (verb == "find")
return $ask:from(prototype):select(@accessible);
elseif (r = match(verb, "^find_by_%([a-zA-Z0-9_]+%)$"))
name = r[4][r[3][1][1]..r[3][1][2]];
return $ask:from(prototype):select(@accessible):where(tostr(name, " = ?"), @values);
endif
raise(E_INVARG);
return;
"{prototype, @values} = args;";
"";
"accessible = setadd(`prototype.accessible ! E_PROPNF => {}', $model.id);";
"";
"if (verb == \"find\")";
"  return $ask:from(prototype):select(@accessible);";
"";
"elseif (r = match(verb, \"^find_by_%([a-zA-Z0-9_]+%)$\"))";
"  name = r[4][r[3][1][1]..r[3][1][2]];";
"  return $ask:from(prototype):select(@accessible):where(tostr(name, \" = ?\"), @values);";
"";
"endif";
"";
"raise(E_INVARG);";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:397C76FC5D8E9E8B0EC0BE361357B9E01171E880";
"-=-=-mxyzptlk-=-=-";
.
#67:0
set_task_perms(caller_perms());
return $model:(verb)(this, @args);
return;
"set_task_perms(caller_perms());";
"";
"/* Verbs `create()', `find()' and `find_by_*()' only require a valid";
" * prototype.  Use `this'.";
" */";
"";
"return $model:(verb)(this, @args);";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9B45952FF2F2F705E3135AB046B4F2DB06AF1C86";
"-=-=-mxyzptlk-=-=-";
.
#67:1
set_task_perms(caller_perms());
if (args && (typeof(args[1]) == OBJ))
return $model:(verb)(this, @args);
else
for parent in (parents(this))
if (isa(parent, $model.model_proto))
return $model:(verb)(parent, this, @args);
endif
endfor
endif
return;
"set_task_perms(caller_perms());";
"";
"/* Verbs `validate()', `update()' and `read()' require a valid";
" * prototype and a valid instance.  If neither are provided,";
" * the prototype is the first parent that is a model prototype";
" * and the instance is `this'.";
" */";
"";
"if (args && typeof(args[1]) == OBJ)";
"  return $model:(verb)(this, @args);";
"else";
"  for parent in (parents(this))";
"    if (isa(parent, $model.model_proto))";
"      return $model:(verb)(parent, this, @args);";
"    endif";
"  endfor";
"endif";
"";
"chunk_length:17";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B4E95A4D90B448D4686BF0A59C7B0EFA9FA2F2AA";
"-=-=-mxyzptlk-=-=-";
.
#68:0
{prototype, instance, properties, name, ?options = []} = args;
return properties;
return;
"{prototype, instance, properties, name, ?options = []} = args;";
"";
"return properties;";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:67FE5D7C3F0338E4E7C76CB2951354635A13F833";
"-=-=-mxyzptlk-=-=-";
.
#68:1
{properties, name, message} = args;
if (errors = properties:value_by_path({$model.errors, name}))
properties = properties:set_value_by_path({$model.errors, name}, (typeof(errors) == LIST) ? {@errors, message} | {errors, message});
else
properties = properties:set_value_by_path({$model.errors, name}, message);
endif
return properties;
return;
"{properties, name, message} = args;";
"";
"if (errors = properties:value_by_path({$model.errors, name}))";
"  properties = properties:set_value_by_path({$model.errors, name}, typeof(errors) == LIST ? {@errors, message} | {errors, message});";
"else";
"  properties = properties:set_value_by_path({$model.errors, name}, message);";
"endif";
"";
"return properties;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C12EC174BC809275A4A14E90F5178CEFD8303C3D";
"-=-=-mxyzptlk-=-=-";
.
#68:2
set_task_perms(caller_perms());
{h, k} = args;
if (typeof(h) == MAP)
present = (typeof(v = `h[k] ! E_RANGE') == STR) ? match(v, "[^ ]") | v;
else
present = (typeof(v = `h.(k) ! E_PROPNF') == STR) ? match(v, "[^ ]") | v;
endif
return ("is_present" == verb) ? !(!present) | (!present);
return;
"set_task_perms(caller_perms());";
"";
"{h, k} = args;";
"";
"if (typeof(h) == MAP)";
"  present = typeof(v = `h[k] ! E_RANGE') == STR ?";
"              match(v, \"[^ ]\") |";
"              v;";
"else";
"  present = typeof(v = `h.(k) ! E_PROPNF') == STR ?";
"              match(v, \"[^ ]\") |";
"              v;";
"endif";
"";
"return (\"is_present\" == verb) ? !!present | !present;";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5D3B24A96E58FE63A1849C19C223D4F65011F313";
"-=-=-mxyzptlk-=-=-";
.
#69:0
set_task_perms(caller_perms());
{prototype, instance, properties, name, ?options = []} = args;
if (this:is_blank(properties, name) && (!(valid(instance) && this:is_present(instance, name))))
properties = this:add_error(properties, name, "can't be blank");
endif
return properties;
return;
"set_task_perms(caller_perms());";
"";
"{prototype, instance, properties, name, ?options = []} = args;";
"";
"if (this:is_blank(properties, name) && !(valid(instance) && this:is_present(instance, name)))";
"  properties = this:add_error(properties, name, \"can't be blank\");";
"endif";
"";
"return properties;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B646EB67CE2967ABDF993394C5B736CBF6119220";
"-=-=-mxyzptlk-=-=-";
.
#70:0
set_task_perms(caller_perms());
{prototype, instance, properties, name, ?options = []} = args;
if ((`properties[name] ! E_RANGE' != E_RANGE) && (!(valid(instance) && (properties[name] == instance.(name)))))
if (valid($ask:from(prototype):where(name + " = ?", properties[name]):one()))
properties = this:add_error(properties, name, "is already taken");
endif
endif
return properties;
return;
"set_task_perms(caller_perms());";
"";
"{prototype, instance, properties, name, ?options = []} = args;";
"";
"if (`properties[name] ! E_RANGE' != E_RANGE && !(valid(instance) && properties[name] == instance.(name)))";
"  if (valid($ask:from(prototype):where(name + \" = ?\", properties[name]):one()))";
"    properties = this:add_error(properties, name, \"is already taken\");";
"  endif";
"endif";
"";
"return properties;";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:63D90B2847224BDDA7400772E0D7BC9D74207EA1";
"-=-=-mxyzptlk-=-=-";
.
#71:0
set_task_perms(caller_perms());
{prototype, instance, properties, name, ?options = []} = args;
if ((`properties[name] ! E_RANGE' != E_RANGE) && (valid(instance) && (properties[name] != instance.(name))))
properties = this:add_error(properties, name, "can't be changed");
endif
return properties;
return;
"set_task_perms(caller_perms());";
"";
"{prototype, instance, properties, name, ?options = []} = args;";
"";
"if (`properties[name] ! E_RANGE' != E_RANGE && (valid(instance) && properties[name] != instance.(name)))";
"  properties = this:add_error(properties, name, \"can't be changed\");";
"endif";
"";
"return properties;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:38D76B88B8BD9959CC3564E753DFC10D4D8C97EE";
"-=-=-mxyzptlk-=-=-";
.
#72:0
{prototype, instance, properties, name, ?options = []} = args;
pattern = `options["pattern"] ! E_RANGE => "^$"';
message = `options["message"] ! E_RANGE => "is not valid"';
if ((`properties[name] ! E_RANGE' != E_RANGE) && (!match(properties[name], pattern)))
properties = this:add_error(properties, name, message);
endif
return properties;
return;
"{prototype, instance, properties, name, ?options = []} = args;";
"";
"pattern = `options[\"pattern\"] ! E_RANGE => \"^$\"';";
"message = `options[\"message\"] ! E_RANGE => \"is not valid\"';";
"";
"if (`properties[name] ! E_RANGE' != E_RANGE && !match(properties[name], pattern))";
"  properties = this:add_error(properties, name, message);";
"endif";
"";
"return properties;";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:52898C132056483AE48A3E3D89923F6E938A81A6";
"-=-=-mxyzptlk-=-=-";
.
#73:0
set_task_perms(caller_perms());
{prototype, instance, properties, name, ?options = []} = args;
if (valid(instance))
if (!(`properties[name] ! E_RANGE' != E_RANGE))
return this:add_error(properties, name, "is required");
elseif (properties[name] != instance.(name))
return this:add_error(properties, name, "is invalid");
endif
else
if (`properties[name] ! E_RANGE' != E_RANGE)
return this:add_error(properties, name, "is invalid");
endif
endif
properties[name] = `properties[name] ! E_RANGE => 0' + 1;
return properties;
return;
"set_task_perms(caller_perms());";
"";
"{prototype, instance, properties, name, ?options = []} = args;";
"";
"if (valid(instance))";
"  if (!(`properties[name] ! E_RANGE' != E_RANGE))";
"    return this:add_error(properties, name, \"is required\");";
"  elseif (properties[name] != instance.(name))";
"    return this:add_error(properties, name, \"is invalid\");";
"  endif";
"else";
"  if (`properties[name] ! E_RANGE' != E_RANGE)";
"    return this:add_error(properties, name, \"is invalid\");";
"  endif";
"endif";
"";
"properties[name] = `properties[name] ! E_RANGE => 0' + 1;";
"";
"return properties;";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:00949BFF81FF829D374CB54CF26FAF20FC2A09FA";
"-=-=-mxyzptlk-=-=-";
.
#76:0
$restrict_to_caller($system, "server_started");
try
file_stat(".");
`file_mkdir("private") || server_log(tostr(file_version(), ": created \"files/private\"")) ! E_FILE';
`file_mkdir("private/app") || server_log(tostr(file_version(), ": created \"files/private/app\"")) ! E_FILE';
`file_mkdir("public") || server_log(tostr(file_version(), ": created \"files/public\"")) ! E_FILE';
`file_mkdir("public/app") || server_log(tostr(file_version(), ": created \"files/public/app\"")) ! E_FILE';
`file_mkdir("public/css") || server_log(tostr(file_version(), ": created \"files/public/css\"")) ! E_FILE';
`file_mkdir("public/img") || server_log(tostr(file_version(), ": created \"files/public/img\"")) ! E_FILE';
`file_mkdir("public/js") || server_log(tostr(file_version(), ": created \"files/public/js\"")) ! E_FILE';
`file_mkdir("tmp") || server_log(tostr(file_version(), ": created \"files/tmp\"")) ! E_FILE';
except (ANY)
server_log(tostr(file_version(), ": missing \"files\" directory"));
endtry
return;
"$restrict_to_caller($system, \"server_started\");";
"try";
"  file_stat(\".\");";
"  `file_mkdir(\"private\") || server_log(tostr(file_version(), \": created \\\"files/private\\\"\")) ! E_FILE';";
"  `file_mkdir(\"private/app\") || server_log(tostr(file_version(), \": created \\\"files/private/app\\\"\")) ! E_FILE';";
"  `file_mkdir(\"public\") || server_log(tostr(file_version(), \": created \\\"files/public\\\"\")) ! E_FILE';";
"  `file_mkdir(\"public/app\") || server_log(tostr(file_version(), \": created \\\"files/public/app\\\"\")) ! E_FILE';";
"  `file_mkdir(\"public/css\") || server_log(tostr(file_version(), \": created \\\"files/public/css\\\"\")) ! E_FILE';";
"  `file_mkdir(\"public/img\") || server_log(tostr(file_version(), \": created \\\"files/public/img\\\"\")) ! E_FILE';";
"  `file_mkdir(\"public/js\") || server_log(tostr(file_version(), \": created \\\"files/public/js\\\"\")) ! E_FILE';";
"  `file_mkdir(\"tmp\") || server_log(tostr(file_version(), \": created \\\"files/tmp\\\"\")) ! E_FILE';";
"except (ANY)";
"  server_log(tostr(file_version(), \": missing \\\"files\\\" directory\"));";
"endtry";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:494FB4EEE91B453CA651336A969FA2E47144B1ED";
"-=-=-mxyzptlk-=-=-";
.
#77:0
$permit("wizard", "owner");
{?full = 1} = args;
if (full)
return mapvalues(this.attachments);
else
return mapkeys(this.attachments);
endif
return;
"$permit(\"wizard\", \"owner\");";
"";
"{?full = 1} = args;";
"";
"if (full)";
"  return mapvalues(this.attachments);";
"else";
"  return mapkeys(this.attachments);";
"endif";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4B94E55E2C7EDCD795795DEA27557075D64CDF49";
"-=-=-mxyzptlk-=-=-";
.
#77:1
$permit("wizard", "owner");
{attachment, ?option = 0} = args;
if (!option)
return this.attachments[attachment];
elseif (`value = this.attachments[attachment][option] ! E_RANGE')
return value;
elseif (option == "data")
fh = -1;
data = "";
path = this.attachments[attachment]["path"];
size = this.attachments[attachment]["size"];
try
fh = file_open(path, "r-bn");
while ((pos = file_tell(fh)) != size)
chunk = file_read(fh, size - pos);
data = data ? data + chunk | chunk;
endwhile
finally
(fh > -1) && file_close(fh);
endtry
return data;
else
raise(E_INVARG);
endif
return;
"$permit(\"wizard\", \"owner\");";
"";
"{attachment, ?option = 0} = args;";
"";
"if (!option)";
"  return this.attachments[attachment];";
"elseif (`value = this.attachments[attachment][option] ! E_RANGE')";
"  return value;";
"elseif (option == \"data\")";
"  fh = -1;";
"  data = \"\";";
"  path = this.attachments[attachment][\"path\"];";
"  size = this.attachments[attachment][\"size\"];";
"  try";
"    fh = file_open(path, \"r-bn\");";
"    while ((pos = file_tell(fh)) != size)";
"      chunk = file_read(fh, size - pos);";
"      data = data ? data + chunk | chunk;";
"    endwhile";
"  finally";
"    (fh > -1) && file_close(fh);";
"  endtry";
"  return data;";
"else";
"  raise(E_INVARG);";
"endif";
"";
"chunk_length:26";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:09868DF21A3E53C9FD1CE92F4F523BA1F8857827";
"-=-=-mxyzptlk-=-=-";
.
#77:2
$permit("wizard", "owner");
{attachment} = args;
`this.attachments[attachment] ! E_RANGE => raise(E_INVARG, tostr("No such attachment: ", attachment), attachment)';
`file_stat(filename = this.attachments[attachment]["path"]) ! E_RANGE, E_FILE => raise(E_INVARG, tostr("No such attached file: ", filename), filename)';
return 1;
return;
"$permit(\"wizard\", \"owner\");";
"";
"{attachment} = args;";
"";
"/* Raises E_INVARG if the attachment is not an attachment; raises";
" * E_FILE if the associated file does not exist.";
" */";
"`this.attachments[attachment] ! E_RANGE => raise(E_INVARG, tostr(\"No such attachment: \", attachment), attachment)';";
"`file_stat(filename = this.attachments[attachment][\"path\"]) ! E_RANGE, E_FILE => raise(E_INVARG, tostr(\"No such attached file: \", filename), filename)';";
"";
"return 1;";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6E03C948540B6FB85C955A0034BC4B4C6152EFD7";
"-=-=-mxyzptlk-=-=-";
.
#77:3
$restrict_to_builtin("recycle");
args && raise(E_ARGS);
for attachment in (this.attachments)
`file_remove(attachment["path"]) ! E_RANGE, E_FILE';
endfor
return;
"$restrict_to_builtin(\"recycle\");";
"";
"args && raise(E_ARGS);";
"";
"for attachment in (this.attachments)";
"  `file_remove(attachment[\"path\"]) ! E_RANGE, E_FILE'; /* if the file is missing, move on... */";
"endfor";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:11679240172E789BD6A0031B98447E9A887C2E2F";
"-=-=-mxyzptlk-=-=-";
.
#77:4
$private();
{name, pool, ?mkdir = 1} = args;
name || raise(E_INVARG, name);
`this.attachment_pools[pool] ! E_RANGE' || raise(E_INVARG, pool);
path = string_hash(tostr(this, name, pool), "md5");
path[3] = "/";
path[6] = "/";
path[9] = "/";
if (mkdir)
parts = {path[1..2], path[1..5], path[1..8]};
for part in (parts)
`file_mkdir(tostr(this.attachment_pools[pool], "/", part)) ! E_FILE';
endfor
endif
return path;
return;
"$private();";
"";
"{name, pool, ?mkdir = 1} = args;";
"";
"name || raise(E_INVARG, name);";
"`this.attachment_pools[pool] ! E_RANGE' || raise(E_INVARG, pool);";
"";
"path = string_hash(tostr(this, name, pool), \"md5\");";
"path[3] = \"/\";";
"path[6] = \"/\";";
"path[9] = \"/\";";
"";
"if (mkdir)";
"  parts = {path[1..2], path[1..5], path[1..8]};";
"  for part in (parts)";
"    `file_mkdir(tostr(this.attachment_pools[pool], \"/\", part)) ! E_FILE';";
"  endfor";
"endif";
"";
"return path;";
"";
"chunk_length:20";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5011167A064F72953458E0B2BC00F33F0591576A";
"-=-=-mxyzptlk-=-=-";
.
#77:5
$permit("wizard", "owner");
{data, attachment, pool, type, ?processors = []} = args;
this:_check_limit();
(typeof(data) == STR) || raise(E_TYPE);
`this.attachments[attachment] ! E_RANGE' && raise(E_INVARG, tostr("Already an attachment: ", attachment), attachment);
`this.attachment_pools[pool] ! E_RANGE' || raise(E_INVARG, tostr("Invalid pool: ", pool), pool);
path = tostr(this.attachment_pools[pool], "/", this:_path_for(attachment, pool));
fh = -1;
try
fh = file_open(path, "w-bn");
file_write(fh, data);
finally
(fh > -1) && file_close(fh);
endtry
size = file_size(path);
this.attachments[attachment] = {attachment, path, pool, type};
this.attachments[attachment] = ["name" -> attachment, "path" -> path, "size" -> size, "type" -> type, "pool" -> pool];
for _, process in (processors)
if ("thumbnail" == process)
sizes = processors["thumbnail"];
sizes = (typeof(sizes) == STR) ? {sizes} | sizes;
this:_thumbnail(attachment, path, pool, type, sizes);
else
raise(E_INVARG, process);
endif
endfor
return this;
return;
"$permit(\"wizard\", \"owner\");";
"";
"{data, attachment, pool, type, ?processors = []} = args;";
"";
"this:_check_limit();";
"";
"typeof(data) == STR || raise(E_TYPE);";
"`this.attachments[attachment] ! E_RANGE' && raise(E_INVARG, tostr(\"Already an attachment: \", attachment), attachment);";
"`this.attachment_pools[pool] ! E_RANGE' || raise(E_INVARG, tostr(\"Invalid pool: \", pool), pool);";
"";
"path = tostr(this.attachment_pools[pool], \"/\", this:_path_for(attachment, pool));";
"";
"fh = -1;";
"try";
"  fh = file_open(path, \"w-bn\");";
"  file_write(fh, data);";
"finally";
"  (fh > -1) && file_close(fh);";
"endtry";
"";
"size = file_size(path);";
"";
"this.attachments[attachment] = {attachment, path, pool, type};";
"this.attachments[attachment] = [\"name\" -> attachment, \"path\" -> path, \"size\" -> size, \"type\" -> type, \"pool\" -> pool];";
"";
"for _, process in (processors)";
"  if (\"thumbnail\" == process)";
"    sizes = processors[\"thumbnail\"];";
"    sizes = typeof(sizes) == STR ? {sizes} | sizes;";
"    this:_thumbnail(attachment, path, pool, type, sizes);";
"  else";
"    raise(E_INVARG, process);";
"  endif";
"endfor";
"";
"return this;";
"";
"chunk_length:36";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:43B5B4F10D7EC1F96065734938CB29BF72D8D077";
"-=-=-mxyzptlk-=-=-";
.
#77:6
$permit("wizard", "owner");
{filename, attachment, pool, type, ?processors = []} = args;
this:_check_limit();
(typeof(filename) == STR) || raise(E_TYPE);
`this.attachments[attachment] ! E_RANGE' && raise(E_INVARG, tostr("Already an attachment: ", attachment), attachment);
`this.attachment_pools[pool] ! E_RANGE' || raise(E_INVARG, tostr("Invalid pool: ", pool), pool);
match(filename, "^/?tmp/.") || raise(E_INVARG, tostr("Must be a temporary file: ", filename), filename);
(file_type(filename) == "reg") || raise(E_INVARG, tostr("Must be a regular file: ", filename), filename);
for path in ({filename, attachment})
index(path, "./") && raise(E_INVARG, path);
index(path, "..") && raise(E_INVARG, path);
endfor
old_path = filename;
new_path = tostr(this.attachment_pools[pool], "/", this:_path_for(attachment, pool));
file_rename(old_path, new_path);
size = file_size(new_path);
this.attachments[attachment] = {attachment, new_path, pool, type};
this.attachments[attachment] = ["name" -> attachment, "path" -> new_path, "size" -> size, "type" -> type, "pool" -> pool];
for _, process in (processors)
if ("thumbnail" == process)
sizes = processors["thumbnail"];
sizes = (typeof(sizes) == STR) ? {sizes} | sizes;
this:_thumbnail(attachment, new_path, pool, type, sizes);
else
raise(E_INVARG, process);
endif
endfor
return this;
return;
"$permit(\"wizard\", \"owner\");";
"";
"{filename, attachment, pool, type, ?processors = []} = args;";
"";
"this:_check_limit();";
"";
"typeof(filename) == STR || raise(E_TYPE);";
"`this.attachments[attachment] ! E_RANGE' && raise(E_INVARG, tostr(\"Already an attachment: \", attachment), attachment);";
"`this.attachment_pools[pool] ! E_RANGE' || raise(E_INVARG, tostr(\"Invalid pool: \", pool), pool);";
"";
"(match(filename, \"^/?tmp/.\")) || raise(E_INVARG, tostr(\"Must be a temporary file: \", filename), filename);";
"(file_type(filename) == \"reg\") || raise(E_INVARG, tostr(\"Must be a regular file: \", filename), filename);";
"";
"for path in ({filename, attachment})";
"  index(path, \"./\") && raise(E_INVARG, path);";
"  index(path, \"..\") && raise(E_INVARG, path);";
"endfor";
"";
"old_path = filename;";
"new_path = tostr(this.attachment_pools[pool], \"/\", this:_path_for(attachment, pool));";
"file_rename(old_path, new_path);";
"";
"size = file_size(new_path);";
"";
"this.attachments[attachment] = {attachment, new_path, pool, type};";
"this.attachments[attachment] = [\"name\" -> attachment, \"path\" -> new_path, \"size\" -> size, \"type\" -> type, \"pool\" -> pool];";
"";
"for _, process in (processors)";
"  if (\"thumbnail\" == process)";
"    sizes = processors[\"thumbnail\"];";
"    sizes = typeof(sizes) == STR ? {sizes} | sizes;";
"    this:_thumbnail(attachment, new_path, pool, type, sizes);";
"  else";
"    raise(E_INVARG, process);";
"  endif";
"endfor";
"";
"return this;";
"";
"chunk_length:38";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E8D005C377A1CF4345A68C85CEAEBEC971958B9D";
"-=-=-mxyzptlk-=-=-";
.
#77:7
$permit("wizard", "owner");
{attachment} = args;
`this.attachments[attachment] ! E_RANGE' || raise(E_INVARG, tostr("No such attachment: ", attachment), attachment);
`file_remove(this.attachments[attachment]["path"]) ! E_RANGE, E_FILE';
this.attachments = mapdelete(this.attachments, attachment);
return this;
return;
"$permit(\"wizard\", \"owner\");";
"";
"{attachment} = args;";
"";
"`this.attachments[attachment] ! E_RANGE' || raise(E_INVARG, tostr(\"No such attachment: \", attachment), attachment);";
"";
"`file_remove(this.attachments[attachment][\"path\"]) ! E_RANGE, E_FILE';";
"";
"this.attachments = mapdelete(this.attachments, attachment);";
"";
"return this;";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2A1E791398FFB08044F57E069C493272A8E0377E";
"-=-=-mxyzptlk-=-=-";
.
#77:8
$private();
{path} = args;
try
{code, out, ERR} = exec({"identify", "-format", "%m", path});
except (E_INVARG, E_FILE)
return 0;
endtry
code && raise(E_INVARG, tostr("Can't identify: ", decode_binary(ERR)[1]));
return decode_binary(out)[1];
return;
"$private();";
"";
"{path} = args;";
"";
"try";
"  {code, out, err} = exec({\"identify\", \"-format\", \"%m\", path});";
"except (E_INVARG, E_FILE)";
"  return 0;";
"endtry";
"";
"code && raise(E_INVARG, tostr(\"Can't identify: \", decode_binary(err)[1]));";
"";
"return decode_binary(out)[1];";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:CBC9E169942E62FE158B7341C7A667DB5A5CE85F";
"-=-=-mxyzptlk-=-=-";
.
#77:9
$private();
{attachment, path, pool, type, sizes} = args;
if (!this:_identify(tostr("files/", path)))
return;
endif
for size in (sizes)
this:_check_limit();
match(size, "^%([1-9][0-9][0-9]?%)x%([1-9][0-9][0-9]?%)$") || raise(E_INVARG, size);
attachment = size + ".png";
thumbnail = tostr(this.attachment_pools[pool], "/", this:_path_for(attachment, pool));
exec({"convert", tostr("files/", path), "-thumbnail", size, "-bordercolor", "white", "-border", "60", "-gravity", "center", "-crop", size + "+0+0", "+repage", tostr("files/", thumbnail)});
this.attachments[size + ".png"] = {size + ".png", thumbnail, pool, "image/png"};
this.attachments[attachment] = ["name" -> attachment, "path" -> thumbnail, "size" -> file_size(thumbnail), "type" -> "image/png", "pool" -> pool];
endfor
return;
"$private();";
"";
"{attachment, path, pool, type, sizes} = args;";
"";
"/* raise an error if we can't identify the file type */";
"/* but don't raise an error if we can't identify at all */";
"if (!this:_identify(tostr(\"files/\", path)))";
"  return;";
"endif";
"";
"for size in (sizes)";
"  this:_check_limit();";
"  match(size, \"^%([1-9][0-9][0-9]?%)x%([1-9][0-9][0-9]?%)$\") || raise(E_INVARG, size);";
"  attachment = size + \".png\";";
"  thumbnail = tostr(this.attachment_pools[pool], \"/\", this:_path_for(attachment, pool));";
"  exec({\"convert\", tostr(\"files/\", path), \"-thumbnail\", size, \"-bordercolor\", \"white\", \"-border\", \"60\", \"-gravity\", \"center\", \"-crop\", size + \"+0+0\", \"+repage\", tostr(\"files/\", thumbnail)});";
"  this.attachments[size + \".png\"] = {size + \".png\", thumbnail, pool, \"image/png\"};";
"  this.attachments[attachment] = [\"name\" -> attachment, \"path\" -> thumbnail, \"size\" -> file_size(thumbnail), \"type\" -> \"image/png\", \"pool\" -> pool];";
"endfor";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:92B08D48B59BD0224852AC07FB4E283C90FE84E9";
"-=-=-mxyzptlk-=-=-";
.
#77:10
$private();
(length(this.attachments) < this.attachment_limit) || raise(E_QUOTA);
return;
"$private();";
"";
"(length(this.attachments) < this.attachment_limit) || raise(E_QUOTA);";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2605769F71081BDE86193A8F286D9AD2D2F1270A";
"-=-=-mxyzptlk-=-=-";
.
#78:0
$restrict_to_caller($composed);
$frobs = setadd($frobs, $dialog.request_proto);
$frobs = setadd($frobs, $dialog.response_proto);
return;
"$restrict_to_caller($composed);";
"";
"$frobs = setadd($frobs, $dialog.request_proto);";
"$frobs = setadd($frobs, $dialog.response_proto);";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5117D37A847185B7404DEEF25D40FB17E3B456C3";
"-=-=-mxyzptlk-=-=-";
.
#78:1
$restrict_to_caller($composed);
$frobs = setremove($frobs, $dialog.request_proto);
$frobs = setremove($frobs, $dialog.response_proto);
return;
"$restrict_to_caller($composed);";
"";
"$frobs = setremove($frobs, $dialog.request_proto);";
"$frobs = setremove($frobs, $dialog.response_proto);";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:7E3D89A2E3AE481EDBA7F957A5D6614A713B015E";
"-=-=-mxyzptlk-=-=-";
.
#81:0
{h, ?p = ""} = args;
q = "";
for vl, k in (h)
for v in ((typeof(vl) == LIST) ? vl | {vl})
q = q ? q + "&" | q;
if (typeof(v) == MAP)
q = tostr(q, this:generate_query_string(v, ((p + "[") + k) + "]"));
else
q = tostr(q, p, k, "=", v);
endif
endfor
endfor
return q;
.
#81:1
{s, ?c = 0} = args;
if (!s)
return [];
endif
h = [];
l = {};
s = s + "&";
while (s)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (c >= 1000)
raise("-*-parameters-is-too-long-*-");
endif
c = c + 1;
i = index(s, "&");
l = {@l, s[1..i - 1]};
s[1..i] = "";
endwhile
for p in (l)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
i = index(p, "=");
f = i ? p[1..i - 1] | p;
v = i ? p[i + 1..$] | "";
if (`h[f] ! E_RANGE' != E_RANGE)
h[f] = {@h[f], v};
else
h[f] = v;
endif
endfor
return h;
.
#81:2
{uri} = args;
new = "";
while (uri)
if (r = match(uri, "[][!*'();:@&=+$,?#/ ]"))
i = uri[r[1]..r[2]] in this.reserved;
new = (new + uri[1..r[1] - 1]) + this.escaped[i];
uri[1..r[2]] = "";
else
new = tostr(new, uri);
uri = "";
endif
endwhile
return new;
.
#81:3
{uri} = args;
new = "";
while (uri)
if (r = match(uri, "%%[a-fA-F0-9][a-fA-F0-9]%|%+"))
chr = (uri[r[1]] != "+") ? "~" + uri[r[1] + 1..r[2]] | "~20";
new = (new + uri[1..r[1] - 1]) + decode_binary(chr)[1];
uri[1..r[2]] = "";
else
new = tostr(new, uri);
uri = "";
endif
endwhile
return new;
.
#82:0
$private();
server_log(tostr(@args));
return;
"$private();";
"";
"server_log(tostr(@args));";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:650D9D9FCADD450749A1A67E616832EAFF78DC8D";
"-=-=-mxyzptlk-=-=-";
.
#82:1
$private();
bytes = {};
for i in [1..128 / 3]
n = random((256 * 256) * 256);
while (n)
bytes = {n % 256, @bytes};
n = n / 256;
endwhile
endfor
return encode_binary(bytes);
return;
"$private();";
"";
"bytes = {};";
"for i in [1..128 / 3]";
"  n = random(256 * 256 * 256);";
"  while (n)";
"    bytes = {n % 256, @bytes};";
"    n = n / 256;";
"  endwhile";
"endfor";
"";
"return encode_binary(bytes);";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:BE0F8436461794647C35BFCB578C81BDC32E0C55";
"-=-=-mxyzptlk-=-=-";
.
#82:2
$permit("owner", "wizard");
`{port} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  port")';
this.key = this:_key();
listen(this, port, 0);
this.port = port;
return;
"$permit(\"owner\", \"wizard\");";
"";
"`{port} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  port\")';";
"";
"this.key = this:_key();";
"";
"listen(this, port, 0);";
"";
"this.port = port;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:7F76AD640411783E10EA4C1E47BEFF625870BD6F";
"-=-=-mxyzptlk-=-=-";
.
#82:3
$permit("owner", "wizard");
args && raise(E_ARGS);
port = 0;
for listener in (listeners())
if (listener[1] == this)
port = listener[2];
break;
endif
endfor
(!port) && raise(E_INVARG, "Server not running");
unlisten(port);
this.key = 0;
return;
"$permit(\"owner\", \"wizard\");";
"";
"args && raise(E_ARGS);";
"";
"port = 0;";
"";
"for listener in (listeners())";
"  if (listener[1] == this)";
"    port = listener[2];";
"    break;";
"  endif";
"endfor";
"";
"!port && raise(E_INVARG, \"Server not running\");";
"";
"unlisten(port);";
"";
"this.key = 0;";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3BDA0CFA5F590ECE040EEEA832C47E8AFDE9836E";
"-=-=-mxyzptlk-=-=-";
.
#82:4
$private();
return read_http("request", @args);
return;
"$private();";
"";
"/* provides a place to redefine network behavior in a child */";
"return read_http(\"request\", @args);";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:00D751116B2CEA7C7EF4819AF89A1BA8E462315E";
"-=-=-mxyzptlk-=-=-";
.
#82:5
$private();
return notify(@args);
return;
"$private();";
"";
"/* provides a place to redefine network behavior in a child */";
"return notify(@args);";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:EA8C0826FC0A7CFF737A580317BDF00143C24910";
"-=-=-mxyzptlk-=-=-";
.
#82:6
$private();
if (verb == "_session_cookie_name")
return this.session_cookie_name;
elseif (verb == "_flash_socket_policy")
return this.flash_socket_policy;
endif
return;
"$private();";
"";
"/* centralizes wiz-perm code for access to `c' properties on children */";
"if (verb == \"_session_cookie_name\")";
"  return this.session_cookie_name;";
"elseif (verb == \"_flash_socket_policy\")";
"  return this.flash_socket_policy;";
"endif";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:41E5EEE5DB4FEB501050CBE720AC9ED755B7C38C";
"-=-=-mxyzptlk-=-=-";
.
#82:7
$private();
{connection, request} = args;
return this:_read_http(connection):merge(request);
return;
"$private();";
"";
"{connection, request} = args;";
"";
"return this:_read_http(connection):merge(request);";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:8A6177211E21B9F04B26D483C7D887D5FC3AFCEE";
"-=-=-mxyzptlk-=-=-";
.
#82:8
$private();
{connection, response} = args;
status_codes = this.status_codes;
status = `response["status"] ! E_RANGE => 0';
`status_codes[status] ! E_RANGE' || raise(E_INVARG, tostr("Status code must be one of:  ", status_codes:keys():join(", ")));
if (`body = response["body"] ! E_RANGE' != E_RANGE)
content_type = response["headers"]["content-type"];
content_length = response["headers"]["content-length"];
this:_notify(connection, tostr("HTTP/1.1 ", status, " ", status_codes[status], "~0D~0A"));
this:_notify(connection, tostr("Content-Type: ", content_type, "~0D~0A"));
this:_notify(connection, tostr("Content-Length: ", content_length, "~0D~0A"));
for value, field in (`response["headers"] ! E_RANGE => []')
if (!(field in {"Content-Type", "Content-Length"}))
this:_notify(connection, tostr(field, ": ", value, "~0D~0A"));
endif
endfor
this:_notify(connection, "~0D~0A");
this:_notify(connection, body);
else
this:_notify(connection, tostr("HTTP/1.1 ", status, " ", status_codes[status], "~0D~0A"));
this:_notify(connection, tostr("Content-Length: ", 0, "~0D~0A"));
for value, field in (`response["headers"] ! E_RANGE => []')
this:_notify(connection, tostr(field, ": ", value, "~0D~0A"));
endfor
this:_notify(connection, "~0D~0A");
endif
return;
"$private();";
"";
"{connection, response} = args;";
"";
"status_codes = this.status_codes;";
"status = `response[\"status\"] ! E_RANGE => 0';";
"`status_codes[status] ! E_RANGE' || raise(E_INVARG, tostr(\"Status code must be one of:  \", status_codes:keys():join(\", \")));";
"";
"if (`body = response[\"body\"] ! E_RANGE' != E_RANGE)";
"  content_type = response[\"headers\"][\"content-type\"];";
"  content_length = response[\"headers\"][\"content-length\"];";
"";
"  this:_notify(connection, tostr(\"HTTP/1.1 \", status, \" \", status_codes[status], \"~0D~0A\"));";
"  this:_notify(connection, tostr(\"Content-Type: \", content_type, \"~0D~0A\"));";
"  this:_notify(connection, tostr(\"Content-Length: \", content_length, \"~0D~0A\"));";
"  for value, field in (`response[\"headers\"] ! E_RANGE => []')";
"    if (!(field in {\"Content-Type\", \"Content-Length\"}))";
"      this:_notify(connection, tostr(field, \": \", value, \"~0D~0A\"));";
"    endif";
"  endfor";
"  this:_notify(connection, \"~0D~0A\");";
"  this:_notify(connection, body);";
"";
"else";
"  this:_notify(connection, tostr(\"HTTP/1.1 \", status, \" \", status_codes[status], \"~0D~0A\"));";
"  this:_notify(connection, tostr(\"Content-Length: \", 0, \"~0D~0A\"));";
"  for value, field in (`response[\"headers\"] ! E_RANGE => []')";
"    this:_notify(connection, tostr(field, \": \", value, \"~0D~0A\"));";
"  endfor";
"  this:_notify(connection, \"~0D~0A\");";
"";
"endif";
"";
"chunk_length:32";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:DB748D8D8C5AC6023EEF06939CDE38ABF5472F90";
"-=-=-mxyzptlk-=-=-";
.
#82:9
$private();
{connection, chain} = args;
request = this.request_proto:create();
response = this.response_proto:create();
request = this:_read_from_connection(connection, request);
if (`request["error"] ! E_RANGE')
this:_log("DIALOG: ", player, " bad request: ", request["error"][1], ": ", request["error"][2]);
return 0;
endif
{request, response} = this:_do_chain(request, response, chain);
this:_write_to_connection(connection, response);
return 1;
return;
"$private();";
"";
"{connection, chain} = args;";
"";
"request = this.request_proto:create();";
"response = this.response_proto:create();";
"";
"request = this:_read_from_connection(connection, request);";
"";
"if (`request[\"error\"] ! E_RANGE')";
"  this:_log(\"DIALOG: \", player, \" bad request: \", request[\"error\"][1], \": \", request[\"error\"][2]);";
"  return 0;";
"endif";
"";
"{request, response} = this:_do_chain(request, response, chain);";
"";
"this:_write_to_connection(connection, response);";
"";
"return 1;";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A76D5E6296204E8E6B26B12797BD0DE957107140";
"-=-=-mxyzptlk-=-=-";
.
#82:10
$restrict_to_server();
set_connection_option(player, "hold-input", 1);
set_connection_option(player, "disable-oob", 1);
set_connection_option(player, "binary", 1);
if (flash_socket_policy = this:_flash_socket_policy())
if ((line = read(player)) == "<policy-file-request/>~00")
this:_log("DIALOG: serving policy file: ", flash_socket_policy);
notify(player, flash_socket_policy);
boot_player(player);
return;
else
force_input(player, line, 1);
endif
endif
while (1)
if (!this:_do_request(player, this.default_chain))
boot_player(player);
break;
endif
endwhile
return;
"$restrict_to_server();";
"";
"set_connection_option(player, \"hold-input\", 1);";
"set_connection_option(player, \"disable-oob\", 1);";
"set_connection_option(player, \"binary\", 1);";
"";
"/* If a flash socket policy is set, peek at the first line.  If it's a";
" * policy file request, serve the policy and finish; otherwise, put";
" * the line back and continue.";
" *";
" * A reasonable socket policy for localhost is:";
" * \"<?xml version=\\\"1.0\\\"?><cross-domain-policy><allow-access-from domain=\\\"localhost\\\" to-ports=\\\"*\\\"/></cross-domain-policy>\"";
" *";
" */";
"if (flash_socket_policy = this:_flash_socket_policy())";
"  if ((line = read(player)) == \"<policy-file-request/>~00\")";
"    this:_log(\"DIALOG: serving policy file: \", flash_socket_policy);";
"    notify(player, flash_socket_policy);";
"    boot_player(player);";
"    return;";
"  else";
"    force_input(player, line, 1);";
"  endif";
"endif";
"";
"/* Loop forever (or until the client closes the connection or until";
" * failure or until something else happens).";
" */";
"while (1)";
"  if (!this:_do_request(player, this.default_chain))";
"    boot_player(player);";
"    break;";
"  endif";
"endwhile";
"";
"chunk_length:34";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:60C47FCCDA2F5078D4BC25D74E6BFC3A69F8BB8C";
"-=-=-mxyzptlk-=-=-";
.
#82:11
$private();
{request, response, chain} = args;
try
cookies = request:cookies();
try
if (`cookie = cookies[this:_session_cookie_name()] ! E_RANGE')
i = cookie:index("-");
hmac = decode_base64(cookie[1..i - 1]);
session = decode_base64(cookie[i + 1..$]);
if ((hmac && session) && (string_hmac(session, this.key) == hmac))
session = parse_json(session, "embedded-types");
if ((session["stamp"] + 604800) > time())
session["data"];
else
this:_log("DIALOG: session cookie has expired");
session = [];
endif
else
this:_log("DIALOG: session cookie hmac does not match");
session = [];
endif
else
session = [];
endif
except (ANY)
this:_log("DIALOG: session cookie is invalid");
session = [];
endtry
if (session)
session = session["data"];
endif
if (!`session["authenticity_token"] ! E_RANGE')
token = string_hash(tostr(random(), time()));
for i in [1..10 + random(100)]
token = string_hash(tostr(random(), token));
endfor
session["authenticity_token"] = token;
endif
if (`session["player"] ! E_RANGE' != E_RANGE)
player = `session["player"] ! E_RANGE => $nothing';
player = (((typeof(player) == OBJ) && valid(player)) && is_player(player)) ? player | $nothing;
session["player"] = player;
endif
local = task_local();
local["http"] = ["session" -> session];
set_task_local(local);
return {request, response, chain};
except ex (ANY)
request = request:set_exception(ex);
return {request, response, {"cleanup", "500"}};
endtry
return;
"$private();";
"";
"{request, response, chain} = args;";
"";
"/* Validate the session and transfer it to a tamper-proof container.";
" * Create a new session if necessary.";
" */";
"";
"try";
"  cookies = request:cookies();";
"";
"  try";
"    if (`cookie = cookies[this:_session_cookie_name()] ! E_RANGE')";
"      i = cookie:index(\"-\");";
"      hmac = decode_base64(cookie[1..i - 1]);";
"      session = decode_base64(cookie[i + 1..$]);";
"      if (hmac && session && string_hmac(session, this.key) == hmac)";
"        session = parse_json(session, \"embedded-types\");";
"        if (session[\"stamp\"] + 604800 > time())";
"          /* probe the value */";
"          session[\"data\"];";
"        else";
"          this:_log(\"DIALOG: session cookie has expired\");";
"          session = [];";
"        endif";
"      else";
"        this:_log(\"DIALOG: session cookie hmac does not match\");";
"        session = [];";
"      endif";
"    else";
"      /* no session cookie */";
"      session = [];";
"    endif";
"  except (ANY)";
"    this:_log(\"DIALOG: session cookie is invalid\");";
"    session = [];";
"  endtry";
"";
"  if (session)";
"    session = session[\"data\"];";
"  endif";
"";
"  /* add an authenticity_token if missing */";
"  if (!`session[\"authenticity_token\"] ! E_RANGE')";
"    token = string_hash(tostr(random(), time()));";
"    for i in [1..10 + random(100)]";
"      token = string_hash(tostr(random(), token));";
"    endfor";
"    session[\"authenticity_token\"] = token;";
"  endif";
"";
"  /* validate the player if present */";
"  if (`session[\"player\"] ! E_RANGE' != E_RANGE)";
"    player = `session[\"player\"] ! E_RANGE => $nothing';";
"    player = typeof(player) == OBJ && valid(player) && is_player(player) ? player | $nothing;";
"    session[\"player\"] = player;";
"  endif";
"";
"  local = task_local();";
"  local[\"http\"] = [\"session\" -> session];";
"  set_task_local(local);";
"";
"  return {request, response, chain};";
"";
"except ex (ANY)";
"  request = request:set_exception(ex);";
"  return {request, response, {\"cleanup\", \"500\"}};";
"endtry";
"";
"chunk_length:68";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:15AB144A52452936167909CBE136B94E014A3C0B";
"-=-=-mxyzptlk-=-=-";
.
#82:12
{request, response, chain} = args;
$private();
for item in (this.contents)
if (isa(item, this.route_proto))
if (route = item:match(request))
{object, verb, parameters} = route;
request = request:set_parameters(`request:parameters() ! E_RANGE => []':merge(parameters));
request = request:set_handler({object, verb});
break;
endif
endif
endfor
return {request, response, chain};
return;
"{request, response, chain} = args;";
"";
"$private();";
"";
"for item in (this.contents)";
"  if (isa(item, this.route_proto))";
"    if (route = item:match(request))";
"      {object, verb, parameters} = route;";
"      request = request:set_parameters(`request:parameters() ! E_RANGE => []':merge(parameters));";
"      request = request:set_handler({object, verb});";
"      break;";
"    endif";
"  endif";
"endfor";
"";
"return {request, response, chain};";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4D54E4ABBFEE9D7B0330F92ED66848FF6D4407F8";
"-=-=-mxyzptlk-=-=-";
.
#82:13
{request, response, chain} = args;
$private();
try
parameters = [];
plen = 0;
parameters = parameters:merge(this.utilities:parse_query_string(this.utilities:unescape(request:query()), plen));
plen = length(parameters);
if (`{type, ?mtparams = []} = request:type("full") ! E_RANGE')
if (type == "application/x-www-form-urlencoded")
parameters = parameters:merge(this.utilities:parse_query_string(this.utilities:unescape(`request:body() ! E_RANGE => ""'), plen));
plen = length(parameters);
elseif (type == "multipart/form-data")
if (mtparams && `boundary = mtparams["boundary"] ! E_RANGE')
body = request:body():trimr(tostr("--", boundary, "--~0D~0A"));
for part in (body:split(tostr("--", boundary, "~0D~0A")))
content_disposition = {};
content_type = {"text/plain"};
while (c = part:index("~0D~0A"))
if (c > 1)
header = part[1..c - 1]:split(":");
field = header[1]:trim();
value = header[2]:trim():split(";");
for i in [1..length(value)]
if (i > 1)
j = value[i]:index("=");
value[i] = {value[i][1..j - 1]:trim(), value[i][j + 1..$]:trim()};
else
value[i] = value[i]:trim();
endif
endfor
if (field == "Content-Disposition")
content_disposition = value;
elseif (field == "Content-Type")
content_type = value;
endif
part = part[c + 6..$];
else
part = part[c + 6..$];
break;
endif
endwhile
value = part[1..$ - 6];
if (((len = length(content_disposition)) > 0) && (content_disposition[1] == "form-data"))
for attr in (content_disposition[2..$])
if (attr[1] == "name")
name = attr[2]:trim("\"");
elseif (attr[1] == "filename")
filename = attr[2]:trim("\"");
value = ["__filename__" -> filename, "__content-type__" -> content_type, "__data__" -> value];
endif
endfor
if (`name ! E_VARNF')
if (plen >= 1000)
raise("-*-parameters-is-too-long-*-");
endif
plen = plen + 1;
parameters[name] = value;
endif
endif
endfor
endif
endif
endif
for v, k in (parameters)
parameters = parameters:delete(k);
ll = {};
while (k)
if (r = match(k, "^%[[^][]*%]"))
if (match(p = r[4][r[1] + 1..r[2] - 1], "^ *__"))
ll = 0;
break;
endif
ll = {@ll, p};
k[r[1]..r[2]] = "";
else
if (match(k, "^ *__"))
ll = 0;
break;
endif
ll = {@ll, k};
k = "";
endif
endwhile
if (ll)
if (((typeof(v) == MAP) && `v["__filename__"] ! E_RANGE') && `v["__data__"] ! E_RANGE')
file_mkdir(tostr("tmp/", task_id()));
filename = tostr("tmp/", task_id(), "/", value_hash(random(), "md5"));
f = -1;
try
f = file_open(filename, "w-bn");
file_write(f, v["__data__"]);
finally
(f > -1) && file_close(f);
endtry
v["__data__"] = filename;
endif
if ((z = parameters:value_by_path(ll)) != E_RANGE)
parameters = parameters:set_value_by_path(ll, (typeof(z) == LIST) ? {@z, v} | {z, v});
else
parameters = parameters:set_value_by_path(ll, v);
endif
endif
endfor
session = request:session();
if (`authenticity_token = session["authenticity_token"] ! E_RANGE')
parameters["__authenticity_token__"] = authenticity_token;
endif
if (`valid(player = session["player"]) ! E_RANGE')
parameters["__player__"] = ["id" -> player, "name" -> player.name];
endif
headers = request:headers();
if (`headers["X-Requested-With"] == "XMLHttpRequest" ! E_RANGE')
parameters["__xhr__"] = 1;
else
parameters["__xhr__"] = 0;
endif
if (`headers["X-Forwarded-Proto"] == "https" ! E_RANGE')
parameters["__ssl__"] = 1;
protocol = "https";
else
parameters["__ssl__"] = 0;
protocol = "http";
endif
{?host = "", ?port = ""} = (`headers["X-Forwarded-Host"]:split(":") ! E_RANGE' || `headers["Host"]:split(":") ! E_RANGE') || {};
if (host && port)
parameters["__url_base__"] = tostr(protocol, "://", host, ":", port);
elseif (host)
parameters["__url_base__"] = tostr(protocol, "://", host);
endif
if (`clients = headers["X-Forwarded-For"] ! E_RANGE')
parameters["__remote_client__"] = clients:split(",")[$]:trim(" ");
else
parameters["__remote_client__"] = connection_name(player):split(" ")[4]:trim(",");
endif
request = request:set_parameters(parameters);
return {request, response, chain};
except ex ("-*-parameters-is-too-long-*-")
request = request:set_exception(ex);
return {request, response, {"cleanup", "413"}};
except ex (ANY)
request = request:set_exception(ex);
return {request, response, {"cleanup", "500"}};
endtry
return;
"{request, response, chain} = args;";
"";
"$private();";
"";
"try";
"  /* Parameters derived from the query string and from the body are";
"   * under the control of an external user and therefore we can't";
"   * trust them.  Therefore, add them first, and then add all other";
"   * parameters from more-trusted/trusted sources (like the";
"   * convenience parameters).";
"   */";
"  parameters = [];";
"  plen = 0;";
"";
"  /* parameters from the query string */";
"  parameters = parameters:merge(this.utilities:parse_query_string(this.utilities:unescape(request:query()), plen));";
"  plen = length(parameters);";
"";
"  /* parameters from the body */";
"  if (`{type, ?mtparams = []} = request:type(\"full\") ! E_RANGE')";
"";
"    /* urlencoded parameters from the POST body */";
"    if (type == \"application/x-www-form-urlencoded\")";
"      parameters = parameters:merge(this.utilities:parse_query_string(this.utilities:unescape(`request:body() ! E_RANGE => \"\"'), plen));";
"      plen = length(parameters);";
"";
"    /* multipart form-data parameters from the POST body */";
"    elseif (type == \"multipart/form-data\")";
"      if (mtparams && `boundary = mtparams[\"boundary\"] ! E_RANGE')";
"        /* trim the fat and process each part */";
"        body = request:body():trimr(tostr(\"--\", boundary, \"--~0D~0A\"));";
"        for part in (body:split(tostr(\"--\", boundary, \"~0D~0A\")))";
"          content_disposition = {};";
"          content_type = {\"text/plain\"};";
"          /* process headers */";
"          while (c = part:index(\"~0D~0A\"))";
"            if (c > 1)";
"              header = part[1..c - 1]:split(\":\");";
"              field = header[1]:trim();";
"              value = header[2]:trim():split(\";\");";
"              for i in [1..length(value)]";
"                if (i > 1)";
"                  j = value[i]:index(\"=\");";
"                  value[i] = {value[i][1..j - 1]:trim(), value[i][j + 1..$]:trim()};";
"                else";
"                  value[i] = value[i]:trim();";
"                endif";
"              endfor";
"              if (field == \"Content-Disposition\")";
"                content_disposition = value;";
"              elseif (field == \"Content-Type\")";
"                content_type = value;";
"              endif";
"              part = part[c + 6..$];";
"            else";
"              part = part[c + 6..$];";
"              break;";
"            endif";
"          endwhile";
"          /* the value is what remains */";
"          value = part[1..$ - 6];";
"          /* add parameter */";
"          if ((len = length(content_disposition)) > 0 && content_disposition[1] == \"form-data\")";
"            for attr in (content_disposition[2..$])";
"              if (attr[1] == \"name\")";
"                name = attr[2]:trim(\"\\\"\");";
"              elseif (attr[1] == \"filename\")";
"                filename = attr[2]:trim(\"\\\"\");";
"                value = [\"__filename__\" -> filename, \"__content-type__\" -> content_type, \"__data__\" -> value];";
"              endif";
"            endfor";
"            if (`name ! E_VARNF')";
"              if (plen >= 1000)";
"                raise(\"-*-parameters-is-too-long-*-\");";
"              endif";
"              plen = plen + 1;";
"              parameters[name] = value;";
"            endif";
"          endif";
"        endfor";
"      endif";
"    endif";
"  endif";
"";
"  /* At this point the parameters map is flat, except for form data";
"   * upload parameters.  Step through the key/value pairs, strip out";
"   * pairs where the key begins with a double-underscore, create";
"   * nested parameters, create temporary files for upload data.";
"   */";
"  for v, k in (parameters)";
"    parameters = parameters:delete(k);";
"";
"    ll = {};";
"    while (k)";
"      if (r = match(k, \"^%[[^][]*%]\"))";
"        if (match((p = r[4][r[1] + 1..r[2] - 1]), \"^ *__\"))";
"          ll = 0;";
"          break;";
"        endif";
"        ll = {@ll, p};";
"        k[r[1]..r[2]] = \"\";";
"      else";
"        if (match(k, \"^ *__\"))";
"          ll = 0;";
"          break;";
"        endif";
"        ll = {@ll, k};";
"        k = \"\";";
"      endif";
"    endwhile";
"";
"    if (ll)";
"      if (typeof(v) == MAP && `v[\"__filename__\"] ! E_RANGE' && `v[\"__data__\"] ! E_RANGE')";
"        file_mkdir(tostr(\"tmp/\", task_id()));";
"        filename = tostr(\"tmp/\", task_id(), \"/\", value_hash(random(), \"md5\"));";
"        f = -1;";
"        try";
"          f = file_open(filename, \"w-bn\");";
"          file_write(f, v[\"__data__\"]);";
"        finally";
"          (f > -1) && file_close(f);";
"        endtry";
"        v[\"__data__\"] = filename;";
"      endif";
"";
"      if ((z = parameters:value_by_path(ll)) != E_RANGE)";
"        parameters = parameters:set_value_by_path(ll, typeof(z) == LIST ? {@z, v} | {z, v});";
"      else";
"        parameters = parameters:set_value_by_path(ll, v);";
"      endif";
"    endif";
"";
"  endfor";
"";
"  /* Add system/convenience parameters after _all_ _user supplied";
"   * parameters_ are added to prevent accidental/intentional redefinition.";
"   */";
"  session = request:session();";
"  if (`(authenticity_token = session[\"authenticity_token\"]) ! E_RANGE')";
"    parameters[\"__authenticity_token__\"] = authenticity_token;";
"  endif";
"  if (`valid(player = session[\"player\"]) ! E_RANGE')";
"    parameters[\"__player__\"] = [\"id\" -> player, \"name\" -> player.name];";
"  endif";
"";
"  headers = request:headers();";
"";
"  if (`headers[\"X-Requested-With\"] == \"XMLHttpRequest\" ! E_RANGE')";
"    parameters[\"__xhr__\"] = 1;";
"  else";
"    parameters[\"__xhr__\"] = 0;";
"  endif";
"";
"  if (`headers[\"X-Forwarded-Proto\"] == \"https\" ! E_RANGE')";
"    parameters[\"__ssl__\"] = 1;";
"    protocol = \"https\";";
"  else";
"    parameters[\"__ssl__\"] = 0;";
"    protocol = \"http\";";
"  endif";
"";
"  {?host = \"\", ?port = \"\"} = `headers[\"X-Forwarded-Host\"]:split(\":\") ! E_RANGE' || `headers[\"Host\"]:split(\":\") ! E_RANGE' || {};";
"  if (host && port)";
"    parameters[\"__url_base__\"] = tostr(protocol, \"://\", host, \":\", port);";
"  elseif (host)";
"    parameters[\"__url_base__\"] = tostr(protocol, \"://\", host);";
"  endif";
"";
"  if (`clients = headers[\"X-Forwarded-For\"] ! E_RANGE')";
"    parameters[\"__remote_client__\"] = clients:split(\",\")[$]:trim(\" \");";
"  else";
"    parameters[\"__remote_client__\"] = connection_name(player):split(\" \")[4]:trim(\",\");";
"  endif";
"";
"  request = request:set_parameters(parameters);";
"";
"  return {request, response, chain};";
"";
"except ex (\"-*-parameters-is-too-long-*-\")";
"  request = request:set_exception(ex);";
"  return {request, response, {\"cleanup\", \"413\"}};";
"";
"except ex (ANY)";
"  request = request:set_exception(ex);";
"  return {request, response, {\"cleanup\", \"500\"}};";
"endtry";
"";
"chunk_length:186";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A90A4AF557C649CD48FA4C14DC18C317D67EA006";
"-=-=-mxyzptlk-=-=-";
.
#82:14
{request, response, chain} = args;
$private();
try
if (((!(request:method() in {"GET", "HEAD"})) && ((token = `task_local()["http"]["session"]["authenticity_token"] ! E_RANGE') != `request:parameters()["_authenticity_token"] ! E_RANGE')) && (token != `request:headers()["X-Authenticity-Token"] ! E_RANGE'))
return {request, response, {"cleanup", "422"}};
else
return {request, response, chain};
endif
except ex (ANY)
request = request:set_exception(ex);
return {request, response, {"cleanup", "500"}};
endtry
return;
"{request, response, chain} = args;";
"";
"$private();";
"";
"/* Per 9.1.1 Safe Methods, RFC 2616, GET and HEAD are explicitly safe";
" * methods and do not require the authenticity token.  POST, PUT and";
" * DELETE are explicitly non-safe; however, assume that all methods";
" * that are not explicitly safe are non-safe.";
" */";
"";
"try";
"  if (!(request:method() in {\"GET\", \"HEAD\"}) &&";
"      (token = `task_local()[\"http\"][\"session\"][\"authenticity_token\"] ! E_RANGE') != `request:parameters()[\"_authenticity_token\"] ! E_RANGE' &&";
"      token != `request:headers()[\"X-Authenticity-Token\"] ! E_RANGE')";
"    return {request, response, {\"cleanup\", \"422\"}};";
"  else";
"    return {request, response, chain};";
"  endif";
"";
"except ex (ANY)";
"  request = request:set_exception(ex);";
"  return {request, response, {\"cleanup\", \"500\"}};";
"endtry";
"";
"chunk_length:23";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C5DF7CF9EC949511A65E24946CD6BB66EE5E6547";
"-=-=-mxyzptlk-=-=-";
.
#82:15
{request, response, chain} = args;
$private();
if (`handler = request:handler() ! E_RANGE')
{object, verb} = handler;
player = `task_local()["http"]["session"]["player"] ! E_RANGE => $nothing';
{request, response} = this:_drop_perms_and_call_verb(object, verb, request, response);
chain = chain:setremove("404");
endif
return {request, response, chain};
return;
"{request, response, chain} = args;";
"";
"$private();";
"";
"if (`handler = request:handler() ! E_RANGE')";
"  {object, verb} = handler;";
"";
"  /* Set player and then drop perms in a wrapper verb so that the";
"   * dropped perms don't make us lose the player change.";
"   */";
"  player = `task_local()[\"http\"][\"session\"][\"player\"] ! E_RANGE => $nothing';";
"";
"  {request, response} = this:_drop_perms_and_call_verb(object, verb, request, response);";
"";
"  /* If successful, remove the 404 -- if 404 is present, it";
"   * should be the first, last and only 404.";
"   */";
"  chain = chain:setremove(\"404\");";
"endif";
"";
"return {request, response, chain};";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D90007B74D3CD48B6039FF61A8C55F4C74D19647";
"-=-=-mxyzptlk-=-=-";
.
#82:16
{request, response, chain} = args;
$private();
try
data = `request:session() ! E_RANGE => []';
headers = `response:headers() ! E_RANGE => []';
session = ["data" -> data, "stamp" -> time()];
session = generate_json(session, "embedded-types");
hmac = string_hmac(session, this.key);
session = encode_base64(session);
hmac = encode_base64(hmac);
set_cookie = `headers["Set-Cookie"] ! E_RANGE => {}';
set_cookie = {@set_cookie, tostr(this.session_cookie_name, "=", hmac, "-", session, ";path=/;HttpOnly")};
headers["Set-Cookie"] = set_cookie:join(",");
package = $lookup("package");
headers["Server"] = tostr(package.identifier, "/", package.version);
headers["Date"] = this:_rfc1123_ctime();
response = response:set_headers(headers);
try
for file in (file_list(tostr("tmp/", task_id())))
file_remove(tostr("tmp/", task_id(), "/", file));
endfor
file_rmdir(tostr("tmp/", task_id()));
except (E_FILE)
endtry
if (`body = response:body() ! E_RANGE' != E_RANGE)
if (typeof(body) == LIST)
body = body:join("~0D~0A") + "~0D~0A";
endif
headers["Content-Type"] = `headers["Content-Type"] ! E_RANGE => "text/plain"';
headers["Content-Length"] = `headers["Content-Length"] ! E_RANGE => length(decode_binary(body, 1))';
response = response:set_headers(headers):set_body(body);
endif
return {request, response, chain};
except ex (ANY)
request = request:set_exception(ex);
return {request, response, {"500"}};
endtry
return;
"{request, response, chain} = args;";
"";
"$private();";
"";
"try";
"  data = `request:session() ! E_RANGE => []';";
"  headers = `response:headers() ! E_RANGE => []';";
"";
"  /* secure session */";
"  session = [\"data\" -> data, \"stamp\" -> time()];";
"  session = generate_json(session, \"embedded-types\");";
"  hmac = string_hmac(session, this.key);";
"  session = encode_base64(session);";
"  hmac = encode_base64(hmac);";
"";
"  /* store in cookie */";
"  set_cookie = `headers[\"Set-Cookie\"] ! E_RANGE => {}';";
"  set_cookie = {@set_cookie, tostr(this.session_cookie_name, \"=\", hmac, \"-\", session, \";path=/;HttpOnly\")};";
"  headers[\"Set-Cookie\"] = set_cookie:join(\",\");";
"";
"  /* add Server header */";
"  package = $lookup(\"package\");";
"  headers[\"Server\"] = tostr(package.identifier, \"/\", package.version);";
"";
"  /* add Date header */";
"  headers[\"Date\"] = this:_rfc1123_ctime();";
"";
"  response = response:set_headers(headers);";
"";
"  /* clean temporary files */";
"  try";
"    for file in (file_list(tostr(\"tmp/\", task_id())))";
"      file_remove(tostr(\"tmp/\", task_id(), \"/\", file));";
"    endfor";
"    file_rmdir(tostr(\"tmp/\", task_id()));";
"  except (E_FILE)";
"  endtry";
"";
"  /* Deal with the body.  Processing can fail with E_QUOTA/E_INVARG";
"   * when concatenating strings and computing the length of the body.";
"   */";
"  if (`body = response:body() ! E_RANGE' != E_RANGE)";
"    /* if the body is a list, make it a string */";
"    if (typeof(body) == LIST)";
"      body = body:join(\"~0D~0A\") + \"~0D~0A\";";
"    endif";
"";
"    /* ensure we have content type and content length */";
"    headers[\"Content-Type\"] = `headers[\"Content-Type\"] ! E_RANGE => \"text/plain\"';";
"    headers[\"Content-Length\"] = `headers[\"Content-Length\"] ! E_RANGE => length(decode_binary(body, 1))';";
"";
"    response = response:set_headers(headers):set_body(body);";
"  endif";
"";
"  return {request, response, chain};";
"";
"except ex (ANY)";
"  request = request:set_exception(ex);";
"  return {request, response, {\"500\"}};";
"endtry";
"";
"chunk_length:60";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:DCAE637AE4A4F36A02AE28F1B49337D4ECD6B195";
"-=-=-mxyzptlk-=-=-";
.
#82:17
$private();
{request, response, chain} = args;
try
code = toint(verb);
description = this.status_codes[code];
except (E_RANGE)
code = 500;
description = "Internal Server Error";
endtry
body = "<html><head><title>%m</title></head><body><h1>%m</h1>%c</body></html>";
if (`ex = request:exception() ! E_RANGE')
body = body:strsub(["%m" -> description, "%c" -> this:traceback(ex)]);
response = response:set_status(code):set_type("text/html"):set_length(length(body)):set_body(body);
else
body = body:strsub(["%m" -> description, "%c" -> ""]);
response = response:set_status(code):set_type("text/html"):set_length(length(body)):set_body(body);
endif
return {request, response, chain};
return;
"$private();";
"";
"{request, response, chain} = args;";
"";
"try";
"  code = toint(verb);";
"  description = this.status_codes[code];";
"except (E_RANGE)";
"  code = 500;";
"  description = \"Internal Server Error\";";
"endtry";
"";
"body = \"<html><head><title>%m</title></head><body><h1>%m</h1>%c</body></html>\";";
"";
"if (`ex = request:exception() ! E_RANGE')";
"  body = body:strsub([\"%m\" -> description, \"%c\" -> this:traceback(ex)]);";
"  response = response:set_status(code):set_type(\"text/html\"):set_length(length(body)):set_body(body);";
"else";
"  body = body:strsub([\"%m\" -> description, \"%c\" -> \"\"]);";
"  response = response:set_status(code):set_type(\"text/html\"):set_length(length(body)):set_body(body);";
"endif";
"";
"return {request, response, chain};";
"";
"chunk_length:23";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0B52F53CCFC46208D5C43BF16F2BA2BEC5BFB623";
"-=-=-mxyzptlk-=-=-";
.
#82:18
{ex} = args;
$private();
{l, @r} = ex[4];
tb = "<ol>";
tb = tostr(tb, "<li><code>", l[4], ":", l[2], @(l[4] != l[1]) ? {" (this == ", toliteral(l[1]), ")"} | {}, ", line ", l[6], ": ", ex[2], "</code></li>");
for l in (r)
tb = tostr(tb, "<li><code>... called from ", l[4], ":", l[2], @(l[4] != l[1]) ? {" (this == ", toliteral(l[1]), ")"} | {}, ", line ", l[6], "</code></li>");
endfor
tb = tostr(tb, "<li><code>(End of traceback)</code></li>");
tb = tostr(tb, "</ol>");
return tb;
.
#82:19
{verb, @args} = args;
$permit("wizard");
set_task_perms(caller_perms());
(verb in {"_do_request", "external", "session", "player", "route", "parameters", "protect_from_forgery", "serve", "cleanup", "404", "500"}) || raise(E_INVARG);
return this:(verb)(@args);
return;
"{verb, @args} = args;";
"$permit(\"wizard\");";
"set_task_perms(caller_perms());";
"verb in {\"_do_request\", \"external\", \"session\", \"player\", \"route\", \"parameters\", \"protect_from_forgery\", \"serve\", \"cleanup\", \"404\", \"500\"} || raise(E_INVARG);";
"return this:(verb)(@args);";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:CD7E4970FACB9D0130ACEEDDE6A3CD618FBBE8E6";
"-=-=-mxyzptlk-=-=-";
.
#82:20
{object, verb, request, response} = args;
$private();
set_task_perms(player);
return object:(verb)(request, response);
return;
"{object, verb, request, response} = args;";
"$private();";
"set_task_perms(player);";
"return object:(verb)(request, response);";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:AD341614B9E0B7291611EE45B616F9B05953BDDD";
"-=-=-mxyzptlk-=-=-";
.
#82:21
$private();
{request, response, chain} = args;
set_task_perms($nothing);
try
while (chain)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
{top, @chain} = chain;
if (typeof(top) == LIST)
{object, verb} = top;
else
object = this;
verb = top;
endif
if (!((object == this) || (object in this.contents)))
raise(E_PERM, tostr("Permission denied:  couldn't chain to ", object, ":", verb));
elseif (!respond_to(object, verb))
raise(E_VERBNF, tostr("Verb not found:  couldn't chain to ", object, ":", verb));
else
{request, response, chain} = object:(verb)(request, response, chain);
endif
endwhile
except ex (ANY)
request = request:set_exception(ex);
if ("cleanup" in chain)
{request, response, chain} = this:cleanup(request, response, chain);
endif
{request, response, chain} = this:("500")(request, response, chain);
endtry
return {request, response};
return;
"$private();";
"";
"{request, response, chain} = args;";
"";
"/* Drop perms here as a precaution.  Any special (wiz) verbs called";
" * below won't see themselves as having been called with special (wiz)";
" * permissions.";
" */";
"set_task_perms($nothing);";
"";
"try";
"";
"  while (chain)";
"    ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"";
"    {top, @chain} = chain;";
"";
"    if (typeof(top) == LIST)";
"      {object, verb} = top;";
"    else";
"      object = this;";
"      verb = top;";
"    endif";
"";
"    /* For boots and suspenders, make sure the object on which the";
"     * verb is being invoked is on this or in the contents of this.";
"     * And make sure it's callable.";
"     */";
"    if (!(object == this || object in this.contents))";
"      raise(E_PERM, tostr(\"Permission denied:  couldn't chain to \", object, \":\", verb));";
"    elseif (!respond_to(object, verb))";
"      raise(E_VERBNF, tostr(\"Verb not found:  couldn't chain to \", object, \":\", verb));";
"    else";
"      {request, response, chain} = object:(verb)(request, response, chain);";
"    endif";
"  endwhile";
"";
"/* Try to be smart about failure.  No matter what's left in the chain,";
" * only do the \"cleanup\" and \"500\" steps -- if we fail while doing";
" * them, _don't_ fail again.";
" */";
"except ex (ANY)";
"  request = request:set_exception(ex);";
"";
"  if (\"cleanup\" in chain)";
"    {request, response, chain} = this:cleanup(request, response, chain);";
"  endif";
"";
"  {request, response, chain} = this:(\"500\")(request, response, chain);";
"endtry";
"";
"return {request, response};";
"";
"chunk_length:52";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E06C52C1D9541FAA362F8ABEFEE46817BCAC4768";
"-=-=-mxyzptlk-=-=-";
.
#82:22
t = args ? args[1] | time();
tz = ctime(t):split()[6];
adj = `(["PST" -> 28800, "PDT" -> 25200, "MST" -> 25200, "MDT" -> 21600, "CST" -> 21600, "CDT" -> 18000, "EST" -> 18000, "EDT" -> 14400])[tz] ! E_RANGE => 0';
t = ctime(t + adj):split();
return tostr(t[1], ", ", t[3], " ", t[2], " ", t[5], " ", t[4], " GMT");
return;
"";
"t = args ? args[1] | time();";
"";
"/* convert it once to get the time zone */";
"";
"tz = ctime(t):split()[6];";
"";
"adj = `[\"PST\" -> 28800, \"PDT\" -> 25200, \"MST\" -> 25200, \"MDT\" -> 21600, \"CST\" -> 21600, \"CDT\" -> 18000, \"EST\" -> 18000, \"EDT\" -> 14400][tz] ! E_RANGE => 0';";
"";
"/* adjust the time for GMT and convert it again */";
"";
"t = ctime(t + adj):split();";
"";
"return tostr(t[1], \", \", t[3], \" \", t[2], \" \", t[5], \" \", t[4], \" GMT\");";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:BAD3CDBA1025FAAC03311053A780F6C26ACAA0BF";
"-=-=-mxyzptlk-=-=-";
.
#83:0
return ["prototype" -> this];
.
#83:1
return caller[verb];
.
#83:2
{value} = args;
caller[verb[5..$]] = value;
return caller;
.
#83:3
cookies = [];
cookie = `caller["headers"]["cookie"] ! ANY => ""';
for cookie in (cookie:split(";"))
i = index(cookie, "=");
key = cookie[1..i - 1]:trim();
value = cookie[i + 1..$]:trim();
cookies[key] = value;
endfor
return cookies;
.
#83:4
i = caller["uri"]:index("?");
return i ? caller["uri"][1..i - 1] | caller["uri"];
.
#83:5
i = caller["uri"]:index("?");
return i ? caller["uri"][i + 1..$] | "";
.
#83:6
{?full = 0} = args;
{type, ?parameters = ""} = caller["headers"]["Content-Type"]:split(";");
if (full)
temp = [];
for parameter in (parameters:split(","))
{k, v} = parameter:split("=");
temp[k:trim()] = v:trim();
endfor
return {type:trim(), temp};
else
return type:trim();
endif
return;
"{?full = 0} = args;";
"";
"{type, ?parameters = \"\"} = caller[\"headers\"][\"Content-Type\"]:split(\";\");";
"";
"if (full)";
"  temp = [];";
"  for parameter in (parameters:split(\",\"))";
"    {k, v} = parameter:split(\"=\");";
"    temp[k:trim()] = v:trim();";
"  endfor";
"  return {type:trim(), temp};";
"else";
"  return type:trim();";
"endif";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4CE45976AE5D41C5A0BB59256B3512746132A0A3";
"-=-=-mxyzptlk-=-=-";
.
#83:7
{type, ?parameters = []} = args;
`caller["headers"] ! E_RANGE' || (caller["headers"] = []);
if (parameters)
temp = {};
for v, k in (parameters)
temp = {@temp, tostr(k, "=", v)};
endfor
caller["headers"]["Content-Type"] = tostr(type, "; ", temp:join());
else
caller["headers"]["Content-Type"] = type;
endif
return caller;
return;
"{type, ?parameters = []} = args;";
"";
"`caller[\"headers\"] ! E_RANGE' || (caller[\"headers\"] = []);";
"";
"if (parameters)";
"  temp = {};";
"  for v, k in (parameters)";
"    temp = {@temp, tostr(k, \"=\", v)};";
"  endfor";
"  caller[\"headers\"][\"Content-Type\"] = tostr(type, \"; \", temp:join());";
"else";
"  caller[\"headers\"][\"Content-Type\"] = type;";
"endif";
"";
"return caller;";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:856523DF718870F5510F63F0A45CB32BB0BE7706";
"-=-=-mxyzptlk-=-=-";
.
#83:8
args && raise(E_ARGS);
return caller["headers"]["Content-Length"];
return;
"args && raise(E_ARGS);";
"";
"return caller[\"headers\"][\"Content-Length\"];";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:823041CE2AC45EA2790CCE216E4260153A56175A";
"-=-=-mxyzptlk-=-=-";
.
#83:9
{length} = args;
`caller["headers"] ! E_RANGE' || (caller["headers"] = []);
caller["headers"]["Content-Length"] = length;
return caller;
return;
"{length} = args;";
"";
"`caller[\"headers\"] ! E_RANGE' || (caller[\"headers\"] = []);";
"";
"caller[\"headers\"][\"Content-Length\"] = length;";
"";
"return caller;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6626802FA7F72A0010F30936907C8B64E83DCF37";
"-=-=-mxyzptlk-=-=-";
.
#83:10
$permit("wizard");
args && raise(E_ARGS);
local = task_local();
return `local["http"]["session"] ! E_RANGE => []';
return;
"$permit(\"wizard\");";
"";
"args && raise(E_ARGS);";
"";
"local = task_local();";
"return `local[\"http\"][\"session\"] ! E_RANGE => []';";
"";
"chunk_length:6";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:00425D608E5B64D713EF1A776E4E6FCFD4701923";
"-=-=-mxyzptlk-=-=-";
.
#83:11
$permit("wizard");
{session} = args;
local = task_local();
old_sesssion = `local["http"]["session"] ! E_RANGE => []';
http = `local["http"] ! E_RANGE => []';
http["session"] = session;
local["http"] = http;
set_task_local(local);
return old_sesssion;
return;
"$permit(\"wizard\");";
"";
"{session} = args;";
"";
"local = task_local();";
"old_sesssion = `local[\"http\"][\"session\"] ! E_RANGE => []';";
"http = `local[\"http\"] ! E_RANGE => []';";
"http[\"session\"] = session;";
"local[\"http\"] = http;";
"set_task_local(local);";
"return old_sesssion;";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:CB4E62F1C5D3754E8340C180B74EA101C5F780B1";
"-=-=-mxyzptlk-=-=-";
.
#84:0
return ["prototype" -> this];
.
#84:1
return caller[verb];
.
#84:2
{value} = args;
caller[verb[5..$]] = value;
return caller;
.
#84:3
{value} = args;
headers = `caller["headers"] ! E_RANGE => []';
fields = ["set_type" -> "Content-Type", "set_length" -> "Content-Length", "set_location" -> "Location"];
headers[fields[verb]] = value;
caller["headers"] = headers;
return caller;
.
#85:0
return {};
return;
"/* A route can match on anything in a request -- common criteria are";
" * HTTP method and URI.  A matched route returns the object/verb that";
" * will handle the request, as well as parameters that will be added";
" * to the other parameters in the request.";
" *";
" * In:";
" *  MAP request";
" * Out:";
" *  OBJ receiver";
" *  STR verb";
" *  MAP parameters";
" */";
"return {};";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4BD935C3BDE051C54B2484EC2D8E80EEFD6205EC";
"-=-=-mxyzptlk-=-=-";
.
#86:0
$permit("owner", "wizard");
`{player} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  OBJ player")';
(valid(player) || (player == $nothing)) || raise(E_INVARG, tostr("Invalid argument:  ", player), player);
(valid(player) && (player.wizard || player.programmer)) && raise(E_INVARG, tostr("Invalid argument:  ", player), player);
if (valid(player))
valid = 0;
for prototype in (this.prototypes)
if (isa(player, prototype))
valid = 1;
break;
endif
endfor
else
valid = 1;
endif
valid || raise(E_PERM);
set_task_local(task_local():merge(["http" -> ["session" -> ["player" -> player]]]));
return;
"$permit(\"owner\", \"wizard\");";
"";
"`{player} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  OBJ player\")';";
"";
"(valid(player) || player == $nothing) || raise(E_INVARG, tostr(\"Invalid argument:  \", player), player);";
"valid(player) && (player.wizard || player.programmer) && raise(E_INVARG, tostr(\"Invalid argument:  \", player), player);";
"";
"if (valid(player))";
"  valid = 0;";
"  for prototype in (this.prototypes)";
"    if (isa(player, prototype))";
"      valid = 1;";
"      break;";
"    endif";
"  endfor";
"else";
"  valid = 1;";
"endif";
"valid || raise(E_PERM);";
"";
"set_task_local(task_local():merge([\"http\" -> [\"session\" -> [\"player\" -> player]]]));";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:814FF22027A715A9CAD5EA24FE58C09A5F1BB069";
"-=-=-mxyzptlk-=-=-";
.
#86:1
$permit("owner", "wizard");
args && raise(E_ARGS);
return task_local()["http"]["session"]["player"];
return;
"$permit(\"owner\", \"wizard\");";
"";
"args && raise(E_ARGS);";
"";
"return task_local()[\"http\"][\"session\"][\"player\"];";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3299BC691A040E829C91ACFA12DB56C3B9FBD536";
"-=-=-mxyzptlk-=-=-";
.
#87:0
$restrict_to_caller(this.location);
{request} = args;
if (request:uri() == "/")
return {this, "it_works!", []};
else
return {};
endif
return;
"$restrict_to_caller(this.location);";
"";
"{request} = args;";
"";
"if (request:uri() == \"/\")";
"  return {this, \"it_works!\", []};";
"else";
"  return {};";
"endif";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A6E84615B5830C99BB92F0E9B74261FE0C9CCD95";
"-=-=-mxyzptlk-=-=-";
.
#87:1
$restrict_to_caller(this.location);
{request, response} = args;
body = {"<html>", "<head>", "<title>It Works!</title>", "</head>", "<body>", "<h1>It Works!</h1>", "<p>Welcome to Stunt!  For information about Stunt, check out <a href='http://stunt.io/'>http://stunt.io/</a>.</p>", "", "</body>", "</html>"};
response = response:set_status(200):set_type("text/html"):set_body(body);
return {request, response};
return;
"$restrict_to_caller(this.location);";
"";
"{request, response} = args;";
"";
"body = {";
"  \"<html>\",";
"    \"<head>\",";
"      \"<title>It Works!</title>\",";
"    \"</head>\",";
"    \"<body>\",";
"      \"<h1>It Works!</h1>\",";
"      \"<p>Welcome to Stunt!  For information about Stunt, check out <a href='http://stunt.io/'>http://stunt.io/</a>.</p>\",";
"      \"\",";
"    \"</body>\",";
"  \"</html>\"";
"};";
"";
"response = response:set_status(200):set_type(\"text/html\"):set_body(body);";
"";
"return {request, response};";
"";
"chunk_length:20";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:444FAB43211D401DF8E2E521CC7F2370F0474719";
"-=-=-mxyzptlk-=-=-";
.
#90:0
$restrict_to_caller($dialog.server, "route");
{request} = args;
uri = request:uri();
uri = uri:strsub(["%20" -> " "]);
if (index(uri, "///") == 1)
return {};
endif
if (uri[$] == "/")
uri = uri + "index.html";
endif
file = "public" + uri;
if (`stat = file_stat(file) ! E_FILE, E_INVARG, E_PERM' && (stat[2] == "reg"))
return {this, "get", ["__sendfile__" -> file]};
endif
return {};
return;
"$restrict_to_caller($dialog.server, \"route\");";
"";
"{request} = args;";
"";
"uri = request:uri();";
"";
"/* replace common URI escapes */";
"uri = uri:strsub([\"%20\" ->\" \"]);";
"";
"/* avoid uris that start with \"///\", which is the database handler path prefix */";
"if (index(uri, \"///\") == 1)";
"  return {};";
"endif";
"";
"/* handle the common case of directory access */";
"if (uri[$] == \"/\")";
"  uri = uri + \"index.html\";";
"endif";
"";
"file = \"public\" + uri;";
"";
"if (`(stat = file_stat(file)) ! E_FILE, E_INVARG, E_PERM' && stat[2] == \"reg\")";
"  return {this, \"get\", [\"__sendfile__\" -> file]};";
"endif";
"";
"return {};";
"";
"chunk_length:26";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E3D5D93459DAE9506EC7E795ED4F70840ED8BDEC";
"-=-=-mxyzptlk-=-=-";
.
#90:1
$restrict_to_caller($dialog.server, "_drop_perms_and_call_verb", "serve");
{request, response} = args;
try
file = request:parameters()["__sendfile__"];
headers = `response:headers() ! E_RANGE => []';
headers["Last-Modified"] = last_modified = $dialog.server:_rfc1123_ctime(file_stat(file)[7]);
response = response:set_headers(headers);
if (`request:headers()["If-Modified-Since"] ! E_RANGE' == last_modified)
response = response:set_status(304);
return {request, response};
endif
data = "";
size = file_size(file);
fh = -1;
try
fh = file_open(file, "r-bn");
while ((pos = file_tell(fh)) != size)
chunk = file_read(fh, size - pos);
data = data ? data + chunk | chunk;
endwhile
finally
(fh > -1) && file_close(fh);
endtry
type = "application/octet-stream";
ext = (length(parts = file:split(".")) > 1) ? parts[$] | "";
if ("txt" == ext)
type = "text/plain";
elseif (("html" == ext) || ("htm" == ext))
type = "text/html";
elseif ("jpeg" == ext)
type = "image/jpeg";
elseif ("jpg" == ext)
type = "image/jpeg";
elseif ("png" == ext)
type = "image/png";
elseif ("gif" == ext)
type = "image/gif";
elseif ("css" == ext)
type = "text/css";
elseif ("less" == ext)
type = "text/css";
elseif ("js" == ext)
type = "text/javascript";
elseif ("json" == ext)
type = "application/json";
elseif ("xml" == ext)
type = "application/xml";
elseif ("swf" == ext)
type = "application/x-shockwave-flash";
elseif (("moo" == ext) || ("moocode" == ext))
type = "application/x-moocode";
else
try
{code, out, ERR} = exec({"identify", "-format", "%m", "files/" + file});
if (!code)
if ("JPEG" == (out = decode_binary(out)[1]))
type = "image/jpeg";
elseif ("PNG" == out)
type = "image/png";
elseif ("GIF" == out)
type = "image/gif";
endif
endif
except (E_INVARG, E_EXEC)
endtry
endif
server_log(tostr("HTTP: serving file: ", file));
response = response:set_status(200):set_body(data):set_type(type):set_length(size);
return {request, response};
except (E_FILE)
endtry
return {request, response};
return;
"$restrict_to_caller($dialog.server, \"_drop_perms_and_call_verb\", \"serve\");";
"";
"{request, response} = args;";
"";
"try";
"  /* \"__sendfile__\" is the file to send */";
"  file = request:parameters()[\"__sendfile__\"];";
"";
"  /* set Last-Modified header */";
"  headers = `response:headers() ! E_RANGE => []';";
"  headers[\"Last-Modified\"] = last_modified = $dialog.server:_rfc1123_ctime(file_stat(file)[7]);";
"  response = response:set_headers(headers);";
"";
"  /* don't serve the file if it hasn't changed */";
"  if (`request:headers()[\"If-Modified-Since\"] ! E_RANGE' == last_modified)";
"    response = response:set_status(304);";
"    return {request, response};";
"  endif";
"";
"  /* read data */";
"  data = \"\";";
"  size = file_size(file);";
"  fh = -1;";
"";
"  try";
"    fh = file_open(file, \"r-bn\");";
"    while ((pos = file_tell(fh)) != size)";
"      chunk = file_read(fh, size - pos);";
"      data = data ? data + chunk | chunk;";
"    endwhile";
"  finally";
"    (fh > -1) && file_close(fh);";
"  endtry";
"";
"  /* determine the type */";
"  type = \"application/octet-stream\";";
"";
"  ext = length(parts = file:split(\".\")) > 1 ? parts[$] | \"\";";
"";
"  if (\"txt\" == ext)";
"    type = \"text/plain\";";
"  elseif (\"html\" == ext || \"htm\" == ext)";
"    type = \"text/html\";";
"  elseif (\"jpeg\" == ext)";
"    type = \"image/jpeg\";";
"  elseif (\"jpg\" == ext)";
"    type = \"image/jpeg\";";
"  elseif (\"png\" == ext)";
"    type = \"image/png\";";
"  elseif (\"gif\" == ext)";
"    type = \"image/gif\";";
"  elseif (\"css\" == ext)";
"    type = \"text/css\";";
"  elseif (\"less\" == ext)";
"    type = \"text/css\";";
"  elseif (\"js\" == ext)";
"    type = \"text/javascript\";";
"  elseif (\"json\" == ext)";
"    type = \"application/json\";";
"  elseif (\"xml\" == ext)";
"    type = \"application/xml\";";
"  elseif (\"swf\" == ext)";
"    type = \"application/x-shockwave-flash\";";
"  elseif (\"moo\" == ext || \"moocode\" == ext)";
"    type = \"application/x-moocode\";";
"  else";
"    /* last ditch effort, try to exec `identify' */";
"    try";
"      {code, out, err} = exec({\"identify\", \"-format\", \"%m\", \"files/\" + file});";
"      if (!code)";
"        if (\"JPEG\" == (out = decode_binary(out)[1]))";
"          type = \"image/jpeg\";";
"        elseif (\"PNG\" == out)";
"          type = \"image/png\";";
"        elseif (\"GIF\" == out)";
"          type = \"image/gif\";";
"        endif";
"      endif";
"    except (E_INVARG, E_EXEC)";
"    endtry";
"  endif";
"";
"  server_log(tostr(\"HTTP: serving file: \", file));";
"";
"  response = response:set_status(200):set_body(data):set_type(type):set_length(size);";
"";
"  return {request, response};";
"";
"except (E_FILE)";
"endtry";
"";
"return {request, response};";
"";
"chunk_length:92";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6BA76902E8036E49E6376305651E8B4F712E04E8";
"-=-=-mxyzptlk-=-=-";
.
#91:0
$restrict_to_caller($dialog.server, "route");
{request} = args;
uri = request:uri();
if (uri:index("///") == 1)
if (request:method() == "get")
return {this, "get", []};
elseif (request:method() == "put")
return {this, "put", []};
elseif (request:method() == "post")
return {this, "post", []};
elseif (request:method() == "delete")
return {this, "delete", []};
endif
endif
return {};
return;
"$restrict_to_caller($dialog.server, \"route\");";
"";
"{request} = args;";
"";
"uri = request:uri();";
"";
"if (uri:index(\"///\") == 1)";
"  if (request:method() == \"get\")";
"    return {this, \"get\", []};";
"  elseif (request:method() == \"put\")";
"    return {this, \"put\", []};";
"  elseif (request:method() == \"post\")";
"    return {this, \"post\", []};";
"  elseif (request:method() == \"delete\")";
"    return {this, \"delete\", []};";
"  endif";
"endif";
"";
"return {};";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0875C635816E12E580F8E3B06EE9A208AA17D102";
"-=-=-mxyzptlk-=-=-";
.
#91:1
$private();
{uri} = args;
if ((uri:index("///") == 1) && ((r = uri:split("/")):length() < 5))
{?a = "", ?b = "", ?c = "", ?d = ""} = r;
return {a, b, c, d};
else
return 0;
endif
return;
"$private();";
"";
"{uri} = args;";
"";
"/*";
"if (r = uri:match(\"^///\" + \"%(%(%w+%)/%(%w+%)?%)?\" + \"%(/%(%w+%)/%(%w+%)?%)?\" + \"$\"))";
"  a1 = r[4][r[3][2][1]..r[3][2][2]];";
"  a2 = r[4][r[3][3][1]..r[3][3][2]];";
"  b1 = r[4][r[3][5][1]..r[3][5][2]];";
"  b2 = r[4][r[3][6][1]..r[3][6][2]];";
"  return {a1, a2, b1, b2};";
"*/";
"if (uri:index(\"///\") == 1 && (r = uri:split(\"/\")):length() < 5)";
"  {?a = \"\", ?b = \"\", ?c = \"\", ?d = \"\"} = r;";
"  return {a, b, c, d};";
"else";
"  return 0;";
"endif";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:7F7443E20EE530973234647DC499BE53D981636E";
"-=-=-mxyzptlk-=-=-";
.
#91:2
{o} = args;
if (match(o, "^#?-?[0-9]+$"))
return toobj(o);
else
return $nothing;
endif
return;
"{o} = args;";
"if (match(o, \"^#?-?[0-9]+$\"))";
"  return toobj(o);";
"else";
"  return $nothing;";
"endif";
"";
"chunk_length:6";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0FA2F2DA5428FB786F77073FE5616CAA57888902";
"-=-=-mxyzptlk-=-=-";
.
#91:3
$restrict_to_caller($dialog.server, "_drop_perms_and_call_verb", "serve");
set_task_perms(caller_perms());
{request, response} = args;
uri = request:uri();
if (r = this:_match_uri(uri))
{a1, a2, b1, b2} = r;
if ((((!a1) && (!a2)) && (!b1)) && (!b2))
response = response:set_status(200);
response = response:set_type("application/json");
response = response:set_body("{}");
elseif (((("objects" == a1) && (!a2)) && (!b1)) && (!b2))
response = response:set_status(200);
response = response:set_type("application/json");
response = response:set_body("{}");
elseif (((("objects" == a1) && a2) && (!b1)) && (!b2))
o = this:_toobj(a2);
o = $shapes:read_object(o);
status = o["Meta"]["status"];
status = (status == "invalid") ? 404 | ((status == "denied") ? 403 | 200);
response = response:set_status(status);
response = response:set_type("application/json");
response = response:set_body(generate_json(o, "embedded-types"):strsub("~", "~7E"));
else
response = response:set_status(404);
response = response:set_type("application/json");
response = response:set_body("{}");
endif
else
response = response:set_status(404);
response = response:set_type("application/json");
response = response:set_body("{}");
endif
return {request, response};
return;
"$restrict_to_caller($dialog.server, \"_drop_perms_and_call_verb\", \"serve\");";
"";
"set_task_perms(caller_perms());";
"";
"{request, response} = args;";
"";
"uri = request:uri();";
"";
"if (r = this:_match_uri(uri))";
"  {a1, a2, b1, b2} = r;";
"  if (!a1 && !a2 && !b1 && !b2)";
"    response = response:set_status(200);";
"    response = response:set_type(\"application/json\");";
"    response = response:set_body(\"{}\");";
"  elseif (\"objects\" == a1 && !a2 && !b1 && !b2)";
"    response = response:set_status(200);";
"    response = response:set_type(\"application/json\");";
"    response = response:set_body(\"{}\");";
"  elseif (\"objects\" == a1 && a2 && !b1 && !b2)";
"    o = this:_toobj(a2);";
"    o = $shapes:read_object(o);";
"    status = o[\"Meta\"][\"status\"];";
"    status = (status == \"invalid\" ? 404 | (status == \"denied\" ? 403 | 200));";
"    response = response:set_status(status);";
"    response = response:set_type(\"application/json\");";
"    response = response:set_body(generate_json(o, \"embedded-types\"):strsub(\"~\", \"~7E\"));";
"  /*";
"  elseif (\"objects\" == a1 && a2 && \"attributes\" == b1 && b2)";
"    response = response:set_status(200);";
"    response = response:set_type(\"application/json\");";
"    response = response:set_body(generate_json($shapes:read_attribute(this:_toobj(a2), b2), \"embedded-types\"));";
"  elseif (\"objects\" == a1 && a2 && \"properties\" == b1 && b2)";
"    response = response:set_status(200);";
"    response = response:set_type(\"application/json\");";
"    response = response:set_body(generate_json($shapes:read_property(this:_toobj(a2), toint(b2)), \"embedded-types\"));";
"  elseif (\"objects\" == a1 && a2 && \"verbs\" == b1 && b2)";
"    response = response:set_status(200);";
"    response = response:set_type(\"application/json\");";
"    response = response:set_body(generate_json($shapes:read_verb(this:_toobj(a2), toint(b2)), \"embedded-types\"));";
"  */";
"  else";
"    response = response:set_status(404);";
"    response = response:set_type(\"application/json\");";
"    response = response:set_body(\"{}\");";
"  endif";
"else";
"  response = response:set_status(404);";
"  response = response:set_type(\"application/json\");";
"  response = response:set_body(\"{}\");";
"endif";
"";
"return {request, response};";
"";
"chunk_length:52";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:40DF01BD0DCE5EABC26CFD68538904B0F49DD264";
"-=-=-mxyzptlk-=-=-";
.
#91:4
$restrict_to_caller($dialog.server, "_drop_perms_and_call_verb", "serve");
set_task_perms(caller_perms());
{request, response} = args;
if (((`request:type() ! E_RANGE' != "application/json") || (`body = request:body() ! E_RANGE' == E_RANGE)) || (`body = parse_json(body, "embedded-types") ! E_INVARG' == E_INVARG))
response = response:set_status(415);
return {request, response};
endif
uri = request:uri();
if (r = this:_match_uri(uri))
{type, id, x1, x2} = r;
if (((("objects" == type) && id) && (!x1)) && (!x2))
if (!valid(o = this:_toobj(id)))
response = response:set_status(404);
return {request, response};
elseif (!$shapes:controls(player, o))
response = response:set_status(403);
return {request, response};
endif
body = $shapes:write_object(o, body);
body = generate_json(body, "embedded-types");
response = response:set_status(200):set_type("application/json"):set_body(body);
return {request, response};
endif
endif
response = response:set_status(404);
return {request, response};
return;
"$restrict_to_caller($dialog.server, \"_drop_perms_and_call_verb\", \"serve\");";
"";
"set_task_perms(caller_perms());";
"";
"{request, response} = args;";
"";
"if (`request:type() ! E_RANGE' != \"application/json\" ||";
"    `(body = request:body()) ! E_RANGE' == E_RANGE ||";
"    `(body = parse_json(body, \"embedded-types\")) ! E_INVARG' == E_INVARG)";
"  response = response:set_status(415);";
"  return {request, response};";
"endif";
"";
"uri = request:uri();";
"";
"if (r = this:_match_uri(uri))";
"  {type, id, x1, x2} = r;";
"  if (\"objects\" == type && id && !x1 && !x2)";
"    if (!valid(o = this:_toobj(id)))";
"      response = response:set_status(404);";
"      return {request, response};";
"    elseif (!$shapes:controls(player, o))";
"      response = response:set_status(403);";
"      return {request, response};";
"    endif";
"    body = $shapes:write_object(o, body);";
"    body = generate_json(body, \"embedded-types\");";
"    response = response:set_status(200):set_type(\"application/json\"):set_body(body);";
"    return {request, response};";
"  endif";
"endif";
"";
"response = response:set_status(404);";
"return {request, response};";
"";
"chunk_length:34";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5FC18E0AD92A5A2A1C47D188D6EDB39CBFBFCDF0";
"-=-=-mxyzptlk-=-=-";
.
#91:5
$restrict_to_caller($dialog.server, "_drop_perms_and_call_verb", "serve");
set_task_perms(caller_perms());
{request, response} = args;
if (((`request:type() ! E_RANGE' != "application/json") || (`body = request:body() ! E_RANGE' == E_RANGE)) || (`body = parse_json(body, "embedded-types") ! E_INVARG' == E_INVARG))
response = response:set_status(415);
return {request, response};
endif
uri = request:uri();
if (r = this:_match_uri(uri))
{type, x0, x1, x2} = r;
if (((("objects" == type) && (!x0)) && (!x1)) && (!x2))
if (!valid(player))
response = response:set_status(403);
return {request, response};
endif
o = create($nothing);
body = $shapes:write_object(o, body);
body = generate_json(body, "embedded-types");
response = response:set_status(201):set_location(tostr("///objects/", toint(o))):set_type("application/json"):set_body(body);
return {request, response};
endif
endif
response = response:set_status(404);
return {request, response};
return;
"$restrict_to_caller($dialog.server, \"_drop_perms_and_call_verb\", \"serve\");";
"";
"set_task_perms(caller_perms());";
"";
"{request, response} = args;";
"";
"if (`request:type() ! E_RANGE' != \"application/json\" ||";
"    `(body = request:body()) ! E_RANGE' == E_RANGE ||";
"    `(body = parse_json(body, \"embedded-types\")) ! E_INVARG' == E_INVARG)";
"  response = response:set_status(415);";
"  return {request, response};";
"endif";
"";
"uri = request:uri();";
"";
"if (r = this:_match_uri(uri))";
"  {type, x0, x1, x2} = r;";
"  if (\"objects\" == type && !x0 && !x1 && !x2)";
"    if (!valid(player))";
"      response = response:set_status(403);";
"      return {request, response};";
"    endif";
"    o = create($nothing);";
"    body = $shapes:write_object(o, body);";
"    body = generate_json(body, \"embedded-types\");";
"    response = response:set_status(201):set_location(tostr(\"///objects/\", toint(o))):set_type(\"application/json\"):set_body(body);";
"    return {request, response};";
"  endif";
"endif";
"";
"response = response:set_status(404);";
"return {request, response};";
"";
"chunk_length:32";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:288A263C496C67358B7D74A1B9E53A74DE4FACD0";
"-=-=-mxyzptlk-=-=-";
.
#91:6
$restrict_to_caller($dialog.server, "_drop_perms_and_call_verb", "serve");
set_task_perms(caller_perms());
{request, response} = args;
uri = request:uri();
if (r = this:_match_uri(uri))
{type, id, x1, x2} = r;
if (((("objects" == type) && id) && (!x1)) && (!x2))
if (!valid(o = this:_toobj(id)))
response = response:set_status(404);
return {request, response};
elseif (!$shapes:controls(player, o))
response = response:set_status(403);
return {request, response};
endif
`recycle(o) ! ANY';
if (valid(o))
response = response:set_status(500);
return {request, response};
endif
response = response:set_status(204);
return {request, response};
endif
endif
response = response:set_status(404);
return {request, response};
return;
"$restrict_to_caller($dialog.server, \"_drop_perms_and_call_verb\", \"serve\");";
"";
"set_task_perms(caller_perms());";
"";
"{request, response} = args;";
"";
"uri = request:uri();";
"";
"if (r = this:_match_uri(uri))";
"  {type, id, x1, x2} = r;";
"  if (\"objects\" == type && id && !x1 && !x2)";
"    if (!valid(o = this:_toobj(id)))";
"      response = response:set_status(404);";
"      return {request, response};";
"    elseif (!$shapes:controls(player, o))";
"      response = response:set_status(403);";
"      return {request, response};";
"    endif";
"    `recycle(o) ! ANY';";
"    if (valid(o)) /* if it's stil around... */";
"      response = response:set_status(500);";
"      return {request, response};";
"    endif";
"    response = response:set_status(204);";
"    return {request, response};";
"  endif";
"endif";
"";
"response = response:set_status(404);";
"return {request, response};";
"";
"chunk_length:30";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D63893C8EA33B24FE5D829B1FE0A95154BC6377C";
"-=-=-mxyzptlk-=-=-";
.
#92:0
$restrict_to_caller($dialog.server, "_do_chain");
{request, response, chain} = args;
if (`request["upgrade"] ! E_RANGE')
if ((`request["headers"]["upgrade"] ! E_RANGE' == "moo") && (`request["headers"]["X-Break-A-Leg"] ! E_RANGE' == "stunt"))
if (((typeof(new_player = `task_local()["http"]["session"]["player"] ! E_RANGE') == OBJ) && valid(new_player)) && is_player(new_player))
set_connection_option(player, "hold-input", 0);
set_connection_option(player, "disable-oob", 0);
set_connection_option(player, "binary", 0);
switch_player(player, new_player);
kill_task(task_id());
endif
boot_player(player);
return {request, response, {}};
endif
endif
return {request, response, chain};
return;
"$restrict_to_caller($dialog.server, \"_do_chain\");";
"";
"{request, response, chain} = args;";
"";
"if (`request[\"upgrade\"] ! E_RANGE')";
"  if (`request[\"headers\"][\"upgrade\"] ! E_RANGE' == \"moo\" && `request[\"headers\"][\"X-Break-A-Leg\"] ! E_RANGE' == \"stunt\")";
"    if (typeof(new_player = `task_local()[\"http\"][\"session\"][\"player\"] ! E_RANGE') == OBJ && valid(new_player) && is_player(new_player))";
"      /* put the connection into interactive mode */";
"      set_connection_option(player, \"hold-input\", 0);";
"      set_connection_option(player, \"disable-oob\", 0);";
"      set_connection_option(player, \"binary\", 0);";
"      switch_player(player, new_player);";
"      /* This is clumsy, but... when we successfully upgrade the";
"       * connection, end the task/request without booting the player";
"       * and let MOO's own command handling take over.";
"       */";
"      kill_task(task_id());";
"    endif";
"";
"    /* It's a valid upgrade, but the session is out-of-date or bogus.";
"     * For safety's sake, close the connection.";
"     */";
"    boot_player(player);";
"    return {request, response, {}};";
"  endif";
"endif";
"";
"/* continue if not upgrading */";
"return {request, response, chain};";
"";
"chunk_length:29";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3FF3EBF549505BB4B459FF4AEF4E5C9D70EDC245";
"-=-=-mxyzptlk-=-=-";
.
#92:1
$restrict_to_caller($dialog.server, "_do_chain");
{request, response, chain} = args;
if (request:path() == "/__long_poll")
if (`request["headers"]["X-Break-A-Leg"] ! E_RANGE' == "stunt")
if (((typeof(new_player = `task_local()["http"]["session"]["player"] ! E_RANGE') == OBJ) && valid(new_player)) && is_player(new_player))
notify(player, tostr("HTTP/1.1 ", 200, " ", "Ok", "~0D~0A"));
notify(player, tostr("Content-Type: ", "text/plain", "~0D~0A"));
notify(player, "~0D~0A");
for i in [1..16]
notify(player, "                                                                                                                                ");
endfor
set_connection_option(player, "hold-input", 0);
set_connection_option(player, "disable-oob", 0);
set_connection_option(player, "binary", 0);
switch_player(player, new_player);
if (cmd = `request:body() ! E_RANGE')
force_input(new_player, cmd);
endif
kill_task(task_id());
endif
boot_player(player);
return {request, response, {}};
endif
endif
return {request, response, chain};
return;
"$restrict_to_caller($dialog.server, \"_do_chain\");";
"";
"{request, response, chain} = args;";
"";
"if (request:path() == \"/__long_poll\")";
"  if (`request[\"headers\"][\"X-Break-A-Leg\"] ! E_RANGE' == \"stunt\")";
"    if (typeof(new_player = `task_local()[\"http\"][\"session\"][\"player\"] ! E_RANGE') == OBJ && valid(new_player) && is_player(new_player))";
"      /* write a minimal header */";
"      notify(player, tostr(\"HTTP/1.1 \", 200, \" \", \"Ok\", \"~0D~0A\"));";
"      notify(player, tostr(\"Content-Type: \", \"text/plain\", \"~0D~0A\"));";
"      notify(player, \"~0D~0A\");";
"      /* write 2048 bytes to get chrome off its ass */";
"      for i in [1..16]";
"        notify(player, \"                                                                                                                                \");";
"      endfor";
"      /* put the connection into interactive mode */";
"      set_connection_option(player, \"hold-input\", 0);";
"      set_connection_option(player, \"disable-oob\", 0);";
"      set_connection_option(player, \"binary\", 0);";
"      switch_player(player, new_player);";
"      /* finally, force the body as a command */";
"      if (cmd = `request:body() ! E_RANGE')";
"        force_input(new_player, cmd);";
"      endif";
"      /* This is clumsy, but... when we successfully set up the";
"       * connection, end the task/request without booting the player";
"       * and let MOO's own command handling take over.";
"       */";
"      kill_task(task_id());";
"    endif";
"";
"    /* It's a valid poll, but the session is out-of-date or bogus.";
"     * For safety's sake, close the connection.";
"     */";
"    boot_player(player);";
"    return {request, response, {}};";
"  endif";
"";
"endif";
"";
"return {request, response, chain};";
"";
"chunk_length:41";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6C6BA21E08D39BBB94251072DE31A052F31BA2E1";
"-=-=-mxyzptlk-=-=-";
.
#93:0
$restrict_to_caller($dialog.server, "_do_chain");
{request, response, chain} = args;
client = `request:parameters()["__remote_client__"] ! E_RANGE => "NA"';
player = `task_local()["http"]["session"]["player"] ! E_RANGE => $nothing';
name = `player.name ! E_TYPE, E_INVIND => ""';
server_log(tostr("HTTP: ", client, " ", toliteral(name), " (", player, ") ", request:method(), " ", request:uri(), " ", response:status()));
return {request, response, chain};
return;
"$restrict_to_caller($dialog.server, \"_do_chain\");";
"";
"{request, response, chain} = args;";
"";
"client = `request:parameters()[\"__remote_client__\"] ! E_RANGE => \"NA\"';";
"player = `task_local()[\"http\"][\"session\"][\"player\"] ! E_RANGE => $nothing';";
"name = `player.name ! E_TYPE, E_INVIND => \"\"';";
"";
"server_log(tostr(\"HTTP: \", client, \" \", toliteral(name), \" (\", player, \") \", request:method(), \" \", request:uri(), \" \", response:status()));";
"";
"return {request, response, chain};";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:12566891C42881F41128653FCB1BEEA38161867A";
"-=-=-mxyzptlk-=-=-";
.
#94:0
$restrict_to_caller($composed);
$external_compilers["application/x-mustache"] = $mustache.compiler;
return;
"$restrict_to_caller($composed);";
"";
"$external_compilers[\"application/x-mustache\"] = $mustache.compiler;";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:20B0254B84F3C85A0B3F9FBD3FA91AB168AEDFAE";
"-=-=-mxyzptlk-=-=-";
.
#94:1
$restrict_to_caller($composed);
$external_compilers = $external_compilers:delete("application/x-mustache");
return;
"$restrict_to_caller($composed);";
"";
"$external_compilers = $external_compilers:delete(\"application/x-mustache\");";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:28F56276ABB1EBEE63718214A624DBB6D74EE42C";
"-=-=-mxyzptlk-=-=-";
.
#97:0
$private();
server_log(tostr(@args));
return;
"$private();";
"server_log(tostr(@args));";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5C711D4BD9B9002572DB2CFAFFD7E9106FB3C119";
"-=-=-mxyzptlk-=-=-";
.
#97:1
{source, ?options = []} = args;
(typeof(source) == LIST) || raise(E_TYPE, "Source must be a list");
code = {"stack = args;", "output = {};"};
start_delim = "{{";
end_delim = "}}";
had_partial = 0;
in_comment = 0;
tag_count = 0;
tag_stack = {};
linec = 0;
for line in (source)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
linec = linec + 1;
if (in_comment)
e = end_delim;
if (!(i = line:index(e)))
line = "";
else
line = line[i + length(e)..$];
tag_count = tag_count + 1;
in_comment = 0;
endif
else
tag_count = 0;
if (line == "")
code = {@code, "output = {@output, \"\", 0};"};
endif
endif
while (line)
escaped = 1;
start_new_context = 0;
start_new_inverted_context = 0;
end_context = 0;
include_partial = 0;
set_delimiters = 0;
comment = 0;
s = start_delim;
if (!(i = line:index(s)))
code = {@code, tostr("output = {@output, ", toliteral(line), ", ", tag_count, "};")};
tag_count = 0;
line = "";
continue;
endif
if ((c = line[i + length(s)]) == "{")
escaped = 0;
s = start_delim + "{";
e = "}" + end_delim;
elseif (c == "&")
escaped = 0;
s = start_delim + "&";
e = end_delim;
elseif (c == "#")
start_new_context = 1;
s = start_delim + "#";
e = end_delim;
elseif (c == "^")
start_new_inverted_context = 1;
s = start_delim + "^";
e = end_delim;
elseif (c == "/")
end_context = 1;
s = start_delim + "/";
e = end_delim;
elseif (c == ">")
include_partial = 1;
s = start_delim + ">";
e = end_delim;
elseif (c == "=")
set_delimiters = 1;
s = start_delim + "=";
e = "=" + end_delim;
elseif (c == "!")
comment = 1;
s = start_delim + "!";
e = end_delim;
else
s = start_delim;
e = end_delim;
endif
content = line[1..i - 1];
rest = line[i + length(s)..$];
if ((!(j = rest:index(e))) && comment)
code = {@code, tostr("output = {@output, ", toliteral(content), "};")};
in_comment = 1;
line = "";
continue;
elseif (!j)
code = {@code, tostr("output = {@output, ", toliteral(line), ", ", tag_count, "};")};
tag_count = 0;
line = "";
continue;
endif
j = ((j + i) + length(s)) - 1;
tag = original_tag = line[i + length(s)..j - 1]:trim();
tag_list = original_tag_list = (tag != ".") ? tag:split(".") | {"."};
code = {@code, tostr("output = {@output, ", toliteral(content), "};")};
line = line[j + length(e)..$];
if (comment)
tag_count = tag_count + 1;
elseif (include_partial)
had_partial = 1;
code = {@code, tostr("verb = `this:(\"", original_tag, "\")(@stack) ! E_VERBNF => {}';")};
code = {@code, "output = {@output, verb};"};
tag_count = tag_count + 1;
elseif (set_delimiters)
{start_delim, end_delim} = original_tag:split();
tag_count = tag_count + 1;
elseif (start_new_context)
tag_stack = {tag, @tag_stack};
if ((l = length(original_tag_list)) > 1)
code = {@code, "failed = 0;"};
tag = original_tag_list[1];
code = {@code, tostr("if (top = `stack[1][\"", tag, "\"] ! E_RANGE')")};
code = {@code, "stack = {stack[1]:merge(typeof(top) == MAP ? top | []), @stack};"};
code = {@code, "else"};
code = {@code, "stack = {[], @stack}; failed = 1;"};
code = {@code, "endif"};
for tag in (original_tag_list[2..$ - 1])
code = {@code, tostr("if (top = `stack[1][\"", tag, "\"] ! E_RANGE')")};
code = {@code, "stack = {typeof(top) == MAP ? top | [], @stack};"};
code = {@code, "else"};
code = {@code, "stack = {[], @stack}; failed = 1;"};
code = {@code, "endif"};
endfor
tag = original_tag_list[$];
code = {@code, tostr("if (!failed && (top = `stack[1][\"", tag, "\"] ! E_RANGE'))")};
code = {@code, "for item in (typeof(top) == LIST ? top | {top})"};
code = {@code, "ticks_left() < 10000 || seconds_left() < 2 && suspend(0);"};
code = {@code, "stack = {typeof(item) == MAP ? item | [\".\" -> item], @stack};"};
else
tag = original_tag_list[1];
code = {@code, tostr("if (top = `stack[1][\"", tag, "\"] ! E_RANGE')")};
code = {@code, "for item in (typeof(top) == LIST ? top | {top})"};
code = {@code, "ticks_left() < 10000 || seconds_left() < 2 && suspend(0);"};
code = {@code, "stack = {stack[1]:merge(typeof(item) == MAP ? item | [\".\" -> item]), @stack};"};
endif
tag_count = tag_count + 1;
elseif (start_new_inverted_context)
tag_stack = {tag, @tag_stack};
if ((l = length(original_tag_list)) > 1)
code = {@code, "failed = 0;"};
tag = original_tag_list[1];
code = {@code, tostr("if (top = `stack[1][\"", tag, "\"] ! E_RANGE')")};
code = {@code, "stack = {stack[1]:merge(typeof(top) == MAP ? top | []), @stack};"};
code = {@code, "else"};
code = {@code, "stack = {[], @stack}; failed = 1;"};
code = {@code, "endif"};
for tag in (original_tag_list[2..$ - 1])
code = {@code, tostr("if (top = `stack[1][\"", tag, "\"] ! E_RANGE')")};
code = {@code, "stack = {typeof(top) == MAP ? top | [], @stack};"};
code = {@code, "else"};
code = {@code, "stack = {[], @stack}; failed = 1;"};
code = {@code, "endif"};
endfor
tag = original_tag_list[$];
code = {@code, tostr("if (failed || !(top = `stack[1][\"", tag, "\"] ! E_RANGE'))")};
code = {@code, "for item in ({\"\"})"};
code = {@code, "ticks_left() < 10000 || seconds_left() < 2 && suspend(0);"};
code = {@code, "stack = {typeof(item) == MAP ? item | [\".\" -> item], @stack};"};
else
tag = original_tag_list[1];
code = {@code, tostr("if (!(top = `stack[1][\"", tag, "\"] ! E_RANGE'))")};
code = {@code, "for item in ({\"\"})"};
code = {@code, "ticks_left() < 10000 || seconds_left() < 2 && suspend(0);"};
code = {@code, "stack = {stack[1]:merge(typeof(item) == MAP ? item | [\".\" -> item]), @stack};"};
endif
tag_count = tag_count + 1;
elseif (end_context)
if (!tag_stack)
return {0, {tostr("Line ", linec, ":  dangling end tag:  ", tag)}};
endif
{top, @tag_stack} = tag_stack;
if (top != tag)
return {0, {tostr("Line ", linec, ":  mismatched end tag:  ", tag)}};
endif
code = {@code, "stack = stack[2..$];", "endfor", "endif"};
if ((l = length(original_tag_list)) > 1)
code = {@code, tostr("stack = stack[", l, "..$];")};
endif
tag_count = tag_count + 1;
else
if ((l = length(original_tag_list)) > 1)
for tag in (original_tag_list[1..$ - 1])
code = {@code, tostr("top = `stack[1][\"", tag, "\"] ! E_RANGE';")};
code = {@code, "stack = {typeof(top) == MAP ? top | [], @stack};"};
endfor
endif
if (!original_tag_list)
return {0, {tostr("Line ", linec, ":  empty tag")}};
endif
tag = original_tag_list[$];
if (escaped)
code = {@code, tostr("output = {@output, strsub(strsub(strsub(strsub(", "`tostr(stack[1][\"", tag, "\"]) ! E_RANGE => \"\"'", ", \"&\", \"&amp;\"), \"<\", \"&lt;\"), \">\", \"&gt;\"), \"\\\"\", \"&quot;\")};")};
else
code = {@code, tostr("output = {@output, `tostr(stack[1][\"", tag, "\"]) ! E_RANGE => \"\"'};")};
endif
if (l > 1)
code = {@code, tostr("stack = stack[", l, "..$];")};
endif
tag_count = tag_count + 1;
endif
endwhile
if ((!in_comment) && tag_count)
code = {@code, tostr("output = {@output, ", tag_count, "};")};
endif
endfor
if (tag_stack)
return {0, {tostr("Line ", linec, ":  missing end tag:  ", tag_stack[1])}};
endif
code = {@code, "out = {}; acc = {}; indent = \"\";"};
code = {@code, "while (output)"};
code = {@code, "{line, @output} = output;"};
code = {@code, "ticks_left() < 10000 || seconds_left() < 2 && suspend(0);"};
code = {@code, "if (typeof(line) == LIST)"};
if (had_partial)
code = {@code, "if (lines = line)"};
code = {@code, "if (length(lines) > 1)"};
code = {@code, "temp = {lines[1], 0};"};
code = {@code, "for line in (lines[2..$ - 1])"};
code = {@code, "temp = {@temp, indent + line, 0};"};
code = {@code, "endfor"};
code = {@code, "temp = {@temp, indent + lines[$]};"};
code = {@code, "output = {@temp, @output};"};
code = {@code, "else"};
code = {@code, "output = {lines[1], @output};"};
code = {@code, "endif"};
code = {@code, "endif"};
endif
code = {@code, "elseif (typeof(line) == INT)"};
code = {@code, "if (line > 0)"};
code = {@code, "if (match(acc = tostr(@acc), \"[^ ]\"))"};
code = {@code, "out = {@out, acc};"};
code = {@code, "endif"};
code = {@code, "else"};
code = {@code, "out = {@out, tostr(@acc)};"};
code = {@code, "endif"};
code = {@code, "acc = {};"};
if (had_partial)
code = {@code, "indent = \"\";"};
endif
code = {@code, "else"};
if (had_partial)
code = {@code, "if (!match(line, \"[^ ]\"))"};
code = {@code, "indent = line;"};
code = {@code, "endif"};
endif
code = {@code, "acc = {@acc, line};"};
code = {@code, "endif"};
code = {@code, "endwhile"};
code = {@code, "return out;"};
return {1, code};
return;
"{source, ?options = []} = args;";
"";
"(typeof(source) == LIST) || raise(E_TYPE, \"Source must be a list\");";
"";
"/* NOTES */";
"/* LambdaMOO currently only has one kind of whitespace -- a single";
" * space -- therefore many of the associated tests from the";
" * specification don't quite work as-is.  In sames cases, I have";
" * replaced tab (\\t) and newline (\\n) with a single space.  In other";
" * cases, I have used lists to represent lines separated by a newline";
" * (or return/newline).  Other tests just won't pass as-is without";
" * finer control over line-endings.";
" */";
"";
"code = {\"stack = args;\", \"output = {};\"};";
"";
"/* the initial delimiters */";
"start_delim = \"{{\";";
"end_delim = \"}}\";";
"";
"/* if true, the template had a partial */";
"had_partial = 0;";
"";
"/* if true, we're processing a multiline comment */";
"in_comment = 0;";
"";
"/* the number of tags in the line */";
"tag_count = 0;";
"";
"/* for matching tags */";
"tag_stack = {};";
"";
"/* line count */";
"linec = 0;";
"";
"/* process each line */";
"for line in (source)";
"  ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"";
"  linec = linec + 1;";
"";
"  /* if we're processing a multiline comment, look for the end";
"   * delimiter -- once found, continue with the rest of the line as if";
"   * it were a continuation of the line on which the comment started";
"   */";
"  if (in_comment)";
"    e = end_delim;";
"    if (!(i = line:index(e)))";
"      line = \"\";";
"    else";
"      line = line[i + length(e)..$];";
"      tag_count = tag_count + 1;";
"      in_comment = 0;";
"    endif";
"";
"  else";
"    tag_count = 0;";
"";
"    /* preserve empty lines */";
"    if (line == \"\")";
"      code = {@code, \"output = {@output, \\\"\\\", 0};\"};";
"    endif";
"";
"  endif";
"";
"  /* chop each line into pieces of content separated by tags -- each";
"   * pass through the loop tries to find a tag and the piece of";
"   * content preceding it";
"   */";
"  while (line)";
"    escaped = 1;";
"    start_new_context = 0;";
"    start_new_inverted_context = 0;";
"    end_context = 0;";
"    include_partial = 0;";
"    set_delimiters = 0;";
"    comment = 0;";
"";
"    /* look for a starting delimiter */";
"    s = start_delim;";
"    if (!(i = line:index(s)))";
"      /* no delimiter! */";
"      code = {@code, tostr(\"output = {@output, \", toliteral(line), \", \", tag_count, \"};\")};";
"      tag_count = 0;";
"      line = \"\";";
"      continue;";
"    endif";
"";
"    if ((c = line[i + length(s)]) == \"{\")";
"      escaped = 0;";
"      s = start_delim + \"{\";";
"      e = \"}\" + end_delim;";
"    elseif (c == \"&\")";
"      escaped = 0;";
"      s = start_delim + \"&\";";
"      e = end_delim;";
"    elseif (c == \"#\")";
"      start_new_context = 1;";
"      s = start_delim + \"#\";";
"      e = end_delim;";
"    elseif (c == \"^\")";
"      start_new_inverted_context = 1;";
"      s = start_delim + \"^\";";
"      e = end_delim;";
"    elseif (c == \"/\")";
"      end_context = 1;";
"      s = start_delim + \"/\";";
"      e = end_delim;";
"    elseif (c == \">\")";
"      include_partial = 1;";
"      s = start_delim + \">\";";
"      e = end_delim;";
"    elseif (c == \"=\")";
"      set_delimiters = 1;";
"      s = start_delim + \"=\";";
"      e = \"=\" + end_delim;";
"    elseif (c == \"!\")";
"      comment = 1;";
"      s = start_delim + \"!\";";
"      e = end_delim;";
"    else";
"      s = start_delim;";
"      e = end_delim;";
"    endif";
"";
"    content = line[1..i - 1];";
"    rest = line[i + length(s)..$];";
"";
"    /* look for an ending delimiter */";
"    if (!(j = rest:index(e)) && comment)";
"      /* no delimiter! but we're inside a comment */";
"      code = {@code, tostr(\"output = {@output, \", toliteral(content), \"};\")};";
"      in_comment = 1;";
"      line = \"\";";
"      continue;";
"    elseif (!j)";
"      /* no delimiter! */";
"      code = {@code, tostr(\"output = {@output, \", toliteral(line), \", \", tag_count, \"};\")};";
"      tag_count = 0;";
"      line = \"\";";
"      continue;";
"    endif";
"";
"    /* make j relative to the beginning of the line */";
"    j = j + i + length(s) - 1;";
"";
"    /* parse the tag */";
"    tag = original_tag = line[i + length(s)..j - 1]:trim();";
"    tag_list = original_tag_list = tag != \".\" ? tag:split(\".\") | {\".\"};";
"";
"    code = {@code, tostr(\"output = {@output, \", toliteral(content), \"};\")};";
"";
"    line = line[j + length(e)..$];";
"";
"    if (comment)";
"      tag_count = tag_count + 1;";
"";
"    elseif (include_partial)";
"      had_partial = 1;";
"      code = {@code, tostr(\"verb = `this:(\\\"\", original_tag, \"\\\")(@stack) ! E_VERBNF => {}';\")};";
"      code = {@code, \"output = {@output, verb};\"};";
"      tag_count = tag_count + 1;";
"";
"    elseif (set_delimiters)";
"      {start_delim, end_delim} = original_tag:split();";
"      tag_count = tag_count + 1;";
"";
"    elseif (start_new_context)";
"      /* if all parts succeed, consider the tag truthy */";
"      /* always increase the stack depth so that the end-tag pops the correct number of frames off */";
"      tag_stack = {tag, @tag_stack};";
"      if ((l = length(original_tag_list)) > 1)";
"        code = {@code, \"failed = 0;\"};";
"        tag = original_tag_list[1];";
"        code = {@code, tostr(\"if (top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE')\")};";
"        code = {@code, \"stack = {stack[1]:merge(typeof(top) == MAP ? top | []), @stack};\"};";
"        code = {@code, \"else\"};";
"        code = {@code, \"stack = {[], @stack}; failed = 1;\"};";
"        code = {@code, \"endif\"};";
"        for tag in (original_tag_list[2..$ - 1])";
"          code = {@code, tostr(\"if (top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE')\")};";
"          code = {@code, \"stack = {typeof(top) == MAP ? top | [], @stack};\"};";
"          code = {@code, \"else\"};";
"          code = {@code, \"stack = {[], @stack}; failed = 1;\"};";
"          code = {@code, \"endif\"};";
"        endfor";
"        tag = original_tag_list[$];";
"        code = {@code, tostr(\"if (!failed && (top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE'))\")};";
"        code = {@code, \"for item in (typeof(top) == LIST ? top | {top})\"};";
"        code = {@code, \"ticks_left() < 10000 || seconds_left() < 2 && suspend(0);\"};";
"        code = {@code, \"stack = {typeof(item) == MAP ? item | [\\\".\\\" -> item], @stack};\"};";
"      else";
"        tag = original_tag_list[1];";
"        code = {@code, tostr(\"if (top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE')\")};";
"        code = {@code, \"for item in (typeof(top) == LIST ? top | {top})\"};";
"        code = {@code, \"ticks_left() < 10000 || seconds_left() < 2 && suspend(0);\"};";
"        code = {@code, \"stack = {stack[1]:merge(typeof(item) == MAP ? item | [\\\".\\\" -> item]), @stack};\"};";
"      endif";
"      tag_count = tag_count + 1;";
"";
"    elseif (start_new_inverted_context)";
"      /* if any part fails, consider the tag falsey */";
"      /* always increase the stack depth so that the end-tag pops the correct number of frames off */";
"      tag_stack = {tag, @tag_stack};";
"      if ((l = length(original_tag_list)) > 1)";
"        code = {@code, \"failed = 0;\"};";
"        tag = original_tag_list[1];";
"        code = {@code, tostr(\"if (top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE')\")};";
"        code = {@code, \"stack = {stack[1]:merge(typeof(top) == MAP ? top | []), @stack};\"};";
"        code = {@code, \"else\"};";
"        code = {@code, \"stack = {[], @stack}; failed = 1;\"};";
"        code = {@code, \"endif\"};";
"        for tag in (original_tag_list[2..$ - 1])";
"          code = {@code, tostr(\"if (top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE')\")};";
"          code = {@code, \"stack = {typeof(top) == MAP ? top | [], @stack};\"};";
"          code = {@code, \"else\"};";
"          code = {@code, \"stack = {[], @stack}; failed = 1;\"};";
"          code = {@code, \"endif\"};";
"        endfor";
"        tag = original_tag_list[$];";
"        code = {@code, tostr(\"if (failed || !(top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE'))\")};";
"        code = {@code, \"for item in ({\\\"\\\"})\"};";
"        code = {@code, \"ticks_left() < 10000 || seconds_left() < 2 && suspend(0);\"};";
"        code = {@code, \"stack = {typeof(item) == MAP ? item | [\\\".\\\" -> item], @stack};\"};";
"      else";
"        tag = original_tag_list[1];";
"        code = {@code, tostr(\"if (!(top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE'))\")};";
"        code = {@code, \"for item in ({\\\"\\\"})\"};";
"        code = {@code, \"ticks_left() < 10000 || seconds_left() < 2 && suspend(0);\"};";
"        code = {@code, \"stack = {stack[1]:merge(typeof(item) == MAP ? item | [\\\".\\\" -> item]), @stack};\"};";
"      endif";
"      tag_count = tag_count + 1;";
"";
"    elseif (end_context)";
"      if (!tag_stack)";
"        return {0, {tostr(\"Line \", linec, \":  dangling end tag:  \", tag)}};";
"      endif";
"      {top, @tag_stack} = tag_stack;";
"      if (top != tag)";
"        return {0, {tostr(\"Line \", linec, \":  mismatched end tag:  \", tag)}};";
"      endif";
"      code = {@code, \"stack = stack[2..$];\", \"endfor\", \"endif\"};";
"      if ((l = length(original_tag_list)) > 1)";
"        code = {@code, tostr(\"stack = stack[\", l, \"..$];\")};";
"      endif";
"      tag_count = tag_count + 1;";
"";
"    else";
"      if ((l = length(original_tag_list)) > 1)";
"        for tag in (original_tag_list[1..$ - 1])";
"          code = {@code, tostr(\"top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE';\")};";
"          code = {@code, \"stack = {typeof(top) == MAP ? top | [], @stack};\"};";
"        endfor";
"      endif";
"      if (!original_tag_list)";
"        return {0, {tostr(\"Line \", linec, \":  empty tag\")}};";
"      endif";
"      tag = original_tag_list[$];";
"      if (escaped)";
"        code = {@code, tostr(\"output = {@output, strsub(strsub(strsub(strsub(\", \"`tostr(stack[1][\\\"\", tag, \"\\\"]) ! E_RANGE => \\\"\\\"'\", \", \\\"&\\\", \\\"&amp;\\\"), \\\"<\\\", \\\"&lt;\\\"), \\\">\\\", \\\"&gt;\\\"), \\\"\\\\\\\"\\\", \\\"&quot;\\\")};\")};";
"      else";
"        code = {@code, tostr(\"output = {@output, `tostr(stack[1][\\\"\", tag, \"\\\"]) ! E_RANGE => \\\"\\\"'};\")};";
"      endif";
"      if (l > 1)";
"        code = {@code, tostr(\"stack = stack[\", l, \"..$];\")};";
"      endif";
"      tag_count = tag_count + 1;";
"";
"    endif";
"";
"  endwhile";
"";
"  /* add line terminator */";
"  if (!in_comment && tag_count)";
"    code = {@code, tostr(\"output = {@output, \", tag_count, \"};\")};";
"  endif";
"";
"endfor";
"";
"if (tag_stack)";
"  return {0, {tostr(\"Line \", linec, \":  missing end tag:  \", tag_stack[1])}};";
"endif";
"";
"/* Clean up and render.";
" * `0' terminates lines of original content _without_ tags, otherwise";
" * the number indicates the number of tags in the line of original";
" * content.  Lists hold partial content, and must be indented.";
" */";
"code = {@code, \"out = {}; acc = {}; indent = \\\"\\\";\"};";
"code = {@code, \"while (output)\"};";
"code = {@code, \"{line, @output} = output;\"};";
"code = {@code, \"ticks_left() < 10000 || seconds_left() < 2 && suspend(0);\"};";
"code = {@code, \"if (typeof(line) == LIST)\"};";
"if (had_partial)";
"  code = {@code, \"if (lines = line)\"};";
"  code = {@code, \"if (length(lines) > 1)\"};";
"  code = {@code, \"temp = {lines[1], 0};\"};";
"  code = {@code, \"for line in (lines[2..$ - 1])\"};";
"  code = {@code, \"temp = {@temp, indent + line, 0};\"};";
"  code = {@code, \"endfor\"};";
"  code = {@code, \"temp = {@temp, indent + lines[$]};\"};";
"  code = {@code, \"output = {@temp, @output};\"};";
"  code = {@code, \"else\"};";
"  code = {@code, \"output = {lines[1], @output};\"};";
"  code = {@code, \"endif\"};";
"  code = {@code, \"endif\"};";
"endif";
"code = {@code, \"elseif (typeof(line) == INT)\"};";
"code = {@code, \"if (line > 0)\"};";
"code = {@code, \"if (match(acc = tostr(@acc), \\\"[^ ]\\\"))\"};";
"code = {@code, \"out = {@out, acc};\"};";
"code = {@code, \"endif\"};";
"code = {@code, \"else\"};";
"code = {@code, \"out = {@out, tostr(@acc)};\"};";
"code = {@code, \"endif\"};";
"code = {@code, \"acc = {};\"};";
"if (had_partial)";
"  code = {@code, \"indent = \\\"\\\";\"};";
"endif";
"code = {@code, \"else\"};";
"if (had_partial)";
"  code = {@code, \"if (!match(line, \\\"[^ ]\\\"))\"};";
"  code = {@code, \"indent = line;\"};";
"  code = {@code, \"endif\"};";
"endif";
"code = {@code, \"acc = {@acc, line};\"};";
"code = {@code, \"endif\"};";
"code = {@code, \"endwhile\"};";
"code = {@code, \"return out;\"};";
"";
"return {1, code};";
"";
"chunk_length:331";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D953F0592C90A9BFFA80F4BA168484FAD6A98E5E";
"-=-=-mxyzptlk-=-=-";
.
#100:0
$restrict_to_caller($system, "authenticate");
if (length(args) == 2)
{name, password} = args;
for player in (children($authenticatable))
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (name == player.name)
if ($identity.utilities:verify_hashed_password(password, player.hashed_password))
return player;
endif
endif
endfor
endif
return $failed_match;
return;
"$restrict_to_caller($system, \"authenticate\");";
"";
"if (length(args) == 2)";
"  {name, password} = args;";
"  for player in (children($authenticatable))";
"    ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"    if (name == player.name)";
"      if ($identity.utilities:verify_hashed_password(password, player.hashed_password))";
"        return player;";
"      endif";
"    endif";
"  endfor";
"endif";
"";
"return $failed_match;";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:CDEDBE61D3FCD123CEA0CFD54FE546F9150ABC83";
"-=-=-mxyzptlk-=-=-";
.
#101:0
if (player != this)
notify(player, "I couldn't understand that.");
return;
endif
first_time = !this.hashed_password;
if (!first_time)
notify(player, "To change your password, first specify your old password, and then specify and confirm your new password.");
else
notify(player, "To set your password, specify and confirm your password.");
endif
try
set_connection_option(player, "binary", 1);
set_connection_option(player, "hold-input", 1);
set_connection_option(player, "client-echo", 0);
if (!first_time)
notify(player, "          Old Password: ");
while (!(((old_password = read()) && (old_password = decode_binary(old_password))) && (typeof(old_password = old_password[1]) == STR)))
endwhile
notify(player, "~0A~0D");
endif
notify(player, "          New Password: ");
while (!(((new_password = read()) && (new_password = decode_binary(new_password))) && (typeof(new_password = new_password[1]) == STR)))
endwhile
notify(player, "~0A~0D");
notify(player, "  Confirm New Password: ");
while (!(((confirm_password = read()) && (confirm_password = decode_binary(confirm_password))) && (typeof(confirm_password = confirm_password[1]) == STR)))
endwhile
notify(player, "~0A~0D");
finally
set_connection_option(player, "binary", 0);
set_connection_option(player, "hold-input", 0);
set_connection_option(player, "client-echo", 1);
endtry
utilities = $lookup("utilities");
if (this.hashed_password && (!utilities:verify_hashed_password(old_password, this.hashed_password)))
notify(player, tostr("Old password is incorrect.  Password not ", first_time ? "set" | "changed", "."));
return;
endif
if (new_password != confirm_password)
notify(player, tostr("Password and confirmation do not match.  Password not ", first_time ? "set" | "changed", "."));
return;
endif
this.hashed_password = utilities:hash_password(new_password);
notify(player, tostr("Password ", first_time ? "set" | "changed", "."));
return;
"if (player != this)";
"  notify(player, \"I couldn't understand that.\");";
"  return;";
"endif";
"";
"first_time = !this.hashed_password;";
"";
"if (!first_time)";
"  notify(player, \"To change your password, first specify your old password, and then specify and confirm your new password.\");";
"else";
"  notify(player, \"To set your password, specify and confirm your password.\");";
"endif";
"";
"try";
"  set_connection_option(player, \"binary\", 1);";
"  set_connection_option(player, \"hold-input\", 1);";
"  set_connection_option(player, \"client-echo\", 0);";
"";
"  /* when reading lines, discard telnet commands and empty lines */";
"";
"  if (!first_time)";
"    notify(player, \"          Old Password: \");";
"    while (!((old_password = read()) && (old_password = decode_binary(old_password)) && (typeof(old_password = old_password[1]) == STR)))";
"    endwhile";
"    notify(player, \"~0A~0D\");";
"  endif";
"";
"  notify(player, \"          New Password: \");";
"  while (!((new_password = read()) && (new_password = decode_binary(new_password)) && (typeof(new_password = new_password[1]) == STR)))";
"  endwhile";
"  notify(player, \"~0A~0D\");";
"";
"  notify(player, \"  Confirm New Password: \");";
"  while (!((confirm_password = read()) && (confirm_password = decode_binary(confirm_password)) && (typeof(confirm_password = confirm_password[1]) == STR)))";
"  endwhile";
"  notify(player, \"~0A~0D\");";
"";
"finally";
"  set_connection_option(player, \"binary\", 0);";
"  set_connection_option(player, \"hold-input\", 0);";
"  set_connection_option(player, \"client-echo\", 1);";
"endtry";
"";
"utilities = $lookup(\"utilities\");";
"";
"if (this.hashed_password && !utilities:verify_hashed_password(old_password, this.hashed_password))";
"  notify(player, tostr(\"Old password is incorrect.  Password not \", (first_time ? \"set\" | \"changed\"), \".\" ));";
"  return;";
"endif";
"";
"if (new_password != confirm_password)";
"  notify(player, tostr(\"Password and confirmation do not match.  Password not \", (first_time ? \"set\" | \"changed\"), \".\" ));";
"  return;";
"endif";
"";
"this.hashed_password = utilities:hash_password(new_password);";
"";
"notify(player, tostr(\"Password \", (first_time ? \"set\" | \"changed\"), \".\" ));";
"";
"chunk_length:58";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:8DBF0ACBC439BF88839CCEDB52B304930BF3BCCB";
"-=-=-mxyzptlk-=-=-";
.
#102:0
{password, hashed_password} = args;
try
algo = hashed_password["algo"];
salt = hashed_password["salt"];
hash = hashed_password["hash"];
except (E_RANGE)
raise(E_INVARG, "Invalid hashed password");
endtry
((algo && salt) && hash) || raise(E_INVARG, "Invalid hashed password");
(((typeof(algo) == STR) && (typeof(salt) == STR)) && (typeof(hash) == STR)) || raise(E_INVARG, "Invalid hashed password");
(algo in {"sha256"}) || raise(E_INVARG, "Unsupported algo");
new_hash = string_hash(salt + password, algo);
if ((length = length(new_hash)) != length(hash))
return 0;
endif
count = 0;
for i in [1..length]
count = ((new_hash[i] == hash[i]) ? 1 | 0) + count;
endfor
return length == count;
return;
"{password, hashed_password} = args;";
"try";
"  algo = hashed_password[\"algo\"];";
"  salt = hashed_password[\"salt\"];";
"  hash = hashed_password[\"hash\"];";
"except (E_RANGE)";
"  raise(E_INVARG, \"Invalid hashed password\");";
"endtry";
"algo && salt && hash || raise(E_INVARG, \"Invalid hashed password\");";
"typeof(algo) == STR && typeof(salt) == STR && typeof(hash) == STR || raise(E_INVARG, \"Invalid hashed password\");";
"algo in {\"sha256\"} || raise(E_INVARG, \"Unsupported algo\");";
"/* absolutely use a *constant time* comparison to frustrate timing attacks */";
"new_hash = string_hash(salt + password, algo);";
"if ((length = length(new_hash)) != length(hash))";
"  return 0;";
"endif";
"count = 0;";
"for i in [1..length]";
"  count = (new_hash[i] == hash[i] ? 1 | 0) + count;";
"endfor";
"return length == count;";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:41112376E5760A2247C86287362A042A8FEC11D9";
"-=-=-mxyzptlk-=-=-";
.
#102:1
{password} = args;
algo = "sha256";
salt = string_hash(tostr(random(), time()), algo);
hash = string_hash(salt + password, algo);
return ["algo" -> algo, "salt" -> salt, "hash" -> hash];
return;
"{password} = args;";
"algo = \"sha256\";";
"salt = string_hash(tostr(random(), time()), algo);";
"hash = string_hash(salt + password, algo);";
"return [\"algo\" -> algo, \"salt\" -> salt, \"hash\" -> hash];";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:15DD175E1035003708BEFB2AF757479D9FA8D806";
"-=-=-mxyzptlk-=-=-";
.
#107:0
{target} = args;
set_task_perms(caller_perms());
regexp = ("match_verb" == verb) ? "^%(me%|here%|#[0-9]+%|%$[a-z0-9_%.]+%)%:%([^ ]+%)$" | "^%(me%|here%|#[0-9]+%|%$[a-z0-9_%.]+%)%.%([^ ]+%)$";
if (m = match(target, regexp))
if (m[4][m[3][1][1]..m[3][1][2]] == "me")
o = player;
elseif (m[4][m[3][1][1]..m[3][1][2]] == "here")
o = player.location;
elseif (m[4][m[3][1][1]] == "$")
try
o = $system;
s = m[4][m[3][1][1] + 1..m[3][1][2]] + ".";
while (x = index(s, "."))
o = o.(s[1..x - 1]);
s = s[x + 1..$];
endwhile
except ex (E_RANGE, E_PROPNF)
return {$failed_match, ""};
endtry
elseif (m[4][m[3][1][1]] == "#")
o = toobj(m[4][m[3][1][1]..m[3][1][2]]);
if (!valid(o))
return {$failed_match, ""};
endif
endif
return {o, m[4][m[3][2][1]..m[3][2][2]]};
endif
return {$failed_match, ""};
.
#107:1
{target} = args;
set_task_perms(caller_perms());
if ("me" == target)
return player;
elseif ("here" == target)
return player.location;
elseif (m = match(target, "^%(#[0-9]+%|%$[a-z0-9_%.]+%)$"))
if (m[4][m[3][1][1]] == "$")
try
o = $system;
s = m[4][m[3][1][1] + 1..m[3][1][2]] + ".";
while (x = index(s, "."))
o = o.(s[1..x - 1]);
s = s[x + 1..$];
endwhile
except ex (E_RANGE, E_PROPNF)
return $failed_match;
endtry
elseif (m[4][m[3][1][1]] == "#")
o = toobj(m[4][m[3][1][1]..m[3][1][2]]);
endif
if (!valid(o))
return $failed_match;
endif
return o;
endif
return $failed_match;
.
#107:2
{o, v} = args;
set_task_perms(caller_perms());
info_function = (verb == "_player_controls_verb") ? "verb_info" | "property_info";
return player.wizard || (player == `call_function(info_function, o, v)[1] ! ANY');
.
#107:3
{o} = args;
set_task_perms(caller_perms());
return player.wizard || (player == `o.owner ! ANY');
.
#107:4
{STR} = args;
if (r = match(STR, "%( +[+-][a-z]+%)+ *$"))
cmd = STR[^..r[1] - 1];
tail = STR[r[1] + 1..$]:split();
return {cmd, @tail};
else
return {STR};
endif
return;
"{str} = args;";
"";
"if ((r = match(str, \"%( +[+-][a-z]+%)+ *$\")))";
"  cmd = str[^..r[1] - 1];";
"  tail = str[r[1] + 1..$]:split();";
"  return {cmd, @tail};";
"else";
"  return {str};";
"endif";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E9E120C913299D9B89F717C31631D48503BFF77D";
"-=-=-mxyzptlk-=-=-";
.
#108:0
callers() && raise(E_PERM, "Server task");
set_task_perms(player);
"very simple, really primitive matching";
if (((prepstr == "with") && (iobjstr == "$composed")) && `valid($composed) ! ANY')
if ((verb in {"@install", "@uninstall", "@list"}) && `respond_to($composed, verb) ! ANY')
return $composed:(verb)(@args);
endif
endif
if (((prepstr == "with") && (iobjstr == "$unit.test")) && `valid($unit.test) ! ANY')
if ((verb in {"@test"}) && `respond_to($unit.test, verb) ! ANY')
return $unit.test:(verb)(@args);
endif
endif
notify(player, "I couldn't understand that.");
.
#108:1
$permit("wizard", "owner");
notify(this, tostr(@args));
.
#108:2
boot_player(player);
.
#109:0
$private();
{prog} = args;
t = $plastic.tokenizer_proto:create(prog);
p = $plastic.parser_proto:create(t);
try
statements = p:statements();
except ex ("Syntax error")
return {0, t.row, t.column, {ex[2]}, t, p};
endtry
return {1, statements, t, p};
return;
"$private();";
"";
"{prog} = args;";
"";
"t = $plastic.tokenizer_proto:create(prog);";
"p = $plastic.parser_proto:create(t);";
"";
"try";
"  statements = p:statements();";
"except ex (\"Syntax error\")";
"  return {0, t.row, t.column, {ex[2]}, t, p};";
"endtry";
"";
"return {1, statements, t, p};";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9E113350BE941E9C9A13782D8B1C905A268BF807";
"-=-=-mxyzptlk-=-=-";
.
#109:1
if (player != this)
notify(player, "I couldn't understand that.");
return;
elseif (!player.programmer)
notify(player, "You need to be a programmer to evaluate code.");
return;
endif
try
prog = {argstr};
set_connection_option(player, "hold-input", 1);
while (((({retval, @rest} = this:_parse(prog)) && (!retval)) && ({row, column, errors, t, p} = rest)) && (row > length(prog)))
if (argstr)
player:tell("Enter lines of code.  Enter a single period (\".\") to abort editing.");
argstr = 0;
endif
if ((line = read(player)) == ".")
player:tell("(aborted)");
return;
endif
prog = {@prog, line};
endwhile
finally
set_connection_option(player, "hold-input", 0);
endtry
if (!retval)
for error in (errors)
player:tell("Line ", row, ":  ", error);
endfor
return;
endif
{statements, t, p} = rest;
if ((length(statements) == 1) && (statements[1].type != "statement"))
ret = $plastic.control_flow_statement_proto:create("return");
ret.type = "statement";
ret.first = statements[1];
statements = {ret};
endif
if (statements && (!((statements[$].type == "statement") && (statements[$].id == "return"))))
ret = $plastic.control_flow_statement_proto:create("return");
ret.type = "statement";
ret.first = 0;
statements = {@statements, ret};
endif
ret = $plastic.bracket_operator_proto:create("[");
ret.type = "unary";
ret.value = {};
for variable in (p:variables())
if ((variable.id[1] != "$") && (!(variable.id in $plastic.name_proto.builtin_names)))
key = $plastic.literal_proto:create("");
key.type = "string";
key.value = variable.id;
value = $plastic.error_catching_operator_proto:create("!!");
value.type = "binary";
value.first = variable;
value.second = {$plastic.name_proto:create("ANY")};
value.second[1].type = "keyword";
value.second[1].value = "ANY";
ret.value = {@ret.value, {key, value}};
endif
endfor
for statement in ($plastic.utilities:match(statements, "return"))
if (statement.first == 0)
statement.first = $plastic.literal_proto:create("");
statement.first.type = "number";
statement.first.value = 0;
endif
first = $plastic.brace_operator_proto:create("{");
first.type = "unary";
first.value = {statement.first, ret};
statement.first = first;
endfor
prefix = $plastic.assignment_operator_proto:create("=");
prefix.type = "binary";
prefix.first = $plastic.name_proto:create("__");
prefix.first.type = "variable";
prefix.first.value = "__";
prefix.second = $plastic.property_selector_operator_proto:create(".");
prefix.second.type = "binary";
prefix.second.first = $plastic.name_proto:create("player");
prefix.second.first.type = "variable";
prefix.second.first.value = "player";
prefix.second.second = $plastic.name_proto:create("alt_bindings");
prefix.second.second.type = "identifier";
prefix.second.second.value = "alt_bindings";
prefix = {prefix};
for v, k in (player.alt_bindings)
assignment = $plastic.assignment_operator_proto:create("=");
assignment.type = "binary";
assignment.first = $plastic.name_proto:create(k);
assignment.first.type = "variable";
assignment.first.value = k;
assignment.second = $plastic.bracket_operator_proto:create("[");
assignment.second.type = "binary";
assignment.second.first = $plastic.name_proto:create("__");
assignment.second.first.type = "variable";
assignment.second.first.value = "__";
assignment.second.second = $plastic.literal_proto:create("");
assignment.second.second.type = "string";
assignment.second.second.value = k;
prefix = {@prefix, assignment};
endfor
statements = {@prefix, @statements};
source = {};
for statement in (statements)
if (statement.type != "statement")
source = {@source, statement:p(), ";"};
else
source = {@source, @statement:p()};
endif
endfor
if (!source)
source = {""};
endif
set_task_perms(player);
{code, retval} = eval(@source);
if (code)
variables = [];
if (typeof(retval) == LIST)
{retval, ?variables = []} = retval;
endif
variables["_"] = retval;
player.alt_bindings = player.alt_bindings:merge(variables);
t = typeof(retval);
if (((t == OBJ) || (t == ANON)) && valid(retval))
player:tell(toliteral(retval), " ", toliteral(retval.name));
elseif (t == ERR)
player:tell(toliteral(retval), " ", toliteral(tostr(retval)));
else
player:tell(toliteral(retval));
endif
else
for line in (retval)
player:tell(line);
endfor
endif
return;
"if (player != this)";
"  notify(player, \"I couldn't understand that.\");";
"  return;";
"elseif (!player.programmer)";
"  notify(player, \"You need to be a programmer to evaluate code.\");";
"  return;";
"endif";
"";
"/* The strategy is to add lines until we either have a chunk of code";
" * that parses without error (in which case we compile it and evaluate";
" * the result) or is uncorrectable (in which case we output the syntax";
" * errors).  \"Uncorrectable\" means that adding more lines will not";
" * result in a valid chunk of code.";
"*/";
"";
"try";
"  prog = {argstr};";
"";
"  set_connection_option(player, \"hold-input\", 1);";
"";
"  while (({retval, @rest} = this:_parse(prog)) && !retval &&";
"         ({row, column, errors, t, p} = rest) &&";
"         row > length(prog))";
"    if (argstr)";
"      player:tell(\"Enter lines of code.  Enter a single period (\\\".\\\") to abort editing.\");";
"      argstr = 0;";
"    endif";
"    if ((line = read(player)) == \".\")";
"      player:tell(\"(aborted)\");";
"      return;";
"    endif";
"    prog = {@prog, line};";
"  endwhile";
"finally";
"  set_connection_option(player, \"hold-input\", 0);";
"endtry";
"";
"if (!retval)";
"  for error in (errors)";
"    player:tell(\"Line \", row, \":  \", error);";
"  endfor";
"  return;";
"endif";
"";
"{statements, t, p} = rest;";
"";
"/* if it's not a statement, make it a return statement */";
"if (length(statements) == 1 && statements[1].type != \"statement\")";
"  ret = $plastic.control_flow_statement_proto:create(\"return\");";
"  ret.type = \"statement\";";
"  ret.first = statements[1];";
"  statements = {ret};";
"endif";
"";
"/* if it doesn't end in a return statement, tack on a return statement */";
"if (statements && !(statements[$].type == \"statement\" && statements[$].id == \"return\"))";
"  ret = $plastic.control_flow_statement_proto:create(\"return\");";
"  ret.type = \"statement\";";
"  ret.first = 0;";
"  statements = {@statements, ret};";
"endif";
"";
"/* build code to return the variables */";
"ret = $plastic.bracket_operator_proto:create(\"[\");";
"ret.type = \"unary\";";
"ret.value = {};";
"for variable in (p:variables())";
"  if (variable.id[1] != \"$\" && !(variable.id in $plastic.name_proto.builtin_names))";
"    key = $plastic.literal_proto:create(\"\");";
"    key.type = \"string\";";
"    key.value = variable.id;";
"    value = $plastic.error_catching_operator_proto:create(\"!!\");";
"    value.type = \"binary\";";
"    value.first = variable;";
"    value.second = {$plastic.name_proto:create(\"ANY\")};";
"    value.second[1].type = \"keyword\";";
"    value.second[1].value = \"ANY\";";
"    ret.value = {@ret.value, {key, value}};";
"  endif";
"endfor";
"";
"/* look for and fix up return statements */";
"for statement in ($plastic.utilities:match(statements, \"return\"))";
"  if (statement.first == 0)";
"    statement.first = $plastic.literal_proto:create(\"\");";
"    statement.first.type = \"number\";";
"    statement.first.value = 0;";
"  endif";
"  first = $plastic.brace_operator_proto:create(\"{\");";
"  first.type = \"unary\";";
"  first.value = {statement.first, ret};";
"  statement.first = first;";
"endfor";
"";
"/* prefix with bindings */";
"prefix = $plastic.assignment_operator_proto:create(\"=\");";
"prefix.type = \"binary\";";
"prefix.first = $plastic.name_proto:create(\"__\");";
"prefix.first.type = \"variable\";";
"prefix.first.value = \"__\";";
"prefix.second = $plastic.property_selector_operator_proto:create(\".\");";
"prefix.second.type = \"binary\";";
"prefix.second.first = $plastic.name_proto:create(\"player\");";
"prefix.second.first.type = \"variable\";";
"prefix.second.first.value = \"player\";";
"prefix.second.second = $plastic.name_proto:create(\"alt_bindings\");";
"prefix.second.second.type = \"identifier\";";
"prefix.second.second.value = \"alt_bindings\";";
"prefix = {prefix};";
"";
"for v, k in (player.alt_bindings)";
"  assignment = $plastic.assignment_operator_proto:create(\"=\");";
"  assignment.type = \"binary\";";
"  assignment.first = $plastic.name_proto:create(k);";
"  assignment.first.type = \"variable\";";
"  assignment.first.value = k;";
"  assignment.second = $plastic.bracket_operator_proto:create(\"[\");";
"  assignment.second.type = \"binary\";";
"  assignment.second.first = $plastic.name_proto:create(\"__\");";
"  assignment.second.first.type = \"variable\";";
"  assignment.second.first.value = \"__\";";
"  assignment.second.second = $plastic.literal_proto:create(\"\");";
"  assignment.second.second.type = \"string\";";
"  assignment.second.second.value = k;";
"  prefix = {@prefix, assignment};";
"endfor";
"";
"statements = {@prefix, @statements};";
"";
"/* generate the code to eval */";
"source = {};";
"";
"for statement in (statements)";
"  if (statement.type != \"statement\")";
"    source = {@source, statement:p(), \";\"};";
"  else";
"    source = {@source, @statement:p()};";
"  endif";
"endfor";
"";
"if (!source)";
"  source = {\"\"};";
"endif";
"";
"/* and evaluate...! */";
"set_task_perms(player);";
"";
"{code, retval} = eval(@source);";
"";
"if (code)";
"  variables = [];";
"  if (typeof(retval) == LIST)";
"    {retval, ?variables = []} = retval;";
"  endif";
"";
"  variables[\"_\"] = retval;";
"";
"  player.alt_bindings = player.alt_bindings:merge(variables);";
"";
"  t = typeof(retval);";
"  if ((t == OBJ || t == ANON) && valid(retval))";
"    player:tell(toliteral(retval), \" \", toliteral(retval.name));";
"  elseif (t == ERR)";
"    player:tell(toliteral(retval), \" \", toliteral(tostr(retval)));";
"  else";
"    player:tell(toliteral(retval));";
"  endif";
"else";
"  for line in (retval)";
"    player:tell(line);";
"  endfor";
"endif";
"";
"chunk_length:172";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:AC07CE1ACFA64719F42021C112EF4521D5A78D68";
"-=-=-mxyzptlk-=-=-";
.
#109:2
if (player != this)
player:notify("I couldn't understand that.");
return;
elseif (!player.programmer)
player:notify("You need to be a programmer to do that.");
return;
endif
utilities = $lookup("player_utilities");
{o, v} = utilities:match_verb(argstr);
if (v && `vi = verb_info(o, v) ! E_VERBNF')
if (utilities:_player_controls_verb(o, v) || index(vi[2], "r"))
d = $verb_detail(o, v);
if (`d["content_type"] ! E_RANGE')
vc = verb_code(o, v);
else
vc = verb_code(o, v, 0, 1);
endif
if (verb == "@edit")
if (`d["content_type"] ! E_RANGE')
player:notify("Editing ", argstr);
player:notify("#$# edit name: ", argstr, " upload: @program ", argstr, " as ", d["content_type"]);
else
player:notify("Editing ", argstr);
player:notify("#$# edit name: ", argstr, " upload: @program ", argstr);
endif
endif
for i in (vc)
player:notify(i);
endfor
if (verb == "@edit")
player:notify(".");
endif
return;
else
player:notify("You don't have permission to do that.");
return;
endif
elseif (v)
player:notify("That verb doesn't exist.");
return;
endif
{o, p} = utilities:match_property(argstr);
if (p && `pi = property_info(o, p) ! E_PROPNF')
if (utilities:_player_controls_property(o, p) || index(pi[2], "r"))
v = o.(p);
if ((type = typeof(v)) == LIST)
for i in (v)
if (typeof(i) != STR)
type = -1;
break;
endif
endfor
endif
if (verb == "@edit")
if (type == LIST)
player:notify("Editing ", argstr);
player:notify("#$# edit name: ", argstr, " upload: @program ", argstr, " as list");
else
player:notify("Editing ", argstr);
player:notify("#$# edit name: ", argstr, " upload: @program ", argstr);
endif
endif
if (type != LIST)
v = {toliteral(v)};
endif
for i in (v)
player:notify(i);
endfor
if (verb == "@edit")
player:notify(".");
endif
return;
else
player:notify("You don't have permission to do that.");
return;
endif
elseif (p)
player:notify("That property doesn't exist.");
return;
endif
player:notify("I couldn't understand that.");
return;
"if (player != this)";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"elseif (!player.programmer)";
"  player:notify(\"You need to be a programmer to do that.\");";
"  return;";
"endif";
"";
"utilities = $lookup(\"player_utilities\");";
"";
"{o, v} = utilities:match_verb(argstr);";
"if (v && `vi = verb_info(o, v) ! E_VERBNF')";
"  if (utilities:_player_controls_verb(o, v) || index(vi[2], \"r\"))";
"    d = $verb_detail(o, v);";
"    if (`d[\"content_type\"] ! E_RANGE')";
"      vc = verb_code(o, v);";
"    else";
"      vc = verb_code(o, v, 0, 1);";
"    endif";
"    if (verb == \"@edit\")";
"      if (`d[\"content_type\"] ! E_RANGE')";
"        player:notify(\"Editing \", argstr);";
"        player:notify(\"#$# edit name: \", argstr, \" upload: @program \", argstr, \" as \", d[\"content_type\"]);";
"      else";
"        player:notify(\"Editing \", argstr);";
"        player:notify(\"#$# edit name: \", argstr, \" upload: @program \", argstr);";
"      endif";
"    endif";
"    for i in (vc)";
"      player:notify(i);";
"    endfor";
"    if (verb == \"@edit\")";
"      player:notify(\".\");";
"    endif";
"    return;";
"  else";
"    player:notify(\"You don't have permission to do that.\");";
"    return;";
"  endif";
"elseif (v)";
"  player:notify(\"That verb doesn't exist.\");";
"  return;";
"endif";
"";
"{o, p} = utilities:match_property(argstr);";
"if (p && `pi = property_info(o, p) ! E_PROPNF')";
"  if (utilities:_player_controls_property(o, p) || index(pi[2], \"r\"))";
"    v = o.(p);";
"    /* is it a list of strings? */";
"    if ((type = typeof(v)) == LIST)";
"      for i in (v)";
"        if (typeof(i) != STR)";
"          type = -1;";
"          break;";
"        endif";
"      endfor";
"    endif";
"    if (verb == \"@edit\")";
"      if (type == LIST)";
"        player:notify(\"Editing \", argstr);";
"        player:notify(\"#$# edit name: \", argstr, \" upload: @program \", argstr, \" as list\");";
"      else";
"        player:notify(\"Editing \", argstr);";
"        player:notify(\"#$# edit name: \", argstr, \" upload: @program \", argstr);";
"      endif";
"    endif";
"    if (type != LIST)";
"      v = {toliteral(v)};";
"    endif";
"    for i in (v)";
"      player:notify(i);";
"    endfor";
"    if (verb == \"@edit\")";
"      player:notify(\".\");";
"    endif";
"    return;";
"  else";
"    player:notify(\"You don't have permission to do that.\");";
"    return;";
"  endif";
"elseif (p)";
"  player:notify(\"That property doesn't exist.\");";
"  return;";
"endif";
"";
"player:notify(\"I couldn't understand that.\");";
"";
"chunk_length:86";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9E3190397CF8BA52EAC3D1B9F599AA8A2ED4A87F";
"-=-=-mxyzptlk-=-=-";
.
#109:3
if (player != this)
player:notify("I couldn't understand that.");
return;
elseif (!player.programmer)
player:notify("You need to be a programmer to program.");
return;
endif
utilities = $lookup("player_utilities");
ll = {};
while ((l = read(player)) != ".")
ll = {@ll, l};
endwhile
{o, v} = utilities:match_verb(dobjstr);
if (v && `vi = verb_info(o, v) ! E_VERBNF')
if (utilities:_player_controls_verb(o, v) || index(vi[2], "w"))
if ((prepstr == "as") && iobjstr)
content_type = $_generate_content_type($_parse_content_type(iobjstr));
elseif (prepstr)
player:notify("I couldn't understand that.");
return;
endif
vd = $verb_detail(o, v);
if (`vd["sha1"] ! E_RANGE' == value_hash(ll, "sha1"))
player:notify("No change.  Nothing to do for ", dobjstr);
return;
endif
set_task_perms(player);
if (`content_type ! E_VARNF')
r = set_verb_code(o, v, ll, content_type);
else
r = set_verb_code(o, v, ll);
endif
if (!r)
player:notify("Programming succeeded for ", dobjstr);
else
player:notify("Programming failed for ", dobjstr);
for rr in (r)
player:notify(rr);
endfor
endif
return;
else
player:notify("You don't have permission to do that.");
return;
endif
elseif (v)
player:notify("That verb doesn't exist.");
return;
endif
{o, p} = utilities:match_property(dobjstr);
if (p && `pi = property_info(o, p) ! E_PROPNF')
if (utilities:_player_controls_property(o, p) || index(pi[2], "w"))
if ((prepstr == "as") && (iobjstr == "list"))
content_type = LIST;
elseif (prepstr)
player:notify("I couldn't understand that.");
return;
endif
set_task_perms(player);
if (`content_type ! E_VARNF')
o.(p) = ll;
else
r = eval(((dobjstr + " = ") + ll:join()) + ";");
endif
if (`r[1] ! E_VARNF => 1')
player:notify("Programming succeeded for ", dobjstr);
else
player:notify("Programming failed for ", dobjstr);
for rr in (r[2])
player:notify(rr);
endfor
endif
return;
else
player:notify("You don't have permission to do that.");
return;
endif
elseif (p)
player:notify("That property doesn't exist.");
return;
endif
player:notify("I couldn't understand that.");
return;
"if (player != this)";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"elseif (!player.programmer)";
"  player:notify(\"You need to be a programmer to program.\");";
"  return;";
"endif";
"";
"utilities = $lookup(\"player_utilities\");";
"";
"/* snarf lines early to avoid the flood of error messages */";
"ll = {};";
"while ((l = read(player)) != \".\")";
"  ll = {@ll, l};";
"endwhile";
"";
"{o, v} = utilities:match_verb(dobjstr);";
"if (v && `vi = verb_info(o, v) ! E_VERBNF')";
"  if (utilities:_player_controls_verb(o, v) || index(vi[2], \"w\"))";
"    if (prepstr == \"as\" && iobjstr)";
"      content_type = $_generate_content_type($_parse_content_type(iobjstr));";
"    elseif (prepstr)";
"      player:notify(\"I couldn't understand that.\");";
"      return;";
"    endif";
"";
"    vd = $verb_detail(o, v);";
"    if (`vd[\"sha1\"] ! E_RANGE' == value_hash(ll, \"sha1\"))";
"      player:notify(\"No change.  Nothing to do for \", dobjstr);";
"      return;";
"    endif";
"";
"    set_task_perms(player);";
"";
"    if (`content_type ! E_VARNF')";
"      r = set_verb_code(o, v, ll, content_type);";
"    else";
"      r = set_verb_code(o, v, ll);";
"    endif";
"";
"    if (!r)";
"      player:notify(\"Programming succeeded for \", dobjstr);";
"    else";
"      player:notify(\"Programming failed for \", dobjstr);";
"      for rr in (r)";
"        player:notify(rr);";
"      endfor";
"    endif";
"";
"    return;";
"";
"  else";
"    player:notify(\"You don't have permission to do that.\");";
"    return;";
"  endif";
"elseif (v)";
"  player:notify(\"That verb doesn't exist.\");";
"  return;";
"endif";
"";
"{o, p} = utilities:match_property(dobjstr);";
"if (p && `pi = property_info(o, p) ! E_PROPNF')";
"  if (utilities:_player_controls_property(o, p) || index(pi[2], \"w\"))";
"    if (prepstr == \"as\" && iobjstr == \"list\")";
"      content_type = LIST;";
"    elseif (prepstr)";
"      player:notify(\"I couldn't understand that.\");";
"      return;";
"    endif";
"";
"    set_task_perms(player);";
"";
"    if (`content_type ! E_VARNF')";
"      o.(p) = ll;";
"    else";
"      r = eval(dobjstr + \" = \" + ll:join() + \";\");";
"    endif";
"";
"    if (`r[1] ! E_VARNF => 1')";
"      player:notify(\"Programming succeeded for \", dobjstr);";
"    else";
"      player:notify(\"Programming failed for \", dobjstr);";
"      for rr in (r[2])";
"        player:notify(rr);";
"      endfor";
"    endif";
"";
"  return;";
"";
"  else";
"    player:notify(\"You don't have permission to do that.\");";
"    return;";
"  endif";
"elseif (p)";
"  player:notify(\"That property doesn't exist.\");";
"  return;";
"endif";
"";
"player:notify(\"I couldn't understand that.\");";
"";
"chunk_length:99";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:1C4EEFFC1C20EF733CE277B783006D6199A4BD5E";
"-=-=-mxyzptlk-=-=-";
.
#109:4
if (player != this)
player:notify("I couldn't understand that.");
return;
endif
all = 0;
tail = {};
utilities = $lookup("player_utilities");
if (!valid(dobj))
{dobjstr, @tail} = utilities:extract_tail(dobjstr);
dobj = utilities:match_object(dobjstr);
all = ("+all" in tail) && (!("-all" in tail));
endif
if (!valid(dobj))
player:notify("I couldn't understand that.");
return;
endif
if (!tail)
all = !(verbs(dobj) || properties(dobj));
endif
p = n = "";
dobj.r ? p = p + "r" | (n = n + "r");
dobj.w ? p = p + "w" | (n = n + "w");
dobj.f ? p = p + "f" | (n = n + "f");
dobj.a ? p = p + "a" | (n = n + "a");
t = {};
`is_player(dobj) ! E_TYPE' && (t = {@t, "player"});
dobj.programmer && (t = {@t, "programmer"});
dobj.wizard && (t = {@t, "wizard"});
t = t:join(", ");
player:notify("\"", dobj.name, "\" (", dobj, ")", p ? " +" | "", p, n ? " -" | "", n, " ", t);
player:notify("Parents: ", toliteral(parents(dobj)), ", ", "Children: ", toliteral(children(dobj)));
player:notify("Location: ", toliteral(dobj.location), ", ", "Contents: ", toliteral(dobj.contents));
player:notify("Owner: ", dobj.owner);
if (utilities:_player_controls_object(dobj) || dobj.r)
ancestors = all ? {dobj, @ancestors(dobj)} | {dobj};
for o in (ancestors)
if (utilities:_player_controls_object(o) || o.r)
for i, j in (verbs(o))
if (utilities:_player_controls_verb(o, j))
if ((dobj == o) && (1 == j))
player:notify();
player:notify("-- Verbs --");
elseif (1 == j)
player:notify();
player:notify("-- Verbs from \"", o.name, "\" (", o, ") --");
else
player:notify();
endif
l = {i};
vd = $verb_detail(o, j);
`vd["state"] == "dirty" ! E_RANGE' && (l = {@l, "[dirty]"});
`vd["content_type"] ! E_RANGE' && (l = {@l, vd["content_type"]});
player:notify(l:join(" "));
player:notify("  ", toliteral(verb_info(o, j)));
player:notify("  ", toliteral(verb_args(o, j)));
else
if (1 == j)
player:notify();
player:notify("-- Verbs from \"", o.name, "\" (", o, ") --");
else
player:notify();
endif
player:notify(i);
player:notify("  <<permission denied>>");
endif
endfor
else
player:notify();
player:notify("-- Verbs from \"", o.name, "\" (", o, ") --");
player:notify("  <<permission denied>>");
endif
endfor
for o in (ancestors)
if (utilities:_player_controls_object(o) || o.r)
for i, j in (properties(o))
if (utilities:_player_controls_property(dobj, i))
if ((dobj == o) && (1 == j))
player:notify();
player:notify("-- Properties --");
elseif (1 == j)
player:notify();
player:notify("-- Properties from \"", o.name, "\" (", o, ") --");
else
player:notify();
endif
l = {i};
is_clear_property(dobj, i) && (l = {@l, "[clear]"});
l = {@l, toliteral(dobj.(i))};
player:notify(l:join(" "));
player:notify("  " + toliteral(property_info(dobj, i)));
else
if (1 == j)
player:notify();
player:notify("-- Properties from \"", o.name, "\" (", o, ") --");
else
player:notify();
endif
player:notify(i);
player:notify("  <<permission denied>>");
endif
endfor
else
player:notify();
player:notify("-- Properties from \"", o.name, "\" (", o, ") --");
player:notify("  <<permission denied>>");
endif
endfor
endif
player:notify();
player:notify("(done)");
return;
"if (player != this)";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"endif";
"";
"all = 0;";
"tail = {};";
"";
"utilities = $lookup(\"player_utilities\");";
"";
"if (!valid(dobj))";
"  {dobjstr, @tail} = utilities:extract_tail(dobjstr);";
"  dobj = utilities:match_object(dobjstr);";
"  all = (\"+all\" in tail) && !(\"-all\" in tail);";
"endif";
"if (!valid(dobj))";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"endif";
"";
"/* Default to all detail if the object defines";
" * no verbs or properties and there is no tail.";
" */";
"if (!tail)";
"  all = !(verbs(dobj) || properties(dobj));";
"endif";
"";
"/* everybody can see general information about the object */";
"";
"p = n = \"\";";
"dobj.r ? (p = p + \"r\") | (n = n + \"r\");";
"dobj.w ? (p = p + \"w\") | (n = n + \"w\");";
"dobj.f ? (p = p + \"f\") | (n = n + \"f\");";
"dobj.a ? (p = p + \"a\") | (n = n + \"a\");";
"";
"t = {};";
"`is_player(dobj) ! E_TYPE' && (t = {@t, \"player\"});";
"dobj.programmer && (t = {@t, \"programmer\"});";
"dobj.wizard && (t = {@t, \"wizard\"});";
"t = t:join(\", \");";
"";
"player:notify(\"\\\"\", dobj.name, \"\\\" (\", dobj, \")\", (p ? \" +\" | \"\"), p, (n ? \" -\" | \"\"), n, \" \", t);";
"player:notify(\"Parents: \", toliteral(parents(dobj)), \", \", \"Children: \", toliteral(children(dobj)));";
"player:notify(\"Location: \", toliteral(dobj.location), \", \", \"Contents: \", toliteral(dobj.contents));";
"player:notify(\"Owner: \", dobj.owner);";
"";
"/* Only display the details if the object is specifically in the";
" * player's control or generally readable.  If the object or any";
" * of its ancestors are in control/readable, include a section for";
" * the object/ancestor.  If a verb/property is in the player's";
" * control or is readable, include details about the verb/";
" * property.";
" */";
"";
"if (utilities:_player_controls_object(dobj) || dobj.r)";
"  ancestors = all ? {dobj, @ancestors(dobj)} | {dobj};";
"";
"  for o in (ancestors)";
"    if (utilities:_player_controls_object(o) || o.r)";
"      for i, j in (verbs(o))";
"        if (utilities:_player_controls_verb(o, j))";
"          if (dobj == o && 1 == j)";
"            player:notify();";
"            player:notify(\"-- Verbs --\");";
"          elseif (1 == j)";
"            player:notify();";
"            player:notify(\"-- Verbs from \\\"\", o.name, \"\\\" (\", o, \") --\");";
"          else";
"            player:notify();";
"          endif";
"          l = {i};";
"          vd = $verb_detail(o, j);";
"          `vd[\"state\"] == \"dirty\" ! E_RANGE' && (l = {@l, \"[dirty]\"});";
"          `vd[\"content_type\"] ! E_RANGE' && (l = {@l, vd[\"content_type\"]});";
"          player:notify(l:join(\" \"));";
"          player:notify(\"  \", toliteral(verb_info(o, j)));";
"          player:notify(\"  \", toliteral(verb_args(o, j)));";
"        else";
"          if (1 == j)";
"            player:notify();";
"            player:notify(\"-- Verbs from \\\"\", o.name, \"\\\" (\", o, \") --\");";
"          else";
"            player:notify();";
"          endif";
"          player:notify(i);";
"          player:notify(\"  <<permission denied>>\");";
"        endif";
"      endfor";
"    else";
"      player:notify();";
"      player:notify(\"-- Verbs from \\\"\", o.name, \"\\\" (\", o, \") --\");";
"      player:notify(\"  <<permission denied>>\");";
"    endif";
"  endfor";
"";
"  for o in (ancestors)";
"    if (utilities:_player_controls_object(o) || o.r)";
"      for i, j in (properties(o))";
"        if (utilities:_player_controls_property(dobj, i))";
"          if (dobj == o && 1 == j)";
"            player:notify();";
"            player:notify(\"-- Properties --\");";
"          elseif (1 == j)";
"            player:notify();";
"            player:notify(\"-- Properties from \\\"\", o.name, \"\\\" (\", o, \") --\");";
"          else";
"            player:notify();";
"          endif";
"          l = {i};";
"          is_clear_property(dobj, i) && (l = {@l, \"[clear]\"});";
"          l = {@l, toliteral(dobj.(i))};";
"          player:notify(l:join(\" \"));";
"          player:notify(\"  \" + toliteral(property_info(dobj, i)));";
"        else";
"          if (1 == j)";
"            player:notify();";
"            player:notify(\"-- Properties from \\\"\", o.name, \"\\\" (\", o, \") --\");";
"          else";
"            player:notify();";
"          endif";
"          player:notify(i);";
"          player:notify(\"  <<permission denied>>\");";
"        endif";
"      endfor";
"    else";
"      player:notify();";
"      player:notify(\"-- Properties from \\\"\", o.name, \"\\\" (\", o, \") --\");";
"      player:notify(\"  <<permission denied>>\");";
"    endif";
"  endfor";
"";
"endif";
"";
"player:notify();";
"player:notify(\"(done)\");";
"";
"chunk_length:135";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:7C0962940168BA3D034518A88EB186A7FCE7B040";
"-=-=-mxyzptlk-=-=-";
.
#109:5
if (player != this)
player:notify("I couldn't understand that.");
return;
elseif (!player.programmer)
player:notify("You need to be a programmer to @diff verb code.");
return;
endif
player_utilities = $lookup("player_utilities");
{o, v} = player_utilities:match_verb(dobjstr);
if (!v)
player:notify("I couldn't understand that.");
return;
elseif (v && (`vi = verb_info(o, v) ! E_VERBNF' == E_VERBNF))
player:notify("That verb doesn't exist.");
return;
elseif ((!player_utilities:_player_controls_verb(o, v)) && (!index(vi[2], "r")))
player:notify("You don't have permission to do that.");
return;
endif
vd = $verb_detail(o, v);
if (`vd["state"] ! E_RANGE' != "dirty")
player:notify("There is nothing to diff; the verb is clean.");
return;
endif
if (`vd["revision"] ! E_RANGE => 0' < 2)
player:notify("There is nothing to diff; there is only one revision.");
return;
endif
set_task_perms(player);
r1 = vd["revision"] - 1;
r2 = vd["revision"];
vc1 = verb_code(o, v, ["revision" -> r1]);
vc2 = verb_code(o, v, ["revision" -> r2]);
player:notify("--- ", dobjstr, " r", r1);
player:notify("+++ ", dobjstr, " r", r2, " (dirty)");
patience_diff = $lookup("patience_diff|text_tools");
diffs = patience_diff:diff(vc1, vc2);
for diff in (diffs)
pos1 = diff[2];
pos2 = diff[3];
if (diff[1] == "r")
df1 = diff[4];
ln1 = length(df1);
df2 = diff[5];
ln2 = length(df2);
elseif (diff[1] == "+")
df1 = {};
ln1 = 0;
df2 = diff[4];
ln2 = length(df2);
elseif (diff[1] = "-")
df1 = diff[4];
ln1 = length(df1);
df2 = {};
ln2 = 0;
endif
before = (pos1 > 1) ? tostr(" ", vc1[pos1 - 1]) | 0;
after = (((pos1 + ln1) - 1) < length(vc1)) ? tostr(" ", vc1[pos1 + ln1]) | 0;
player:notify("@@ -", pos1, ",", ln1, " +", pos2, ",", ln2, " @@");
before && player:notify(before);
for l in (df1)
player:notify("-" + l);
endfor
for l in (df2)
player:notify("+" + l);
endfor
after && player:notify(after);
endfor
player:notify("(done)");
return;
"if (player != this)";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"elseif (!player.programmer)";
"  player:notify(\"You need to be a programmer to @diff verb code.\");";
"  return;";
"endif";
"";
"player_utilities = $lookup(\"player_utilities\");";
"";
"{o, v} = player_utilities:match_verb(dobjstr);";
"if (!v)";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"elseif (v && `vi = verb_info(o, v) ! E_VERBNF' == E_VERBNF)";
"  player:notify(\"That verb doesn't exist.\");";
"  return;";
"elseif (!player_utilities:_player_controls_verb(o, v) && !index(vi[2], \"r\"))";
"  player:notify(\"You don't have permission to do that.\");";
"  return;";
"endif";
"";
"vd = $verb_detail(o, v);";
"if (`vd[\"state\"] ! E_RANGE' != \"dirty\")";
"  player:notify(\"There is nothing to diff; the verb is clean.\");";
"  return;";
"endif";
"if (`vd[\"revision\"] ! E_RANGE => 0' < 2)";
"  player:notify(\"There is nothing to diff; there is only one revision.\");";
"  return;";
"endif";
"";
"set_task_perms(player);";
"";
"r1 = vd[\"revision\"] - 1;";
"r2 = vd[\"revision\"];";
"";
"vc1 = verb_code(o, v, [\"revision\" -> r1]);";
"vc2 = verb_code(o, v, [\"revision\" -> r2]);";
"";
"player:notify(\"--- \", dobjstr, \" r\", r1);";
"player:notify(\"+++ \", dobjstr, \" r\", r2, \" (dirty)\");";
"";
"patience_diff = $lookup(\"patience_diff|text_tools\");";
"";
"diffs = patience_diff:diff(vc1, vc2);";
"";
"for diff in (diffs)";
"  pos1 = diff[2];";
"  pos2 = diff[3];";
"  if (diff[1] == \"r\")";
"    df1 = diff[4];";
"    ln1 = length(df1);";
"    df2 = diff[5];";
"    ln2 = length(df2);";
"  elseif (diff[1] == \"+\")";
"    df1 = {};";
"    ln1 = 0;";
"    df2 = diff[4];";
"    ln2 = length(df2);";
"  elseif (diff[1] = \"-\")";
"    df1 = diff[4];";
"    ln1 = length(df1);";
"    df2 = {};";
"    ln2 = 0;";
"  endif";
"  before = pos1 > 1 ? tostr(\" \", vc1[pos1 - 1]) | 0;";
"  after = pos1 + ln1 - 1 < length(vc1) ? tostr(\" \", vc1[pos1 + ln1]) | 0;";
"  player:notify(\"@@ -\", pos1, \",\", ln1, \" +\", pos2, \",\", ln2, \" @@\");";
"  before && player:notify(before);";
"  for l in (df1)";
"    player:notify(\"-\" + l);";
"  endfor";
"  for l in (df2)";
"    player:notify(\"+\" + l);";
"  endfor";
"  after && player:notify(after);";
"endfor";
"";
"player:notify(\"(done)\");";
"";
"chunk_length:80";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A47BE42A7D9589E8326AF92033ABEF72EE381BFD";
"-=-=-mxyzptlk-=-=-";
.
#109:6
if (player != this)
player:notify("I couldn't understand that.");
return;
elseif (!player.programmer)
player:notify("You need to be a programmer to ", verb, " verb code.");
return;
endif
player_utilities = $lookup("player_utilities");
{o, v} = player_utilities:match_verb(dobjstr);
if (!v)
player:notify("I couldn't understand that.");
return;
elseif (v && (`vi = verb_info(o, v) ! E_VERBNF' == E_VERBNF))
player:notify("That verb doesn't exist.");
return;
elseif ((!player_utilities:_player_controls_verb(o, v)) && (!index(vi[2], "w")))
player:notify("You don't have permission to do that.");
return;
endif
vd = $verb_detail(o, v);
if (`vd["state"] ! E_RANGE' != "dirty")
player:notify("There is nothing to ", verb[2..$], "; the verb is clean.");
return;
endif
if (("@revert" == verb) && (`vd["revision"] ! E_RANGE => 0' < 2))
player:notify("There is nothing to revert; there is only one revision.");
return;
endif
set_task_perms(player);
if ("@commit" == verb)
$verb_commit(o, v);
player:notify("You committed the changes to ", dobjstr);
elseif ("@revert" == verb)
$verb_revert(o, v);
player:notify("You reverted the changes to ", dobjstr);
endif
return;
"if (player != this)";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"elseif (!player.programmer)";
"  player:notify(\"You need to be a programmer to \", verb, \" verb code.\");";
"  return;";
"endif";
"";
"player_utilities = $lookup(\"player_utilities\");";
"";
"{o, v} = player_utilities:match_verb(dobjstr);";
"if (!v)";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"elseif (v && `vi = verb_info(o, v) ! E_VERBNF' == E_VERBNF)";
"  player:notify(\"That verb doesn't exist.\");";
"  return;";
"elseif (!player_utilities:_player_controls_verb(o, v) && !index(vi[2], \"w\"))";
"  player:notify(\"You don't have permission to do that.\");";
"  return;";
"endif";
"";
"vd = $verb_detail(o, v);";
"if (`vd[\"state\"] ! E_RANGE' != \"dirty\")";
"  player:notify(\"There is nothing to \", verb[2..$], \"; the verb is clean.\");";
"  return;";
"endif";
"";
"if (\"@revert\" == verb && `vd[\"revision\"] ! E_RANGE => 0' < 2)";
"  player:notify(\"There is nothing to revert; there is only one revision.\");";
"  return;";
"endif";
"";
"set_task_perms(player);";
"";
"if (\"@commit\" == verb)";
"  $verb_commit(o, v);";
"  player:notify(\"You committed the changes to \", dobjstr);";
"elseif (\"@revert\" == verb)";
"  $verb_revert(o, v);";
"  player:notify(\"You reverted the changes to \", dobjstr);";
"endif";
"";
"chunk_length:42";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:39BA28E527A97FD9B68E40D9EC05118E1BE8A11E";
"-=-=-mxyzptlk-=-=-";
.
#111:0
$restrict_to_caller($composed);
chparents(#5, {$alt.wizard_proto});
chparents(#6, {$alt.programmer_proto});
return;
"$restrict_to_caller($composed);";
"/* improvise-specific application tweaks */";
"chparents(#5, {$alt.wizard_proto});";
"chparents(#6, {$alt.programmer_proto});";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:47625885FC0B925292089EDE0ACD5F175697BDC2";
"-=-=-mxyzptlk-=-=-";
.
#113:0
$restrict_to_caller($system, "server_started");
$lookup("server"):start(8888);
.
#115:0
$private();
{?parameters = []} = args;
if (valid(player))
return parameters:merge(["links" -> {["id" -> tonum($system), "name" -> "$system"], ["id" -> tonum(player.location), "name" -> "home"], ["id" -> tonum(player), "name" -> "me"]}, "player" -> ["id" -> tonum(player), "name" -> player.name], "page" -> ["title" -> "Stunt | Improvise"]]);
else
return parameters:merge(["links" -> {["id" -> tonum($system), "name" -> "$system"]}, "page" -> ["title" -> "Stunt | Improvise"]]);
endif
return;
"$private();";
"";
"{?parameters = []} = args;";
"";
"if (valid(player))";
"  return parameters:merge([";
"    \"links\" -> {";
"      [\"id\" -> tonum($system), \"name\" -> \"$system\"],";
"      [\"id\" -> tonum(player.location), \"name\" -> \"home\"],";
"      [\"id\" -> tonum(player), \"name\" -> \"me\"]";
"    },";
"    \"player\" -> [\"id\" -> tonum(player), \"name\" -> player.name],";
"    \"page\" -> [\"title\" -> \"Stunt | Improvise\"]";
"  ]);";
"else";
"  return parameters:merge([";
"    \"links\" -> {";
"      [\"id\" -> tonum($system), \"name\" -> \"$system\"]";
"    },";
"    \"page\" -> [\"title\" -> \"Stunt | Improvise\"]";
"  ]);";
"endif";
"";
"chunk_length:22";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:8EA0088393B6703B267559CBB18092ABDDE672A4";
"-=-=-mxyzptlk-=-=-";
.
#115:1
$restrict_to_caller($dialog.server);
{request, response} = args;
parameters = this:_common(request:parameters());
if (valid(player))
parameters = parameters:merge(["page" -> ["title" -> "Stunt | Improvise", "swf" -> 1]]);
view = "home";
else
view = "public";
endif
response = response:set_status(200):set_type("text/html"):set_body($lookup("home_views"):(view)(parameters));
return {request, response};
return;
"$restrict_to_caller($dialog.server);";
"";
"{request, response} = args;";
"";
"parameters = this:_common(request:parameters());";
"";
"if (valid(player))";
"  parameters = parameters:merge([ \"page\" -> [\"title\" -> \"Stunt | Improvise\", \"swf\" -> 1]]);";
"  view = \"home\";";
"else";
"  view = \"public\";";
"endif";
"";
"response = response:set_status(200):set_type(\"text/html\"):set_body($lookup(\"home_views\"):(view)(parameters));";
"";
"return {request, response};";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:1F45EF1CB2EF68DAA28970CBED1035D3805E2EC8";
"-=-=-mxyzptlk-=-=-";
.
#115:2
$restrict_to_caller($dialog.server);
{request, response} = args;
parameters = this:_common(request:parameters());
response = response:set_status(200):set_type("text/html"):set_body($lookup("home_views"):browse(parameters));
return {request, response};
return;
"$restrict_to_caller($dialog.server);";
"";
"{request, response} = args;";
"";
"parameters = this:_common(request:parameters());";
"";
"response = response:set_status(200):set_type(\"text/html\"):set_body($lookup(\"home_views\"):browse(parameters));";
"";
"return {request, response};";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:777A0606BD3B75404A03C8DD6FD3CEF9D4BC6DBE";
"-=-=-mxyzptlk-=-=-";
.
#116:0
stack = args;
output = {};
output = {@output, "<head>", 0};
output = {@output, "  <title>"};
top = `stack[1]["page"] ! E_RANGE';
stack = {(typeof(top) == MAP) ? top | ([]), @stack};
output = {@output, strsub(strsub(strsub(strsub(`tostr(stack[1]["title"]) ! E_RANGE => ""', "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), "\"", "&quot;")};
stack = stack[2..$];
output = {@output, "</title>", 1};
output = {@output, "  <meta name=\"authenticity_token\" content=\""};
output = {@output, strsub(strsub(strsub(strsub(`tostr(stack[1]["__authenticity_token__"]) ! E_RANGE => ""', "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), "\"", "&quot;")};
output = {@output, "\"/>", 1};
output = {@output, "  "};
failed = 0;
if (top = `stack[1]["page"] ! E_RANGE')
stack = {stack[1]:merge((typeof(top) == MAP) ? top | ([])), @stack};
else
stack = {[], @stack};
failed = 1;
endif
if ((!failed) && (top = `stack[1]["swf"] ! E_RANGE'))
for item in ((typeof(top) == LIST) ? top | {top})
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
stack = {(typeof(item) == MAP) ? item | (["." -> item]), @stack};
output = {@output, 1};
output = {@output, "    <script type=\"text/javascript\" src=\"/js/Socket.js\"></script>", 0};
output = {@output, "    <script type=\"text/javascript\" src=\"/js/swfobject-2.1.min.js\"></script>", 0};
output = {@output, "    <script type=\"text/javascript\">", 0};
output = {@output, "      var flashvars = {};", 0};
output = {@output, "      var params = {menu: 'false', scale: 'noScale', allowScriptAccess: 'always', bgcolor: '#FFFFFF'};", 0};
output = {@output, "      var attributes = {id: 'JavascriptSocket', name: 'JavascriptSocket'};", 0};
output = {@output, "      swfobject.embedSWF('/flash/javascriptsocket.swf', 'flash-content', '100%', '100%', '9.0.0', null, flashvars, params, attributes);", 0};
output = {@output, "    </script>", 0};
output = {@output, "  "};
stack = stack[2..$];
endfor
endif
stack = stack[2..$];
output = {@output, 1};
output = {@output, "  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/bootstrap-2.0.2.min.css\">", 0};
output = {@output, "  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/bootstrap-responsive-2.0.2.min.css\">", 0};
output = {@output, "  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/font-awesome-1.0.0-7.min.css\">", 0};
output = {@output, "  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/moo-0.0.4.min.css\">", 0};
output = {@output, "  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/console.min.css\">", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/jquery-1.7.1.min.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/jquery.ui.core-1.8.18.min.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/jquery.ui.widget-1.8.18.min.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/jquery.console-1.1.0.min.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/underscore-1.3.1.min.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/backbone-0.9.2.min.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/bootstrap-dropdown-2.0.2.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/bootstrap-modal-2.0.2.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/bootstrap-transition-2.0.2.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/moo-0.0.4.min.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/moo-interactive-0.0.3.min.js\"></script>", 0};
output = {@output, "</head>", 0};
out = {};
acc = {};
indent = "";
while (output)
{line, @output} = output;
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (typeof(line) == LIST)
elseif (typeof(line) == INT)
if (line > 0)
if (match(acc = tostr(@acc), "[^ ]"))
out = {@out, acc};
endif
else
out = {@out, tostr(@acc)};
endif
acc = {};
else
acc = {@acc, line};
endif
endwhile
return out;
return;
"<head>";
"  <title>{{page.title}}</title>";
"  <meta name=\"authenticity_token\" content=\"{{__authenticity_token__}}\"/>";
"  {{#page.swf}}";
"    <script type=\"text/javascript\" src=\"/js/Socket.js\"></script>";
"    <script type=\"text/javascript\" src=\"/js/swfobject-2.1.min.js\"></script>";
"    <script type=\"text/javascript\">";
"      var flashvars = {};";
"      var params = {menu: 'false', scale: 'noScale', allowScriptAccess: 'always', bgcolor: '#FFFFFF'};";
"      var attributes = {id: 'JavascriptSocket', name: 'JavascriptSocket'};";
"      swfobject.embedSWF('/flash/javascriptsocket.swf', 'flash-content', '100%', '100%', '9.0.0', null, flashvars, params, attributes);";
"    </script>";
"  {{/page.swf}}";
"  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/bootstrap-2.0.2.min.css\">";
"  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/bootstrap-responsive-2.0.2.min.css\">";
"  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/font-awesome-1.0.0-7.min.css\">";
"  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/moo-0.0.4.min.css\">";
"  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/console.min.css\">";
"  <script type=\"text/javascript\" src=\"/js/jquery-1.7.1.min.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/jquery.ui.core-1.8.18.min.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/jquery.ui.widget-1.8.18.min.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/jquery.console-1.1.0.min.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/underscore-1.3.1.min.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/backbone-0.9.2.min.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/bootstrap-dropdown-2.0.2.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/bootstrap-modal-2.0.2.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/bootstrap-transition-2.0.2.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/moo-0.0.4.min.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/moo-interactive-0.0.3.min.js\"></script>";
"</head>";
"";
"chunk_length:30";
"chunk_type:source";
"content_type:application/x-mustache";
"sha1:CD6D0B6F34A532741F2F60BD478CE85CBB7B7072";
"-=-=-mxyzptlk-=-=-";
.
#116:1
stack = args;
output = {};
output = {@output, ""};
failed = 0;
if (top = `stack[1]["page"] ! E_RANGE')
stack = {stack[1]:merge((typeof(top) == MAP) ? top | ([])), @stack};
else
stack = {[], @stack};
failed = 1;
endif
if ((!failed) && (top = `stack[1]["swf"] ! E_RANGE'))
for item in ((typeof(top) == LIST) ? top | {top})
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
stack = {(typeof(item) == MAP) ? item | (["." -> item]), @stack};
output = {@output, 1};
output = {@output, "  <div id=\"flash-content\"></div>", 0};
output = {@output, ""};
stack = stack[2..$];
endfor
endif
stack = stack[2..$];
output = {@output, 1};
output = {@output, "<script type=\"text/javascript\">", 0};
output = {@output, "", 0};
output = {@output, "  var authenticity_token = $(\"meta[name=authenticity_token]\").attr(\"content\");", 0};
output = {@output, "", 0};
output = {@output, "  $(document).ajaxSend(function(event, xhr, settings) {", 0};
output = {@output, "    xhr.setRequestHeader(\"X-Authenticity-Token\", authenticity_token);", 0};
output = {@output, "  });", 0};
output = {@output, "", 0};
output = {@output, "  $(\"#disconnect\").click(function(e) {", 0};
output = {@output, "    e.preventDefault();", 0};
output = {@output, "    $.post($(this).attr(\"href\"), function() {", 0};
output = {@output, "      window.location.href = \"/\";", 0};
output = {@output, "    });", 0};
output = {@output, "  });", 0};
output = {@output, "</script>", 0};
out = {};
acc = {};
indent = "";
while (output)
{line, @output} = output;
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (typeof(line) == LIST)
elseif (typeof(line) == INT)
if (line > 0)
if (match(acc = tostr(@acc), "[^ ]"))
out = {@out, acc};
endif
else
out = {@out, tostr(@acc)};
endif
acc = {};
else
acc = {@acc, line};
endif
endwhile
return out;
return;
"{{#page.swf}}";
"  <div id=\"flash-content\"></div>";
"{{/page.swf}}";
"<script type=\"text/javascript\">";
"";
"  var authenticity_token = $(\"meta[name=authenticity_token]\").attr(\"content\");";
"";
"  $(document).ajaxSend(function(event, xhr, settings) {";
"    xhr.setRequestHeader(\"X-Authenticity-Token\", authenticity_token);";
"  });";
"";
"  $(\"#disconnect\").click(function(e) {";
"    e.preventDefault();";
"    $.post($(this).attr(\"href\"), function() {";
"      window.location.href = \"/\";";
"    });";
"  });";
"</script>";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-mustache";
"sha1:9F3D0B2DEE4CB78C3D159EFEFFEA556046D6BAC2";
"-=-=-mxyzptlk-=-=-";
.
#116:2
stack = args;
output = {};
output = {@output, "<div class=\"navbar navbar-fixed-top\">", 0};
output = {@output, "  <div class=\"navbar-inner\">", 0};
output = {@output, "    <div class=\"container\">", 0};
output = {@output, "      <a class=\"brand\" href=\"/\">", 0};
output = {@output, "        "};
top = `stack[1]["page"] ! E_RANGE';
stack = {(typeof(top) == MAP) ? top | ([]), @stack};
output = {@output, strsub(strsub(strsub(strsub(`tostr(stack[1]["title"]) ! E_RANGE => ""', "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), "\"", "&quot;")};
stack = stack[2..$];
output = {@output, 1};
output = {@output, "      </a>", 0};
output = {@output, "      <ul class=\"nav\">", 0};
output = {@output, "        "};
if (top = `stack[1]["player"] ! E_RANGE')
for item in ((typeof(top) == LIST) ? top | {top})
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
stack = {stack[1]:merge((typeof(item) == MAP) ? item | (["." -> item])), @stack};
output = {@output, 1};
output = {@output, "          <li>", 0};
output = {@output, "            <a href=\"/\">Console</a>", 0};
output = {@output, "          </li>", 0};
output = {@output, "        "};
stack = stack[2..$];
endfor
endif
output = {@output, 1};
output = {@output, "        <li class=\"dropdown\">", 0};
output = {@output, "          <a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\">Browse To<b class=\"caret\"></b></a>", 0};
output = {@output, "          <ul class=\"dropdown-menu\">", 0};
output = {@output, "            "};
if (top = `stack[1]["links"] ! E_RANGE')
for item in ((typeof(top) == LIST) ? top | {top})
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
stack = {stack[1]:merge((typeof(item) == MAP) ? item | (["." -> item])), @stack};
output = {@output, 1};
output = {@output, "              <li><a rel=\"object\" data-object-number=\""};
output = {@output, strsub(strsub(strsub(strsub(`tostr(stack[1]["id"]) ! E_RANGE => ""', "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), "\"", "&quot;")};
output = {@output, "\" href=\"/objects/"};
output = {@output, strsub(strsub(strsub(strsub(`tostr(stack[1]["id"]) ! E_RANGE => ""', "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), "\"", "&quot;")};
output = {@output, "\">"};
output = {@output, strsub(strsub(strsub(strsub(`tostr(stack[1]["name"]) ! E_RANGE => ""', "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), "\"", "&quot;")};
output = {@output, "</a></li>", 3};
output = {@output, "            "};
stack = stack[2..$];
endfor
endif
output = {@output, 1};
output = {@output, "          </ul>", 0};
output = {@output, "        </li>", 0};
output = {@output, "      </ul>", 0};
output = {@output, "      <ul class=\"nav pull-right\">", 0};
output = {@output, "        "};
if (top = `stack[1]["player"] ! E_RANGE')
for item in ((typeof(top) == LIST) ? top | {top})
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
stack = {stack[1]:merge((typeof(item) == MAP) ? item | (["." -> item])), @stack};
output = {@output, 1};
output = {@output, "          <li><a id=\"disconnect\" href=\"/session/destroy\">Disconnect</a></li>", 0};
output = {@output, "        "};
stack = stack[2..$];
endfor
endif
output = {@output, 1};
output = {@output, "        "};
if (!(top = `stack[1]["player"] ! E_RANGE'))
for item in ({""})
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
stack = {stack[1]:merge((typeof(item) == MAP) ? item | (["." -> item])), @stack};
output = {@output, 1};
output = {@output, "          <li><a href=\"/\">Connect</a></li>", 0};
output = {@output, "        "};
stack = stack[2..$];
endfor
endif
output = {@output, 1};
output = {@output, "      </ul>", 0};
output = {@output, "    </div>", 0};
output = {@output, "  </div>", 0};
output = {@output, "</div>", 0};
out = {};
acc = {};
indent = "";
while (output)
{line, @output} = output;
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (typeof(line) == LIST)
elseif (typeof(line) == INT)
if (line > 0)
if (match(acc = tostr(@acc), "[^ ]"))
out = {@out, acc};
endif
else
out = {@out, tostr(@acc)};
endif
acc = {};
else
acc = {@acc, line};
endif
endwhile
return out;
return;
"<div class=\"navbar navbar-fixed-top\">";
"  <div class=\"navbar-inner\">";
"    <div class=\"container\">";
"      <a class=\"brand\" href=\"/\">";
"        {{page.title}}";
"      </a>";
"      <ul class=\"nav\">";
"        {{#player}}";
"          <li>";
"            <a href=\"/\">Console</a>";
"          </li>";
"        {{/player}}";
"        <li class=\"dropdown\">";
"          <a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\">Browse To<b class=\"caret\"></b></a>";
"          <ul class=\"dropdown-menu\">";
"            {{#links}}";
"              <li><a rel=\"object\" data-object-number=\"{{id}}\" href=\"/objects/{{id}}\">{{name}}</a></li>";
"            {{/links}}";
"          </ul>";
"        </li>";
"      </ul>";
"      <ul class=\"nav pull-right\">";
"        {{#player}}";
"          <li><a id=\"disconnect\" href=\"/session/destroy\">Disconnect</a></li>";
"        {{/player}}";
"        {{^player}}";
"          <li><a href=\"/\">Connect</a></li>";
"        {{/player}}";
"      </ul>";
"    </div>";
"  </div>";
"</div>";
"";
"chunk_length:32";
"chunk_type:source";
"content_type:application/x-mustache";
"sha1:BB81418E9CDC9537A706F603B5475A95D2ACB503";
"-=-=-mxyzptlk-=-=-";
.
#116:3
stack = args;
output = {};
output = {@output, "<!DOCTYPE html>", 0};
output = {@output, "<html lang=\"en\">", 0};
output = {@output, ""};
verb = `this:_head(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "<body>", 0};
output = {@output, "  <style type=\"text/css\">", 0};
output = {@output, "    body .container .mark {", 0};
output = {@output, "      font-weight: bold;", 0};
output = {@output, "    }", 0};
output = {@output, "    #logo {", 0};
output = {@output, "      width: 450px;", 0};
output = {@output, "      margin: 40px 10px;", 0};
output = {@output, "    }", 0};
output = {@output, "  </style>", 0};
output = {@output, "  <div class=\"container\">", 0};
output = {@output, "    &nbsp;", 0};
output = {@output, "    <div class=\"row\">", 0};
output = {@output, "      <div class=\"span12\">", 0};
output = {@output, "        <h1>Welcome to Stunt | Improvise</h1>", 0};
output = {@output, "      </div>", 0};
output = {@output, "    </div>", 0};
output = {@output, "    &nbsp;", 0};
output = {@output, "    <div class=\"row\">", 0};
output = {@output, "      <div class=\"span5\">", 0};
output = {@output, "        <form class=\"well form-inline\" action=\"/session/create\" method=\"post\">", 0};
output = {@output, "          <input type=\"hidden\" name=\"_authenticity_token\" value=\""};
output = {@output, strsub(strsub(strsub(strsub(`tostr(stack[1]["__authenticity_token__"]) ! E_RANGE => ""', "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), "\"", "&quot;")};
output = {@output, "\">", 1};
output = {@output, "          <button type=\"submit\" name=\"submit\">Connect</button>", 0};
output = {@output, "          <input class=\"span3\" type=\"text\" name=\"credentials\" placeholder=\"credentials, ex: &lt;player&gt; &lt;password&gt;\">", 0};
output = {@output, "        </form>", 0};
output = {@output, "        <img id=\"logo\" src=\"/img/stunt.png\">", 0};
output = {@output, "      </div>", 0};
output = {@output, "      <div class=\"span7\">", 0};
output = {@output, "        <h2>Get Started</h2>", 0};
output = {@output, "        <p>", 0};
output = {@output, "          &larr; Use the form on the left to connect to a specific player.", 0};
output = {@output, "        </p>", 0};
output = {@output, "        <h2>About Stunt | Improvise</h2>", 0};
output = {@output, "        <p>", 0};
output = {@output, "          <a href=\"https://github.com/toddsundsted/stunt\">Stunt</a>", 0};
output = {@output, "          is a set of extensions to the <a href=\"http://sourceforge.net/projects/lambdamoo/\">LambdaMOO server</a>", 0};
output = {@output, "          and <a href=\"https://github.com/toddsundsted/improvise\">Improvise</a>", 0};
output = {@output, "          is an associated framework that uses those extensions.", 0};
output = {@output, "        </p>", 0};
output = {@output, "        <p>", 0};
output = {@output, "          <span class=\"mark\">Stunt | Improvise</span> is well suited", 0};
output = {@output, "          for building immersive, collaborative, Web-based", 0};
output = {@output, "          applications &mdash; specifically, applications where", 0};
output = {@output, "          every <em>user</em> is a <em>programmer</em>.", 0};
output = {@output, "        </p>", 0};
output = {@output, "        <p>", 0};
output = {@output, "          Together, <span class=\"mark\">Stunt | Improvise</span>", 0};
output = {@output, "          comprise:", 0};
output = {@output, "        </p>", 0};
output = {@output, "        <ul>", 0};
output = {@output, "          <li>a persistent, NoSQL object database with a simple JSON API</li>", 0};
output = {@output, "          <li>an server-side HTTP-based MVC framework with support for HTML5 features like pushState</li>", 0};
output = {@output, "          <li>a client-side RAI framework based on Backbone.js</li>", 0};
output = {@output, "          <li>a framework for securely executing untrusted code</li>", 0};
output = {@output, "          <li>a simple, embedded programming language</li>", 0};
output = {@output, "          <li>integrated package management</li>", 0};
output = {@output, "        </ul>", 0};
output = {@output, "        <h2>Learn More</h2>", 0};
output = {@output, "        <p>", 0};
output = {@output, "          To learn more, check out:", 0};
output = {@output, "        </p>", 0};
output = {@output, "        <ul>", 0};
output = {@output, "          <li><a href=\"http://stunt.io/\">the Stunt.io website</a></li>", 0};
output = {@output, "          <li><a href=\"https://github.com/toddsundsted/improvise/wiki\">the Improvise wiki</a></li>", 0};
output = {@output, "          <li><a href=\"http://stunt.io/ProgrammersManual.html\">the LambdaMOO Programmers Manual</a></li>", 0};
output = {@output, "          <li><a href=\"https://github.com/toddsundsted/stunt\">the Stunt GitHub project</a></li>", 0};
output = {@output, "          <li><a href=\"https://github.com/toddsundsted/improvise\">the Improvise GitHub project</a></li>", 0};
output = {@output, "        </ul>", 0};
output = {@output, "      </div>", 0};
output = {@output, "    </div>", 0};
output = {@output, "  </div>", 0};
output = {@output, ""};
verb = `this:_foot(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "</body>", 0};
output = {@output, "</html>", 0};
out = {};
acc = {};
indent = "";
while (output)
{line, @output} = output;
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (typeof(line) == LIST)
if (lines = line)
if (length(lines) > 1)
temp = {lines[1], 0};
for line in (lines[2..$ - 1])
temp = {@temp, indent + line, 0};
endfor
temp = {@temp, indent + lines[$]};
output = {@temp, @output};
else
output = {lines[1], @output};
endif
endif
elseif (typeof(line) == INT)
if (line > 0)
if (match(acc = tostr(@acc), "[^ ]"))
out = {@out, acc};
endif
else
out = {@out, tostr(@acc)};
endif
acc = {};
indent = "";
else
if (!match(line, "[^ ]"))
indent = line;
endif
acc = {@acc, line};
endif
endwhile
return out;
return;
"<!DOCTYPE html>";
"<html lang=\"en\">";
"{{> _head}}";
"<body>";
"  <style type=\"text/css\">";
"    body .container .mark {";
"      font-weight: bold;";
"    }";
"    #logo {";
"      width: 450px;";
"      margin: 40px 10px;";
"    }";
"  </style>";
"  <div class=\"container\">";
"    &nbsp;";
"    <div class=\"row\">";
"      <div class=\"span12\">";
"        <h1>Welcome to Stunt | Improvise</h1>";
"      </div>";
"    </div>";
"    &nbsp;";
"    <div class=\"row\">";
"      <div class=\"span5\">";
"        <form class=\"well form-inline\" action=\"/session/create\" method=\"post\">";
"          <input type=\"hidden\" name=\"_authenticity_token\" value=\"{{__authenticity_token__}}\">";
"          <button type=\"submit\" name=\"submit\">Connect</button>";
"          <input class=\"span3\" type=\"text\" name=\"credentials\" placeholder=\"credentials, ex: &lt;player&gt; &lt;password&gt;\">";
"        </form>";
"        <img id=\"logo\" src=\"/img/stunt.png\">";
"      </div>";
"      <div class=\"span7\">";
"        <h2>Get Started</h2>";
"        <p>";
"          &larr; Use the form on the left to connect to a specific player.";
"        </p>";
"        <h2>About Stunt | Improvise</h2>";
"        <p>";
"          <a href=\"https://github.com/toddsundsted/stunt\">Stunt</a>";
"          is a set of extensions to the <a href=\"http://sourceforge.net/projects/lambdamoo/\">LambdaMOO server</a>";
"          and <a href=\"https://github.com/toddsundsted/improvise\">Improvise</a>";
"          is an associated framework that uses those extensions.";
"        </p>";
"        <p>";
"          <span class=\"mark\">Stunt | Improvise</span> is well suited";
"          for building immersive, collaborative, Web-based";
"          applications &mdash; specifically, applications where";
"          every <em>user</em> is a <em>programmer</em>.";
"        </p>";
"        <p>";
"          Together, <span class=\"mark\">Stunt | Improvise</span>";
"          comprise:";
"        </p>";
"        <ul>";
"          <li>a persistent, NoSQL object database with a simple JSON API</li>";
"          <li>an server-side HTTP-based MVC framework with support for HTML5 features like pushState</li>";
"          <li>a client-side RAI framework based on Backbone.js</li>";
"          <li>a framework for securely executing untrusted code</li>";
"          <li>a simple, embedded programming language</li>";
"          <li>integrated package management</li>";
"        </ul>";
"        <h2>Learn More</h2>";
"        <p>";
"          To learn more, check out:";
"        </p>";
"        <ul>";
"          <li><a href=\"http://stunt.io/\">the Stunt.io website</a></li>";
"          <li><a href=\"https://github.com/toddsundsted/improvise/wiki\">the Improvise wiki</a></li>";
"          <li><a href=\"http://stunt.io/ProgrammersManual.html\">the LambdaMOO Programmers Manual</a></li>";
"          <li><a href=\"https://github.com/toddsundsted/stunt\">the Stunt GitHub project</a></li>";
"          <li><a href=\"https://github.com/toddsundsted/improvise\">the Improvise GitHub project</a></li>";
"        </ul>";
"      </div>";
"    </div>";
"  </div>";
"{{> _foot}}";
"</body>";
"</html>";
"";
"chunk_length:77";
"chunk_type:source";
"content_type:application/x-mustache";
"sha1:8F784715A251BE01FF08E30991DD524727A25074";
"-=-=-mxyzptlk-=-=-";
.
#116:4
stack = args;
output = {};
output = {@output, "<!DOCTYPE html>", 0};
output = {@output, "<html lang=\"en\">", 0};
output = {@output, "  "};
verb = `this:_head(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "  <body>", 0};
output = {@output, "    "};
verb = `this:_nav(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "    <div id=\"top\" class=\"container\" style=\"padding-top: 60px;\">", 0};
output = {@output, "      <div class=\"row\">", 0};
output = {@output, "        <div id=\"console\" class=\"console span12\"></div>", 0};
output = {@output, "      </div>", 0};
output = {@output, "    </div>", 0};
output = {@output, "    <script type=\"text/javascript\">", 0};
output = {@output, "      $(function() {", 0};
output = {@output, "        var console1 = $('#console').console({", 0};
output = {@output, "           autofocus:true,", 0};
output = {@output, "           animateScroll:true,", 0};
output = {@output, "           promptHistory:true,", 0};
output = {@output, "           promptLabel: '> ',", 0};
output = {@output, "           commandHandle:function(command){", 0};
output = {@output, "             interactive.send(command + '\\n');", 0};
output = {@output, "             return true;", 0};
output = {@output, "           }", 0};
output = {@output, "        });", 0};
output = {@output, "        $('#console .jquery-console-inner').height($(window).height() - 140);", 0};
output = {@output, "        var interactive = new Moo.Interactive(window.location.hostname, window.location.port, {", 0};
output = {@output, "          callback: function(message) {", 0};
output = {@output, "            message = message.split('\\n');", 0};
output = {@output, "            message = _.select(message, function(v) { return v; });", 0};
output = {@output, "            message = _.map(message, function(v) { return {msg: v} });", 0};
output = {@output, "            console1.append(message);", 0};
output = {@output, "          }", 0};
output = {@output, "        });", 0};
output = {@output, "      });", 0};
output = {@output, "    </script>", 0};
output = {@output, "    "};
verb = `this:_foot(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "  </body>", 0};
output = {@output, "</html>", 0};
out = {};
acc = {};
indent = "";
while (output)
{line, @output} = output;
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (typeof(line) == LIST)
if (lines = line)
if (length(lines) > 1)
temp = {lines[1], 0};
for line in (lines[2..$ - 1])
temp = {@temp, indent + line, 0};
endfor
temp = {@temp, indent + lines[$]};
output = {@temp, @output};
else
output = {lines[1], @output};
endif
endif
elseif (typeof(line) == INT)
if (line > 0)
if (match(acc = tostr(@acc), "[^ ]"))
out = {@out, acc};
endif
else
out = {@out, tostr(@acc)};
endif
acc = {};
indent = "";
else
if (!match(line, "[^ ]"))
indent = line;
endif
acc = {@acc, line};
endif
endwhile
return out;
return;
"<!DOCTYPE html>";
"<html lang=\"en\">";
"  {{> _head}}";
"  <body>";
"    {{> _nav}}";
"    <div id=\"top\" class=\"container\" style=\"padding-top: 60px;\">";
"      <div class=\"row\">";
"        <div id=\"console\" class=\"console span12\"></div>";
"      </div>";
"    </div>";
"    <script type=\"text/javascript\">";
"      $(function() {";
"        var console1 = $('#console').console({";
"           autofocus:true,";
"           animateScroll:true,";
"           promptHistory:true,";
"           promptLabel: '> ',";
"           commandHandle:function(command){";
"             interactive.send(command + '\\n');";
"             return true;";
"           }";
"        });";
"        $('#console .jquery-console-inner').height($(window).height() - 140);";
"        var interactive = new Moo.Interactive(window.location.hostname, window.location.port, {";
"          callback: function(message) {";
"            message = message.split('\\n');";
"            message = _.select(message, function(v) { return v; });";
"            message = _.map(message, function(v) { return {msg: v} });";
"            console1.append(message);";
"          }";
"        });";
"      });";
"    </script>";
"    {{> _foot}}";
"  </body>";
"</html>";
"";
"chunk_length:36";
"chunk_type:source";
"content_type:application/x-mustache";
"sha1:56345025A8BE60097FE7DFF597125FA592E0528C";
"-=-=-mxyzptlk-=-=-";
.
#116:5
stack = args;
output = {};
output = {@output, "<!DOCTYPE html>", 0};
output = {@output, "<html lang=\"en\">", 0};
output = {@output, "  "};
verb = `this:_head(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "  <body>", 0};
output = {@output, "    "};
verb = `this:_nav(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "    <div id=\"top\" class=\"container\" style=\"padding-top: 60px;\">", 0};
output = {@output, "      <p id=\"browser\" class=\"browser\"></p>", 0};
output = {@output, "    </div>", 0};
output = {@output, "    <script type=\"text/javascript\">", 0};
output = {@output, "      $(function() {", 0};
output = {@output, "        Moo.Object.prototype.urlRoot = 'http://' + window.location.host + '///objects';", 0};
output = {@output, "", 0};
output = {@output, "        var $browser = $('#browser');", 0};
output = {@output, "        $browser.simpleObjectPanel();", 0};
output = {@output, "", 0};
output = {@output, "        Moo.Space = Backbone.Router.extend({", 0};
output = {@output, "          routes: {", 0};
output = {@output, "            'objects/:number': 'browse'", 0};
output = {@output, "          },", 0};
output = {@output, "          browse: function(number) {", 0};
output = {@output, "            var o = new Moo.Object({id: number});", 0};
output = {@output, "            o.fetch({", 0};
output = {@output, "              success: function(model, response) {", 0};
output = {@output, "                $browser.simpleObjectPanel({object: o});", 0};
output = {@output, "                $('#top').get(0).scrollIntoView(true);", 0};
output = {@output, "              },", 0};
output = {@output, "              error: function(model, response) {", 0};
output = {@output, "                $browser.simpleObjectPanel({object: o});", 0};
output = {@output, "                $('#top').get(0).scrollIntoView(true);", 0};
output = {@output, "              }", 0};
output = {@output, "            });", 0};
output = {@output, "          }", 0};
output = {@output, "        });", 0};
output = {@output, "        var moo = new Moo.Space;", 0};
output = {@output, "", 0};
output = {@output, "        $('body').on('click', 'a[rel*=object]', function(e) {", 0};
output = {@output, "          e.preventDefault();", 0};
output = {@output, "          var o = $(e.target).data('object-number');", 0};
output = {@output, "          moo.navigate('/objects/' + o, {trigger: true});", 0};
output = {@output, "        });", 0};
output = {@output, "", 0};
output = {@output, "        Backbone.history.start({pushState: true});", 0};
output = {@output, "", 0};
output = {@output, "        "};
if (top = `stack[1]["id"] ! E_RANGE')
for item in ((typeof(top) == LIST) ? top | {top})
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
stack = {stack[1]:merge((typeof(item) == MAP) ? item | (["." -> item])), @stack};
output = {@output, 1};
output = {@output, "          moo.navigate('/objects/"};
output = {@output, strsub(strsub(strsub(strsub(`tostr(stack[1]["id"]) ! E_RANGE => ""', "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), "\"", "&quot;")};
output = {@output, "');", 1};
output = {@output, "        "};
stack = stack[2..$];
endfor
endif
output = {@output, 1};
output = {@output, "      });", 0};
output = {@output, "    </script>", 0};
output = {@output, "    "};
verb = `this:_foot(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "  </body>", 0};
output = {@output, "</html>", 0};
out = {};
acc = {};
indent = "";
while (output)
{line, @output} = output;
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (typeof(line) == LIST)
if (lines = line)
if (length(lines) > 1)
temp = {lines[1], 0};
for line in (lines[2..$ - 1])
temp = {@temp, indent + line, 0};
endfor
temp = {@temp, indent + lines[$]};
output = {@temp, @output};
else
output = {lines[1], @output};
endif
endif
elseif (typeof(line) == INT)
if (line > 0)
if (match(acc = tostr(@acc), "[^ ]"))
out = {@out, acc};
endif
else
out = {@out, tostr(@acc)};
endif
acc = {};
indent = "";
else
if (!match(line, "[^ ]"))
indent = line;
endif
acc = {@acc, line};
endif
endwhile
return out;
return;
"<!DOCTYPE html>";
"<html lang=\"en\">";
"  {{> _head}}";
"  <body>";
"    {{> _nav}}";
"    <div id=\"top\" class=\"container\" style=\"padding-top: 60px;\">";
"      <p id=\"browser\" class=\"browser\"></p>";
"    </div>";
"    <script type=\"text/javascript\">";
"      $(function() {";
"        Moo.Object.prototype.urlRoot = 'http://' + window.location.host + '///objects';";
"";
"        var $browser = $('#browser');";
"        $browser.simpleObjectPanel();";
"";
"        Moo.Space = Backbone.Router.extend({";
"          routes: {";
"            'objects/:number': 'browse'";
"          },";
"          browse: function(number) {";
"            var o = new Moo.Object({id: number});";
"            o.fetch({";
"              success: function(model, response) {";
"                $browser.simpleObjectPanel({object: o});";
"                $('#top').get(0).scrollIntoView(true);";
"              },";
"              error: function(model, response) {";
"                $browser.simpleObjectPanel({object: o});";
"                $('#top').get(0).scrollIntoView(true);";
"              }";
"            });";
"          }";
"        });";
"        var moo = new Moo.Space;";
"";
"        $('body').on('click', 'a[rel*=object]', function(e) {";
"          e.preventDefault();";
"          var o = $(e.target).data('object-number');";
"          moo.navigate('/objects/' + o, {trigger: true});";
"        });";
"";
"        Backbone.history.start({pushState: true});";
"";
"        {{#id}}";
"          moo.navigate('/objects/{{id}}');";
"        {{/id}}";
"      });";
"    </script>";
"    {{> _foot}}";
"  </body>";
"</html>";
"";
"chunk_length:51";
"chunk_type:source";
"content_type:application/x-mustache";
"sha1:DF0E9237C2D63F33AABC361455BB1D682EC3C596";
"-=-=-mxyzptlk-=-=-";
.
#117:0
$restrict_to_caller($dialog.server);
{request, response} = args;
credentials = `request:parameters()["credentials"] ! E_RANGE => ""';
if (valid(player = $authenticate(@credentials:split())))
set_task_local(task_local():merge(["http" -> ["session" -> ["player" -> player]]]));
endif
response = response:set_status(302):set_location(request:parameters()["__url_base__"] + "/"):set_body("");
return {request, response};
return;
"$restrict_to_caller($dialog.server);";
"";
"{request, response} = args;";
"";
"credentials = `request:parameters()[\"credentials\"] ! E_RANGE => \"\"';";
"";
"if (valid(player = $authenticate(@credentials:split())))";
"  /* blow away the session; set the player */";
"  set_task_local(task_local():merge([\"http\" -> [\"session\" -> [\"player\" -> player]]]));";
"endif";
"";
"response = response:set_status(302):set_location(request:parameters()[\"__url_base__\"] + \"/\"):set_body(\"\");";
"";
"return {request, response};";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:DAC9458114344DEAB4B92F9B49BDC1366C09400B";
"-=-=-mxyzptlk-=-=-";
.
#117:1
$restrict_to_caller($dialog.server);
{request, response} = args;
set_task_local(task_local():merge(["http" -> ["session" -> ["player" -> $nothing]]]));
response = response:set_status(302):set_location(request:parameters()["__url_base__"] + "/"):set_body("");
return {request, response};
return;
"$restrict_to_caller($dialog.server);";
"";
"{request, response} = args;";
"";
"/* blow away the session; reset the player */";
"set_task_local(task_local():merge([\"http\" -> [\"session\" -> [\"player\" -> $nothing]]]));";
"";
"response = response:set_status(302):set_location(request:parameters()[\"__url_base__\"] + \"/\"):set_body(\"\");";
"";
"return {request, response};";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:8E330B8306793720181DC1854F85CC058D806C87";
"-=-=-mxyzptlk-=-=-";
.
#120:0
$restrict_to_caller($dialog.server);
{request} = args;
path = request:path():split("/");
method = request:method();
{host, ?port = 80} = `request:headers()["host"]:split(":") ! E_RANGE => {""}';
parameters = ["__base_uri__" -> host ? tostr("http://", host, ":", port) | "", "__connection__" -> player];
if ((!path) && (method == "get"))
return {$lookup("home_controller"), "home", parameters};
elseif (((length(path) == 2) && (path[1] == "objects")) && (method == "get"))
return {$lookup("home_controller"), "browse", parameters:merge(["id" -> path[2]])};
elseif ((path == {"session", "create"}) && (method == "post"))
return {$lookup("session_controller"), path[2], parameters};
elseif ((path == {"session", "destroy"}) && (method == "post"))
return {$lookup("session_controller"), path[2], parameters};
endif
return {};
return;
"$restrict_to_caller($dialog.server);";
"";
"{request} = args;";
"";
"path = request:path():split(\"/\");";
"method = request:method();";
"";
"{host, ?port = 80} = `request:headers()[\"host\"]:split(\":\") ! E_RANGE => {\"\"}';";
"";
"parameters = [";
"  \"__base_uri__\" -> host ? tostr(\"http://\", host, \":\", port) | \"\",";
"  \"__connection__\" -> player";
"];";
"";
"if (!path && method == \"get\")";
"  return {$lookup(\"home_controller\"), \"home\", parameters};";
"elseif (length(path) == 2 && path[1] == \"objects\" && method == \"get\")";
"  return {$lookup(\"home_controller\"), \"browse\", parameters:merge([\"id\" -> path[2]])};";
"elseif (path == {\"session\", \"create\"} && method == \"post\")";
"  return {$lookup(\"session_controller\"), path[2], parameters};";
"elseif (path == {\"session\", \"destroy\"} && method == \"post\")";
"  return {$lookup(\"session_controller\"), path[2], parameters};";
"endif";
"";
"return {};";
"";
"chunk_length:25";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:79918BB91D0319737CE40A30069282AA30854424";
"-=-=-mxyzptlk-=-=-";
.
